#!/usr/bin/env python
"""py-web-lp Literate Programming.

Yet another simple literate programming tool derived from **nuweb**, 
implemented entirely in Python.
With a suitable configuration, this weaves documents with any markup language,
and tangles source files for any programming language.
"""
__version__ = """3.2"""

### DO NOT EDIT THIS FILE!
### It was created by pyweb.py, __version__='3.2'.
### From source impl.w modified Tue Jul 11 09:03:19 2023.
### In working directory '/Users/slott/Documents/Projects/py-web-tool/src'.

from collections import defaultdict
from collections.abc import Iterator
from dataclasses import dataclass, field
from functools import cache
import logging
from pathlib import Path
from types import SimpleNamespace
from typing import Any, Optional, Literal, ClassVar, Union
from weakref import ref, ReferenceType
from typing import TypeGuard, TypeVar, Generic
import abc
from textwrap import dedent, shorten
from jinja2 import Environment, DictLoader, select_autoescape
import filecmp
import tempfile
import os
import builtins
import sys
import platform

from typing import TextIO, cast
import re
from collections.abc import Iterator, Iterable

import argparse
import shlex

import logging
import logging.config

import os
import time
import datetime
import sys
import types

if sys.version_info[:2] <= (3, 10):
    import tomli as toml
else:
    import tomllib as toml



class Error(Exception): pass




_T = TypeVar("_T")

class TypeId:
    """
    This makes a given class name into an attribute with a 
    True value. Any other attribute reference will return False.
    
    >>> class A:
    ...     typeid = TypeId()
    >>> a = A()
    >>> a.typeid.A 
    True
    >>> a.typeid.B
    False
    """             
    def __set_name__(self, owner: type[_T], name: str) -> "TypeId":
        self.my_class = owner
        return self

    def __getattr__(self, item: str) -> TypeGuard[_T]:
        return self.my_class.__name__ == item
        
from collections.abc import Mapping

class TypeIdMeta(type):
    """Inject the ``typeid`` attribute into a class definition."""
    @classmethod
    def __prepare__(metacls, name: str, bases: tuple[type, ...], **kwds: Any) -> Mapping[str, object]:  # type: ignore[override]
        return {"typeid": TypeId()}




class Command(metaclass=TypeIdMeta):
    typeid: TypeId
    has_name: TypeGuard["ReferenceCommand"] = False
    has_text: TypeGuard[Union["CodeCommand", "TextCommand"]] = False
        
    def __init__(self, location: tuple[str, int]) -> None:
        self.location = location  #: The (filename, line number)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.web: ReferenceType["Web"]
        self.text: str  #: The body of this command
        
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(location={self.location!r})"
        
    @abc.abstractmethod
    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        ...



HasText = Union["CodeCommand", "TextCommand"]



class TextCommand(Command):
    """Text outside any other command."""    
    has_text: TypeGuard[Union["CodeCommand", "TextCommand"]] = True
    
    def __init__(self, text: str, location: tuple[str, int]) -> None:
        super().__init__(location)
        self.text = text  #: The text
            
    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        message = f"attempt to tangle a text block {self.location} {shorten(self.text, 32)!r}"
        self.logger.error(message)
        raise Error(message)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(text={self.text!r}, location={self.location!r})"


class CodeCommand(Command):
    """Code inside a ``@o``, or ``@d`` command."""    
    has_text: TypeGuard[Union["CodeCommand", "TextCommand"]] = True

    def __init__(self, text: str, location: tuple[str, int]) -> None:
        super().__init__(location)
        self.text = text  #: The text

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        self.logger.debug(f"tangle {self.text=!r}")
        aTangler.codeBlock(target, self.text)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(text={self.text!r}, location={self.location!r})"


class ReferenceCommand(Command):
    """
    Reference to a ``NamedChunk`` in code, a ``@< name @>`` construct.
    In a CodeChunk or OutputChunk, it tangles to the definition from a ``NamedChunk``.
    In text, it can weave to the text of a ``NamedDocumentChunk``.
    """    
    has_name: TypeGuard["ReferenceCommand"] = True

    def __init__(self, name: str, location: tuple[str, int]) -> None:
        super().__init__(location)
        self.name = name  #: The name that is referenced.
    
    @property
    def full_name(self) -> str:
        return cast(Web, self.web()).resolve_name(self.name)

    @property
    def seq(self) -> int | None:
        return cast(Web, self.web()).resolve_chunk(self.name)[0].seq

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        """Expand this reference.
        The starting position is the indentation for all **subsequent** lines.
        Provide the indent before ``@<``, in ``tangler.fragment`` back to the tangler. 
        """
        self.logger.debug(f"tangle reference to {self.name=}, context: {aTangler.fragment=}")
        chunk_list = cast(Web, self.web()).resolve_chunk(self.name)
        if len(chunk_list) == 0:
            message = f"Attempt to tangle an undefined Chunk, {self.name!r}"
            self.logger.error(message)
            raise Error(message) 
        aTangler.reference_names.add(self.name)
        aTangler.addIndent(len(aTangler.fragment))
        aTangler.fragment = ""

        for chunk in chunk_list:
            # TODO: if chunk.options includes '-indent': do a setIndent before tangling.
            for command in chunk.commands:
                command.tangle(aTangler, target)
                
        aTangler.clrIndent()

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name={self.name!r}, location={self.location!r})"


class FileXrefCommand(Command):
    """The ``@f`` command."""    
    def __init__(self, location: tuple[str, int]) -> None:
        super().__init__(location)

    @property
    def files(self) -> list["OutputChunk"]:
        return cast(Web, self.web()).files

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        raise Error('Illegal tangling of a cross reference command.')

class MacroXrefCommand(Command):
    """The ``@m`` command."""    
    def __init__(self, location: tuple[str, int]) -> None:
        super().__init__(location)

    @property
    def macros(self) -> list[SimpleNamespace]:
        return cast(Web, self.web()).macros

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        raise Error('Illegal tangling of a cross reference command.')

class UserIdXrefCommand(Command):
    """The ``@u`` command."""    
    def __init__(self, location: tuple[str, int]) -> None:
        super().__init__(location)

    @property
    def userids(self) -> list[SimpleNamespace]:
        return cast(Web, self.web()).userids
        
    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        raise Error('Illegal tangling of a cross reference command.')




@dataclass
class Chunk:
    """Superclass for OutputChunk, NamedChunk, NamedDocumentChunk.
    """
    #: Short name of the chunk.
    name: str | None = None
    
    #: Unique sequence number of chunk in the WEB.
    seq: int | None = None  
    
    #: Sequence of commands inside this chunk.
    commands: list["Command"] = field(default_factory=list)
    
    #: Parsed options for @d and @o chunks.  
    options: list[str] = field(default_factory=list)  
    
    #: Names defined after ``@|`` in this chunk.
    def_names: list[str] = field(default_factory=list)
      
    #: Is this the first use of a given Chunk name?     
    initial: bool = False  
    
    #: If injecting location details whenm tangling, this is the comment prefix.
    comment_start: str | None = None
    
    #: If injecting location details, this is the comment suffix. 
    comment_end: str | None = None  

    #: Count of references to this Chunk.
    references: int = field(init=False, default=0)
    
    #: The immediate reference to this chunk.
    referencedBy: Optional["Chunk"] = field(init=False, default=None)
    
    #: Weak reference to the ``Web`` containing this ``Chunk``.
    web: ReferenceType["Web"] = field(init=False, repr=False)
    
    #: Logger for any chunk-specific messages.
    logger: logging.Logger = field(init=False, default=logging.getLogger("Chunk"))

    @property
    def full_name(self) -> str | None:
        if self.name:
            return cast(Web, self.web()).resolve_name(self.name)
        else:
            return None

    @property
    def path(self) -> Path | None:
        return None

    @property
    def location(self) -> tuple[str, int]:
        return self.commands[0].location

    @property
    def transitive_referencedBy(self) -> list["Chunk"]:
        if self.referencedBy:
            return [self.referencedBy] + self.referencedBy.transitive_referencedBy
        else:
            return []
        
    def add_text(self, text: str, location: tuple[str, int]) -> "Chunk":
        if self.commands and self.commands[-1].typeid.TextCommand:
            cast(HasText, self.commands[-1]).text += text
        else:
            # Empty list OR previous command was not ``TextCommand``
            self.commands.append(TextCommand(text, location))
        return self
             
    def type_is(self, name: str) -> bool:
        """
        Instead of type name matching, we could check for these features:
        - has_code() (i.e., NamedChunk and OutputChunk)
        - has_text() (i.e., Chunk and NamedDocumentChunk)
        This is for template rendering, where proper Liskov
        Substitution is irrelevant.
        """
        return self.__class__.__name__ == name

class OutputChunk(Chunk):
    """An output file."""
    @property
    def path(self) -> Path | None:
        if self.name:
            return Path(self.name)
        else:
            return None

    @property
    def full_name(self) -> str | None:
        return None

    def add_text(self, text: str, location: tuple[str, int]) -> Chunk:
        if self.commands and self.commands[-1].typeid.CodeCommand:
            cast(HasText, self.commands[-1]).text += text
        else:
            # Empty list OR previous command was not ``CodeCommand``
            self.commands.append(CodeCommand(text, location))
        return self
             
class NamedChunk(Chunk): 
    """A defined name with code."""
    def add_text(self, text: str, location: tuple[str, int]) -> Chunk:
        if self.commands and self.commands[-1].typeid.CodeCommand:
            cast(HasText, self.commands[-1]).text += text
        else:
            # Empty list OR previous command was not ``CodeCommand``
            self.commands.append(CodeCommand(text, location))
        return self
             
class NamedChunk_Noindent(Chunk):
    """A defined name with code and the -noIndent option."""
    pass

class NamedDocumentChunk(Chunk): 
    """A defined name with text."""
    pass




@dataclass
class Web:
    chunks: list["Chunk"]  #: The source sequence of chunks.

    # The ``@d`` chunk names and locations where they're defined.
    chunk_map: dict[str, list["Chunk"]] = field(init=False)
    
    # The ``@|`` defined names and chunks with which they're associated.
    userid_map: defaultdict[str, list["Chunk"]] = field(init=False)
        
    logger: logging.Logger = field(init=False, default=logging.getLogger("Web"))
    
    web_path: Path = field(init=False)  #: Source WEB file; set by ```WebParse``

    strict_match: ClassVar[bool] = True  #: Report ... names without a definition.


    def __post_init__(self) -> None:
        """
        Populate weak references throughout the web to make full_name properties work.
        Then. Locate all macro definitions and userid references. 
        """
        # Pass 1 -- set all Chunk and Command back references.
        for c in self.chunks:
            c.web = ref(self)
            for cmd in c.commands:
                cmd.web = ref(self)
                
        # Named Chunks = Union of macro_iter and file_iter
        named_chunks = list(filter(lambda c: c.name is not None, self.chunks))

        # Pass 2 -- locate the unabbreviated names in chunks and references to chunks.
        self.chunk_map = {}
        for seq, c in enumerate(named_chunks, start=1):
            c.seq = seq
            if not c.path:
                # Use ``@d name`` chunks (reject ``@o`` and text)
                if c.name and not c.name.endswith('...'):
                    self.logger.debug(f"__post_init__ 2a {c.name=!r}")
                    self.chunk_map.setdefault(c.name, [])
            for cmd in c.commands:
                # Find ``@< name @>`` in ``@d name`` chunks or ``@o`` chunks 
                if cmd.has_name:
                    if not cast(ReferenceCommand, cmd).name.endswith('...'):
                        self.logger.debug(f"__post_init__ 2b {cast(ReferenceCommand, cmd).name=!r}")
                        self.chunk_map.setdefault(cast(ReferenceCommand, cmd).name, [])
                    
        # Pass 3 -- accumulate chunk lists, output lists, and name definition lists.
        self.userid_map = defaultdict(list)
        for c in named_chunks:
            for name in c.def_names:
                self.userid_map[name].append(c)
            if not c.path:
                # Named ``@d name`` chunks
                if full_name := c.full_name:
                    c.initial = len(self.chunk_map[full_name]) == 0
                    self.chunk_map[full_name].append(c)
                    self.logger.debug(f"__post_init__ 3 {c.name=!r} -> {c.full_name=!r}")
            else:
                # Output ``@o`` and anonymous chunks.
                # Assume all @o chunks are unique. If they're not, they overwrite each other.
                # Also, there's not ``full_name`` for these chunks.
                c.initial = True
                
            # TODO: Accumulate all chunks that contribute to a named file...

        # Pass 4 -- set referencedBy a command in a chunk.
        # ONLY set this in references embedded in named chunk or output chunk.
        # In a generic Chunk (which is text) there's no anchor to refer to.
        # NOTE: Assume single references *only*
        # We should raise an exception when updating a non-None referencedBy value.
        # Or incrementing ref_chunk.references > 1.
        for c in named_chunks:
            for cmd in c.commands:
                if cmd.has_name:
                    ref_to_list = self.resolve_chunk(cast(ReferenceCommand, cmd).name)
                    for ref_chunk in ref_to_list:
                        ref_chunk.referencedBy = c
                        ref_chunk.references += 1
            
    def __repr__(self) -> str:
        NL = ",\n"
        return (
            f"{self.__class__.__name__}("
            f"{NL.join(repr(c) for c in self.chunks)}"
            f")"
        )

    def resolve_name(self, target: str) -> str:
        """Map short names to full names, if possible."""
        if target in self.chunk_map:
            # self.logger.debug(f"resolve_name {target=} in self.chunk_map")
            return target
        elif target.endswith('...'):
            # The ... is equivalent to regular expression .*
            matches = list(
                c_name
                for c_name in self.chunk_map
                if c_name.startswith(target[:-3])
            )
            match : str
            # self.logger.debug(f"resolve_name {target=} {matches=} in self.chunk_map")
            match matches:
                case []:
                    if self.strict_match:
                        raise Error(f"No full name for {target!r}")
                    else:
                        self.logger.warning(f"resolve_name {target=} unknown")
                        self.chunk_map[target] = []
                    match = target
                case [head]:
                    match = head
                case [head, *tail]:
                    message = f"Ambiguous abbreviation {target!r}, matches {[head] + tail!r}"
                    raise Error(message)
            return match
        else:
            self.logger.warning(f"resolve_name {target=} unknown")
            self.chunk_map[target] = []
            return target

    def resolve_chunk(self, target: str) -> list["Chunk"]:
        """Map name (short or full) to the defining sequence of chunks."""
        full_name = self.resolve_name(target)
        chunk_list = self.chunk_map[full_name]
        self.logger.debug(f"resolve_chunk {target=!r} -> {full_name=!r} -> {chunk_list=}")
        return chunk_list

    def file_iter(self) -> Iterator[OutputChunk]:
        return (cast(OutputChunk, c) for c in self.chunks if c.type_is("OutputChunk"))

    def macro_iter(self) -> Iterator[NamedChunk]:
        return (cast(NamedChunk, c) for c in self.chunks if c.type_is("NamedChunk"))

    def userid_iter(self) -> Iterator[SimpleNamespace]:
        yield from (SimpleNamespace(def_name=n, chunk=c) for c in self.file_iter() for n in c.def_names)
        yield from (SimpleNamespace(def_name=n, chunk=c) for c in self.macro_iter() for n in c.def_names)

    @property
    def files(self) -> list["OutputChunk"]:
        return list(self.file_iter())

    @property
    def macros(self) -> list[SimpleNamespace]:
        """
        The chunk_map has the list of Chunks that comprise a macro definition.
        We separate those to make it slightly easier to format the first definition.
        """
        first_list = (
            (self.chunk_map[name][0], self.chunk_map[name])
            for name in sorted(self.chunk_map)
            if self.chunk_map[name]
        )
        macro_list = list(
            SimpleNamespace(name=first_def.name, full_name=first_def.full_name, seq=first_def.seq, def_list=def_list)
            for first_def, def_list in first_list
        )
        # self.logger.debug(f"macros: {defs}")
        return macro_list

    @property
    def userids(self) -> list[SimpleNamespace]:
        userid_list = list(
            SimpleNamespace(userid=userid, ref_list=self.userid_map[userid])
            for userid in sorted(self.userid_map)
        )
        # self.logger.debug(f"userids: {userid_list}")
        return userid_list
            
    def no_reference(self) -> list[Chunk]:
        return list(filter(lambda c: c.name and not c.path and c.references == 0, self.chunks))
        
    def multi_reference(self) -> list[Chunk]:
        return list(filter(lambda c: c.name and not c.path and c.references > 1, self.chunks))




class Emitter(abc.ABC):
    def __init__(self, output: Path): 
        self.logger = logging.getLogger(self.__class__.__qualname__)
        self.log_indent = logging.getLogger("indent." + self.__class__.__qualname__)
        self.output = output
    
    @abc.abstractmethod
    def emit(self, web: Web) -> None:
        pass




def debug_quote_rules(text: str) -> str:
    return repr(text)
    
debug_weaver_template = dedent("""\
    {%- macro text(command) -%}
    text: {{command}}
    {%- endmacro -%}
    
    {%- macro begin_code(chunk) %}
    begin_code: {{chunk}}
    {%- endmacro -%}
    
    {%- macro code(command) %}
    code: {{command}}
    {%- endmacro -%}
    
    {%- macro ref(id) %}
    ref: {{id}}
    {%- endmacro -%}
    
    {%- macro end_code(chunk) %}
    end_code: {{chunk}}
    {% endmacro -%}
    
    {%- macro file_xref(command) -%}
    file_xref {{command.files}}
    {%- endmacro -%}
    
    {%- macro macro_xref(command) -%}
    macro_xref {{command.macros}}
    {%- endmacro -%}

    {%- macro userid_xref(command) -%}
    userid_xref {{command.userids}}
    {%- endmacro -%}
    """)




def rst_quote_rules(text: str) -> str:
    quoted_chars = [
        ('\\', r'\\'), # Must be first.
        ('`', r'\`'),
        ('_', r'\_'), 
        ('*', r'\*'),
        ('|', r'\|'),
    ]
    clean = text
    for from_, to_ in quoted_chars:
        clean = clean.replace(from_, to_)
    return clean
    
rst_weaver_template = dedent("""
    {%- macro text(command) -%}
    {{command.text}}
    {%- endmacro -%}
    
    {%- macro begin_code(chunk) %}
    ..  _`{{chunk.full_name or chunk.name}} ({{chunk.seq}})`:
    ..  rubric:: {{chunk.full_name or chunk.name}} ({{chunk.seq}}) {% if chunk.initial %}={% else %}+={% endif %}
    ..  parsed-literal::
        :class: code
        
    {% endmacro -%}

    {# For RST, each line must be indented. #}    
    {%- macro code(command) %}{% for line in command.text.splitlines() %}    {{line | quote_rules}}
    {% endfor -%}{% endmacro -%}
    
    {%- macro ref(id) %}    \N{RIGHTWARDS ARROW} `{{id.full_name or id.name}} ({{id.seq}})`_{% endmacro -%}
    
    {# When using Sphinx, this *could* be rst-class::, pure docutils uses container::#}
    {%- macro end_code(chunk) %}
    ..
    
    ..  container:: small
    
        \N{END OF PROOF} *{{chunk.full_name or chunk.name}} ({{chunk.seq}})*.
        {% if chunk.referencedBy %}Used by {{ref(chunk.referencedBy)}}.{% endif %}
        
    {% endmacro -%}
    
    {%- macro file_xref(command) -%}
    {% for file in command.files -%}
    :{{file.name}}:
        \N{RIGHTWARDS ARROW} `{{file.name}} ({{file.seq}})`_
    {%- endfor %}
    {%- endmacro -%}
    
    {%- macro macro_xref(command) -%}
    {% for macro in command.macros -%}
    :{{macro.full_name}}:
        {% for d in macro.def_list -%}\N{RIGHTWARDS ARROW} `{{d.full_name or d.name}} ({{d.seq}})`_{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
        
    {% endfor %}
    {%- endmacro -%}

    {%- macro userid_xref(command) -%}
    {% for userid in command.userids -%}
    :{{userid.userid}}:
        {% for r in userid.ref_list -%}\N{RIGHTWARDS ARROW} `{{r.full_name or r.name}} ({{r.seq}})`_{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
        
    {% endfor %}
    {%- endmacro -%}
    """)

rst_overrides_template = dedent("""\
    """)
    
rst_nosphinx_template = dedent("""\
    {%- macro end_code(chunk) %}
    ..
    
    ..  class:: small
    
        \N{END OF PROOF} *{{chunk.full_name or chunk.name}} ({{chunk.seq}})*
        
    {% endmacro -%}
    """)



def html_quote_rules(text: str) -> str:
    quoted_chars = [
        ("&", "&amp;"),  # Must be first
        ("<", "&lt;"),
        (">", "&gt;"),
        ('"', "&quot;"),  # Only applies inside tags...
    ]
    clean = text
    for from_, to_ in quoted_chars:
        clean = clean.replace(from_, to_)
    return clean

html_weaver_template = dedent("""\
    {%- macro text(command) -%}
    {{command.text}}
    {%- endmacro -%}
    
    {%- macro begin_code(chunk) %}
    <a name="pyweb_{{chunk.seq}}"></a>
    <!--line number {{chunk.location}}-->
    <p><em>{{chunk.full_name or chunk.name}} ({{chunk.seq}})</em> {% if chunk.initial %}={% else %}+={% endif %}</p>
    <pre><code>
    {%- endmacro -%}
    
    {%- macro code(command) -%}{{command.text | quote_rules}}{%- endmacro -%}
    
    {%- macro ref(id) %}&rarr;<a href="#pyweb_{{id.seq}}"><em>{{id.full_name or id.name}} ({{id.seq}})</em></a>{% endmacro -%}
    
    {%- macro end_code(chunk) %}
    </code></pre>
    <p>&#8718; <em>{{chunk.full_name or chunk.name}} ({{chunk.seq}})</em>.
    {% if chunk.referencedBy %}Used by {{ref(chunk.referencedBy)}}.{% endif %}
    </p> 
    {% endmacro -%}
    
    {%- macro file_xref(command) %}
    <dl>
    {% for file in command.files -%}
      <dt>{{file.name}}</dt><dd>{{ref(file)}}</dd>
    {%- endfor %}
    </dl>
    {% endmacro -%}
    
    {%- macro macro_xref(command) %}
    <dl>
    {% for macro in command.macros -%}
      <dt>{{macro.full_name}}<dt>
      <dd>{% for d in macro.def_list -%}{{ref(d)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}</dd>
    {% endfor %}
    </dl>
    {% endmacro -%}

    {%- macro userid_xref(command) %}
    <dl>
    {% for userid in command.userids -%}
      <dt>{{userid.userid}}</dt>
      <dd>{% for r in userid.ref_list -%}{{ref(r)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}</dd>
    {% endfor %}
    </dl>
    {% endmacro -%}
    """)

html_overrides_template = dedent("""\
    """)
 


def latex_quote_rules(text: str) -> str:
    quoted_strings = [
        ("\\end{Verbatim}", "\\end\\,{Verbatim}"),  # Allow \end{Verbatim} in a Verbatim context
        ("\\{", "\\\\,{"), # Prevent unexpected commands in Verbatim
        ("$", "\\$"), # Prevent unexpected math in Verbatim
    ]
    clean = text
    for from_, to_ in quoted_strings:
        clean = clean.replace(from_, to_)
    return clean

latex_weaver_template = dedent("""\
    {%- macro text(command) -%}
    {{command.text}}
    {%- endmacro -%}
    
    {%- macro begin_code(chunk) %}
    \\label{pyweb-{{chunk.seq}}}
    \\begin{flushleft}
    \\textit{Code example {{chunk.full_name or chunk.name}} ({{chunk.seq}})}
    \\begin{Verbatim}[commandchars=\\\\\\{\\},codes={\\catcode`$$=3\\catcode`^=7},frame=single]
    {%- endmacro -%}
    
    {%- macro code(command) -%}{{command.text | quote_rules}}{%- endmacro -%}
    
    {%- macro ref(id) %}$$\\rightarrow$$ Code Example {{id.full_name or id.name}} ({{id.seq}}){% endmacro -%}
    
    {%- macro end_code(chunk) %}
    \\end{Verbatim}
    \\end{flushleft}
    {% endmacro -%}
    
    {%- macro file_xref(command) %}
    \\begin{itemize}
    {% for file in command.files -%}
      \\item {{file.name}}: {{ref(file)}}
    {%- endfor %}
    \\end{itemize}
    {% endmacro -%}
    
    {%- macro macro_xref(command) %}
    \\begin{itemize}
    {% for macro in command.macros -%}
      \\item {{macro.full_name}} \\\\
            {% for d in macro.def_list -%}{{ref(d)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
    {% endfor %}
    \\end{itemize}
    {% endmacro -%}

    {%- macro userid_xref(command) %}
    \\begin{itemize}
    {% for userid in command.userids -%}
      \\item {{userid.userid}} \\\\
            {% for r in userid.ref_list -%}{{ref(r)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
    {% endfor %}
    \\end{itemize}
    {% endmacro -%}
    """)

tex_overrides_template = dedent("""\
    """)

 


base_template = dedent("""\
    {%- from macros import text, begin_code, code, ref, end_code, file_xref, macro_xref, userid_xref -%}
    {%- if not text is defined %}{%- from defaults import text -%}{%- endif -%}
    {%- if not begin_code is defined %}{%- from defaults import begin_code -%}{%- endif -%}
    {%- if not code is defined %}{%- from defaults import code -%}{%- endif -%}
    {%- if not ref is defined %}{%- from defaults import ref -%}{%- endif -%}
    {%- if not end_code is defined %}{%- from defaults import end_code -%}{%- endif -%}
    {%- if not file_xref is defined %}{%- from defaults import file_xref -%}{%- endif -%}
    {%- if not macro_xref is defined %}{%- from defaults import macro_xref -%}{%- endif -%}
    {%- if not userid_xref is defined %}{%- from defaults import userid_xref -%}{%- endif -%}
    {% for chunk in web.chunks -%}
        {%- if chunk.type_is('OutputChunk') or chunk.type_is('NamedChunk') -%}
            {{begin_code(chunk)}}
            {%- for command in chunk.commands -%}
                {%- if command.typeid.CodeCommand -%}{{code(command)}}
                {%- elif command.typeid.ReferenceCommand -%}{{ref(command)}}
                {%- endif -%}
            {%- endfor -%}
            {{end_code(chunk)}}
        {%- elif chunk.type_is('Chunk') -%}
            {%- for command in chunk.commands -%}
                {%- if command.typeid.TextCommand %}{{text(command)}}
                {%- elif command.typeid.ReferenceCommand %}{{ref(command)}}
                {%- elif command.typeid.FileXrefCommand %}{{file_xref(command)}}
                {%- elif command.typeid.MacroXrefCommand %}{{macro_xref(command)}}
                {%- elif command.typeid.UserIdXrefCommand %}{{userid_xref(command)}}
                {%- endif -%}
            {%- endfor -%}
        {%- endif -%}
    {%- endfor %}
""")


class Weaver(Emitter):
    template_map = {
        "debug_defaults": debug_weaver_template, "debug_macros": "",
        "rst_defaults": rst_weaver_template, "rst_macros": rst_overrides_template,
        "html_defaults": html_weaver_template, "html_macros": html_overrides_template,
        "tex_defaults": latex_weaver_template, "tex_macros": tex_overrides_template,

        "rst-sphinx_defaults": rst_weaver_template, "rst-sphinx_macros": rst_overrides_template, 
        "rst-nosphinx_defaults": rst_weaver_template, "rst-nosphinx_macros": rst_nosphinx_template, 
        "rst-docutils_defaults": rst_weaver_template, "rst-docutils_macros": rst_nosphinx_template, 
    }
        
    quote_rules = {
        "rst": rst_quote_rules,
        "html": html_quote_rules,
        "tex": latex_quote_rules,
        "debug": debug_quote_rules,
    }

    def __init__(self, output: Path = Path.cwd()) -> None:
        super().__init__(output)
        # Summary
        self.linesWritten = 0
        
    def set_markup(self, markup: str = "rst") -> "Weaver":
        self.markup = markup
        return self
        
    def emit(self, web: Web) -> None:
        self.target_path = (self.output / web.web_path.name).with_suffix(f".{self.markup}")
        self.logger.info("Weaving %s using %s markup", self.target_path, self.markup)
        with self.target_path.open('w') as target_file:
            for text in self.generate_text(web):
                self.linesWritten += text.count("\n")
                target_file.write(text)
                
    def generate_text(self, web: Web) -> Iterator[str]:
        self.env = Environment(
            loader=DictLoader(
                self.template_map | 
                {'base_weaver': base_template,}
            ),
            autoescape=select_autoescape()
        )
        self.env.filters |= {
            "quote_rules": self.quote_rules[self.markup]
        }
        defaults = self.env.get_template(f"{self.markup}_defaults")
        macros = self.env.get_template(f"{self.markup}_macros")
        template = self.env.get_template("base_weaver")
        return template.generate(web=web, macros=macros, defaults=defaults)



class Tangler(Emitter):
    code_indent = 0  #: Initial indent

    def __init__(self, output: Path = Path.cwd()) -> None:
        super().__init__(output)
        self.context: list[int] = []  #: Indentations
        self.fragment = ""  # Nothing written yet.
        # Create context and initial lastIndent values
        self.resetIndent(self.code_indent)
        # Summaries
        self.reference_names: set[str] = set()
        self.linesWritten = 0
        self.totalFiles = 0
        self.totalLines = 0

    def emit(self, web: Web) -> None:
        for file_chunk in web.files:
            self.logger.info("Tangling %s", file_chunk.name)
            self.emit_file(web, file_chunk)
            
    def emit_file(self, web: Web, file_chunk: Chunk) -> None:
        target_path = self.output / (file_chunk.name or "Untitled.out")
        self.logger.debug("Writing %s", target_path)
        self.logger.debug("Chunk %r", file_chunk)
        with target_path.open("w") as target:
            # An initial command to provide indentations.
            for command in file_chunk.commands:
                command.tangle(self, target)
                
        
    def codeBlock(self, target: TextIO, text: str) -> None:
        """Indented write of text in a ``CodeCommand``. 
        Counts lines and saves position to indent to when expanding ``@<...@>`` references.
        
        The ``fragment`` is the prevailing indent used in reference expansion.
        """
        for line in text.splitlines(keepends=True):
            self.logger.debug("codeBlock(%r)", line)
            indent = self.context[-1]
            if len(line) == 0:
                # Degenerate case of empty CodeText command. Should not occur.
                pass
            elif not line.endswith('\n'):
                # Possible start of indentation prior to a ``@<name@>``
                target.write(indent*' ')
                wrote = target.write(line)
                self.fragment = ' ' * wrote
                # May be used by a ``ReferenceCommand``, if needed.
            elif line.endswith('\n'):
                target.write(indent*' ')
                target.write(line)
                self.linesWritten += 1
            else:
                raise RuntimeError("Non-exhaustive if statement.")
    
    


        
    def addIndent(self, increment: int) -> None:
        self.lastIndent = self.context[-1]+increment
        self.context.append(self.lastIndent)
        self.log_indent.debug("addIndent %d: %r", increment, self.context)
        self.fragment = ""
        
    def setIndent(self, indent: int) -> None:
        self.context.append(indent)
        self.lastIndent = self.context[-1]
        self.log_indent.debug("setIndent %d: %r", indent, self.context)
        self.fragment = ""
    
    def clrIndent(self) -> None:
        if len(self.context) > 1:
            self.context.pop()
        self.lastIndent = self.context[-1]
        self.log_indent.debug("clrIndent %r", self.context)
        self.fragment = ""
    
    def resetIndent(self, indent: int = 0) -> None:
        """Resets the indentation context."""
        self.lastIndent = indent
        self.context = [self.lastIndent]
        self.log_indent.debug("resetIndent %d: %r", indent, self.context)
    

 


class TanglerMake(Tangler):
    def emit_file(self, web: Web, file_chunk: Chunk) -> None:
        target_path = self.output / (file_chunk.name or "Untitled.out")
        self.logger.debug("Writing %s via a temp file", target_path)
        self.logger.debug("Chunk %r", file_chunk)

        fd, tempname = tempfile.mkstemp(dir=os.curdir)
        with os.fdopen(fd, "w") as target:
            for command in file_chunk.commands:
                command.tangle(self, target)
                
        try:
            same = filecmp.cmp(tempname, target_path)
        except OSError as e:
            same = False  # Doesn't exist. (Could check for errno.ENOENT)
            
        if same:
            self.logger.info("Unchanged '%s'", target_path)
            os.remove(tempname)
        else:
            # Windows requires the original file name be removed first.
            try: 
                target_path.unlink()
            except OSError as e:
                pass  # Doesn't exist. (Could check for errno.ENOENT)
            target_path.parent.mkdir(parents=True, exist_ok=True)
            target_path.hardlink_to(tempname)
            os.remove(tempname)
            self.logger.info("Wrote %d lines to %s", self.linesWritten, target_path)



class Tokenizer(Iterator[str]):
    def __init__(self, stream: TextIO, command_char: str='@') -> None:
        self.command = command_char
        self.parsePat = re.compile(f'({self.command}.|\\n)')
        self.token_iter = (t for t in self.parsePat.split(stream.read()) if len(t) != 0)
        self.lineNumber = 0
        
    def __next__(self) -> str:
        token = next(self.token_iter)
        self.lineNumber += token.count('\n')
        return token
        
    def __iter__(self) -> Iterator[str]:
        return self




class WebReader:
    """Parse an input file, creating Chunks and Commands."""

    # Configuration
    #: The command prefix, default ``@``.
    command: str 
    #: Permitted errors, usually @i commands
    permitList: list[str]
    #: Working directory to resolve @i commands  
    base_path: Path  
    #: The tokenizer used to find commands
    tokenizer: Tokenizer  
    
    # State of the reader
    #: Parent context for @i commands      
    parent: Optional["WebReader"]
    #: Input Path 
    filePath: Path 
    #: Input file-like object, default is self.filePath.open()
    _source: TextIO  
    #: The sequence of Chunk instances being built
    content: list[Chunk] 
    
    def __init__(self, parent: Optional["WebReader"] = None) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)

        self.output_option_parser = argparse.ArgumentParser(add_help=False, exit_on_error=False)
        self.output_option_parser.add_argument("-start", dest='start', type=str, default=None)
        self.output_option_parser.add_argument("-end", dest='end', type=str, default="")
        self.output_option_parser.add_argument("argument", type=str, nargs="*")

        # TODO: Allow a numeric argument value in ``-indent``
        self.definition_option_parser = argparse.ArgumentParser(add_help=False, exit_on_error=False)
        self.definition_option_parser.add_argument("-indent", dest='indent', action='store_true', default=False)
        self.definition_option_parser.add_argument("-noindent", dest='noindent', action='store_true', default=False)
        self.definition_option_parser.add_argument("argument", type=str, nargs="*")

        # Configuration comes from the parent or defaults if there is no parent.
        self.parent = parent
        if self.parent: 
            self.command = self.parent.command
            self.permitList = self.parent.permitList
        else: # Defaults until overridden
            self.command = '@'
            self.permitList = []
                    
        # Summary
        self.totalLines = 0
        self.totalFiles = 0
        self.errors = 0 
        
                
        # Structural ("major") commands
        self.cmdo = self.command+'o'
        self.cmdd = self.command+'d'
        self.cmdlcurl = self.command+'{'
        self.cmdrcurl = self.command+'}'
        self.cmdlbrak = self.command+'['
        self.cmdrbrak = self.command+']'
        self.cmdi = self.command+'i'
        
        # Inline ("minor") commands
        self.cmdlangl = self.command+'<'
        self.cmdrangl = self.command+'>'
        self.cmdpipe = self.command+'|'
        self.cmdlexpr = self.command+'('
        self.cmdrexpr = self.command+')'
        self.cmdcmd = self.command+self.command
        
        # Content "minor" commands
        self.cmdf = self.command+'f'
        self.cmdm = self.command+'m'
        self.cmdu = self.command+'u'

        
    def __str__(self) -> str:
        return self.__class__.__name__
        
        
    def location(self) -> tuple[str, int]:
        return (str(self.filePath), self.tokenizer.lineNumber+1)
    

    
        
    def load(self, filepath: Path, source: TextIO | None = None) -> list[Chunk]:
        """Returns a flat list of chunks to be made into a Web. 
        Also used to expand ``@i`` included files.
        """
        self.filePath = filepath
        self.base_path = self.filePath.parent
    
        if source:
            self._source = source
            self.parse_source()
        else:
            with self.filePath.open() as self._source:
                self.parse_source()
        return self.content
    
    def parse_source(self) -> None:
        """Builds a sequence of Chunks."""
        self.tokenizer = Tokenizer(self._source, self.command)
        self.totalFiles += 1
    
        # Initial anonymous chunk.
        self.content = [Chunk()]
    
        for token in self.tokenizer:
            if len(token) >= 2 and token.startswith(self.command):
                if self.handleCommand(token):
                    continue
                else:
                    self.logger.error('Unknown @-command in input: %r near %r', token, self.location())
                    self.content[-1].add_text(token, self.location())
                    
            elif token:
                # Accumulate a non-empty block of text in the current chunk.
                self.content[-1].add_text(token, self.location())
    
            else:
                # Whitespace
                pass
        self.logger.debug("parse_source: [")
        for c in self.content:
            self.logger.debug("  %r", c)
        self.logger.debug("]")
    

    
        
    def handleCommand(self, token: str) -> bool:
        self.logger.debug("Reading %r", token)
        new_chunk: Optional[Chunk] = None
        match token[:2]:
            case self.cmdo:
                                
                arg_str = next(self.tokenizer)
                self.expect({self.cmdlcurl})
                options = self.output_option_parser.parse_args(shlex.split(arg_str))
                new_chunk = OutputChunk(
                    name=' '.join(options.argument),
                    comment_start=options.start if '-start' in options else "# ",
                    comment_end=options.end if '-end' in options else "",
                )
                self.content.append(new_chunk)
                # capture an OutputChunk up to @}
    
            case self.cmdd:
                                
                arg_str = next(self.tokenizer)
                brack = self.expect({self.cmdlcurl, self.cmdlbrak})
                options = self.definition_option_parser.parse_args(shlex.split(arg_str))
                name = ' '.join(options.argument)
                
                if brack == self.cmdlbrak:
                    new_chunk = NamedDocumentChunk(name)
                elif brack == self.cmdlcurl:
                    if 'noindent' in options and options.noindent:
                        new_chunk = NamedChunk_Noindent(name)
                    else:
                        new_chunk = NamedChunk(name)
                elif brack == None:
                    new_chunk = None
                    pass  # Error already noted by ``expect()``
                else:
                    raise RuntimeError("Design Error")
                
                if new_chunk:
                    self.content.append(new_chunk)
                # capture a NamedChunk up to @} or @]
    
            case self.cmdi:
                                
                incPath = Path(next(self.tokenizer).strip())
                try:
                    include = WebReader(parent=self)
                    if not incPath.is_absolute():
                        incPath = self.base_path / incPath
                    self.logger.info("Including '%s'", incPath)
                    self.content.extend(include.load(incPath))
                    self.totalLines += include.tokenizer.lineNumber
                    self.totalFiles += include.totalFiles
                    if include.errors:
                        self.errors += include.errors
                        self.logger.error("Errors in included file '%s', output is incomplete.", incPath)
                except Error as e:
                    self.logger.error("Problems with included file '%s', output is incomplete.", incPath)
                    self.errors += 1
                except IOError as e:
                    self.logger.error("Problems finding included file '%s', output is incomplete.", incPath)
                    # Discretionary -- sometimes we want to continue
                    if self.cmdi in self.permitList: pass
                    else: raise  # Seems heavy-handed, but, the file wasn't found!
                # Start a new context for text or commands *after* the ``@i``.
                self.content.append(Chunk())
    
            case self.cmdrcurl | self.cmdrbrak:
                                
                # Start a new context for text or commands *after* this command.
                self.content.append(Chunk())
    
            case self.cmdpipe:
                                
                try:
                    names = next(self.tokenizer).strip().split()
                    self.content[-1].def_names.extend(names)
                except AttributeError:
                    # Out of place @| user identifier command
                    self.logger.error("Unexpected references near %r: %r", self.location(), token)
                    self.errors += 1
    
            case self.cmdf:
                self.content[-1].commands.append(FileXrefCommand(self.location()))
            case self.cmdm:
                self.content[-1].commands.append(MacroXrefCommand(self.location()))
            case self.cmdu:
                self.content[-1].commands.append(UserIdXrefCommand(self.location()))
            case self.cmdlangl:
                                
                # get the name, introduce into the named Chunk dictionary
                name = next(self.tokenizer).strip()
                closing = self.expect({self.cmdrangl})
                self.content[-1].commands.append(ReferenceCommand(name, self.location()))
                self.logger.debug("Reading %r %r", name, closing)
    
            case self.cmdlexpr:
                                
                # get the Python expression, create the expression result
                expression = next(self.tokenizer)
                self.expect({self.cmdrexpr})
                try:
                    # Build Context
                    # **TODO:** Parts of this are static and can be built as part of ``__init__()``.
                    dangerous = {
                        'breakpoint', 'compile', 'eval', 'exec', 'execfile', 'globals', 'help', 'input', 
                        'memoryview', 'open', 'print', 'super', '__import__'
                    }
                    safe = types.SimpleNamespace(**dict(
                        (name, obj) 
                        for name,obj in builtins.__dict__.items() 
                        if name not in dangerous
                    ))
                    globals = dict(
                        __builtins__=safe, 
                        os=types.SimpleNamespace(path=os.path, getcwd=os.getcwd, name=os.name),
                        time=time,
                        datetime=datetime,
                        platform=platform,
                        theWebReader=self,
                        theFile=self.filePath,
                        thisApplication=sys.argv[0],
                        __version__=__version__,  # Legacy compatibility. Deprecated.
                        version=__version__,
                        theLocation=str(self.location()),  # The only thing that's dynamic
                        )
                    # Evaluate
                    result = str(eval(expression, globals))
                except Exception as exc:
                    self.logger.error('Failure to process %r: exception is %r', expression, exc)
                    self.errors += 1
                    result = f"@({expression!r}: Error {exc!r}@)"
                self.content[-1].add_text(result, self.location())
    
            case self.cmdcmd:
                                
                self.logger.debug(f"double-command: {self.content[-1]=}")
                self.content[-1].add_text(self.command, self.location())
    
            case self.cmdlcurl | self.cmdlbrak:
                # These should have been consumed as part of @o and @d parsing
                self.logger.error("Extra %r (possibly missing chunk name) near %r", token, self.location())
                self.errors += 1
            case _:
                return False  # did not recogize the command
        return True  # did recognize the command
    
    
    def expect(self, tokens: set[str]) -> str | None:
        """Compare next token with expectation, quietly skipping whitespace (i.e., ``\n``)."""
        try:
            t = next(self.tokenizer)
            while t == '\n':
                t = next(self.tokenizer)
        except StopIteration:
            self.logger.error("At %r: end of input, %r not found", self.location(), tokens)
            self.errors += 1
            return None
        if t in tokens:
            return t
        else:
            self.logger.error("At %r: expected %r, found %r", self.location(), tokens, t)
            self.errors += 1
            return None
    





class Action:
    """An action performed by pyWeb."""
    start: float
    options: argparse.Namespace

    def __init__(self, name: str) -> None:
        self.name = name
        self.logger = logging.getLogger(self.__class__.__qualname__)

    def __str__(self) -> str:
        return f"{self.name!s} [{self.options.web!s}]"
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        self.logger.info("Starting %s", self.name)
        self.options = options
        self.start = time.process_time()
    

    
        
    def duration(self) -> float:
        """Return duration of the action."""
        return (self.start and time.process_time()-self.start) or 0
        
    def summary(self) -> str:
        return f"{self.name!s} in {self.duration():0.3f} sec."
    




class ActionSequence(Action):
    """An action composed of a sequence of other actions."""
    def __init__(self, name: str, opSequence: list[Action] | None = None) -> None:
        super().__init__(name)
        if opSequence: self.opSequence = opSequence
        else: self.opSequence = []
        
    def __str__(self) -> str:
        return "; ".join([str(x) for x in self.opSequence])
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        for o in self.opSequence:
            o(self.options)
    

        
        
    def summary(self) -> str:
        return ", ".join([o.summary() for o in self.opSequence])
    




class WeaveAction(Action):
    """Weave the final document."""
    def __init__(self) -> None:
        super().__init__("Weave")
        
    def __str__(self) -> str:
        return f"{self.name!s} [{self.options.web!s}, {self.options.theWeaver!s}]"

        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        if not self.options.weaver: 
            # Examine first few chars of first chunk of web to determine language
            self.options.weaver = self.options.web.language() 
            self.logger.info("Using %s", self.options.theWeaver)
        self.options.theWeaver.output = self.options.output
        try:
            self.options.theWeaver.set_markup(self.options.weaver)
            self.options.theWeaver.emit(self.options.web)
            self.logger.info("Finished Normally")
        except Error as e:
            self.logger.error("Problems weaving document from %r (weave file is faulty).", self.options.web.web_path)
            #raise
    

    
        
    def summary(self) -> str:
        if self.options.theWeaver and self.options.theWeaver.linesWritten > 0:
            return (
                f"{self.name!s} {self.options.theWeaver.linesWritten:d} lines in {self.duration():0.3f} sec."
            )
        return f"did not {self.name!s}"
    




class TangleAction(Action):
    """Tangle source files."""
    def __init__(self) -> None:
        super().__init__("Tangle")
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        self.options.theTangler.include_line_numbers = self.options.tangler_line_numbers
        self.options.theTangler.output = self.options.output
        try:
            self.options.theTangler.emit(self.options.web)
        except Error as e:
            self.logger.error("Problems tangling outputs from %r (tangle files are faulty).", self.options.web.web_path)
            #raise
    

    
        
    def summary(self) -> str:
        if self.options.theTangler and self.options.theTangler.linesWritten > 0:
            return (
                f"{self.name!s} {self.options.theTangler.totalLines:d} lines in {self.duration():0.3f} sec."
            )
        return f"did not {self.name!r}"
    




class LoadAction(Action):
    """Load the source web."""
    def __init__(self) -> None:
        super().__init__("Load")
        
    def __str__(self) -> str:
        return f"Load [{self.webReader!s}, {self.options.web!s}]"
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        self.webReader = self.options.webReader
        self.webReader.command = self.options.command
        self.webReader.permitList = self.options.permitList
        self.logger.debug("Reader Class %s", self.webReader.__class__.__name__)
    
        error = f"Problems with source file {self.options.source_path!r}, no output produced."
        try:
            chunks = self.webReader.load(self.options.source_path)
            if self.webReader.errors != 0:
                raise Error("Syntax Errors in the Web")
            self.logger.debug("Read %d Chunks", len(chunks))
            self.options.web = Web(chunks)
            self.options.web.web_path = self.options.source_path
            self.logger.debug("Web contains %3d chunks", len(self.options.web.chunks))
            self.logger.debug("Web defines  %3d files", len(self.options.web.files))
            self.logger.debug("Web defines  %3d macros", len(self.options.web.macros))
            self.logger.debug("Web defines  %3d names", len(self.options.web.userids))
        except Error as e:
            self.logger.error(error)
            raise  # Could not be parsed or built.
        except IOError as e:
            self.logger.error(error)
            raise
    

    
        
    def summary(self) -> str:
        return (
            f"{self.name!s} {self.webReader.totalLines:d} lines from {self.webReader.totalFiles:d} files in {self.duration():0.3f} sec."
        )
    





class Application:
    def __init__(self, base_config: dict[str, Any] | None = None) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)
                
        self.defaults = argparse.Namespace(
            verbosity=logging.INFO,
            command='@',
            weaver='rst', 
            skip='',  # Don't skip any steps
            permit='',  # Don't tolerate missing includes
            reference='s',  # Simple references
            tangler_line_numbers=False,
            output=Path.cwd(),
            )
        
        # Primitive Actions
        self.loadOp = LoadAction()
        self.weaveOp = WeaveAction()
        self.tangleOp = TangleAction()
        
        # Composite Actions
        self.doWeave = ActionSequence("load and weave", [self.loadOp, self.weaveOp])
        self.doTangle = ActionSequence("load and tangle", [self.loadOp, self.tangleOp])
        self.theAction = ActionSequence("load, tangle and weave", [self.loadOp, self.tangleOp, self.weaveOp])

        
        
    def parseArgs(self, argv: list[str]) -> argparse.Namespace:
        p = argparse.ArgumentParser()
        p.add_argument("-v", "--verbose", dest="verbosity", action="store_const", const=logging.INFO)
        p.add_argument("-s", "--silent", dest="verbosity", action="store_const", const=logging.WARN)
        p.add_argument("-d", "--debug", dest="verbosity", action="store_const", const=logging.DEBUG)
        p.add_argument("-c", "--command", dest="command", action="store")
        p.add_argument("-w", "--weaver", dest="weaver", action="store")
        p.add_argument("-x", "--except", dest="skip", action="store", choices=('w', 't'))
        p.add_argument("-p", "--permit", dest="permit", action="store")
        p.add_argument("-n", "--linenumbers", dest="tangler_line_numbers", action="store_true")
        p.add_argument("-o", "--output", dest="output", action="store", type=Path)
        p.add_argument("-V", "--Version", action='version', version=f"py-web-lp pyweb.py {__version__}")
        p.add_argument("files", nargs='+', type=Path)
        config = p.parse_args(argv, namespace=self.defaults)
        self.expand(config)
        return config
        
    def expand(self, config: argparse.Namespace) -> argparse.Namespace:
        """Translate the argument values from simple text to useful objects.
        Weaver. Tangler. WebReader.
        """
        # Weaver & Tangler
        config.theWeaver = Weaver(config.output)
        config.theTangler = TanglerMake(config.output)
        
        if config.permit:
            # save permitted errors, usual case is ``-pi`` to permit ``@i`` include errors
            config.permitList = [f'{config.command!s}{c!s}' for c in config.permit]
        else:
            config.permitList = []
    
        config.webReader = WebReader()
    
        return config
    

    
        
    def process(self, config: argparse.Namespace) -> None:
        root = logging.getLogger()
        root.setLevel(config.verbosity)
        self.logger.debug("Setting root log level to %r", logging.getLevelName(root.getEffectiveLevel()))
        
        if config.command:
            self.logger.debug("Command character %r", config.command)
            
        if config.skip:
            if config.skip.lower().startswith('w'):  # not weaving == tangling
                self.theAction = self.doTangle
            elif config.skip.lower().startswith('t'):  # not tangling == weaving
                self.theAction = self.doWeave
            else:
                raise Exception(f"Unknown -x option {config.skip!r}")
    
        for f in config.files:
            self.logger.info("%s %s %r", self.theAction.name, __version__, f)
            config.source_path = f
            self.theAction(config)
            self.logger.info(self.theAction.summary())
    




class Logger:
    def __init__(self, dict_config: dict[str, Any] | None = None, **kw_config: Any) -> None:
        self.dict_config = dict_config
        self.kw_config = kw_config
        
    def __enter__(self) -> "Logger":
        if self.dict_config:
            logging.config.dictConfig(self.dict_config)
        else:
            logging.basicConfig(**self.kw_config)
        return self
        
    def __exit__(self, *args: Any) -> Literal[False]:
        logging.shutdown()
        return False

default_logging_config = {
    'version': 1,
    'disable_existing_loggers': False, # Allow pre-existing loggers to work.
    'style': '{',
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'stream': 'ext://sys.stderr',
            'formatter': 'basic',
        },
    },
    'formatters': {
        'basic': {
            'format': "{levelname}:{name}:{message}",
            'style': "{",
        }
    },
    
    'root': {'handlers': ['console'], 'level': logging.INFO,},
    
    # For specific debugging support...
    'loggers': {
        'Weaver': {'level': logging.INFO},
        'WebReader': {'level': logging.INFO},
        'Tangler': {'level': logging.INFO},
        'TanglerMake': {'level': logging.INFO},
        'indent.TanglerMake': {'level': logging.INFO},
        'Web': {'level': logging.INFO},
        # Unit test requires this...
        'ReferenceCommand': {'level': logging.INFO},
    },
}


def main(argv: list[str] = sys.argv[1:], base_config: dict[str, Any] | None=None) -> None:
    a = Application(base_config)
    config = a.parseArgs(argv)
    a.process(config)


if __name__ == "__main__":
    config_paths = Path("pyweb.toml"), Path.home()/"pyweb.toml"
    base_config: dict[str, Any] = {}
    for cp in config_paths:
        if cp.exists():
            with cp.open('rb') as config_file:
                base_config = toml.load(config_file)
            break
    log_config = base_config.get('logging', default_logging_config)
    with Logger(log_config):
        main(base_config=base_config.get('pyweb', {}))
