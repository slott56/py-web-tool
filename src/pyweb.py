#!/usr/bin/env python
"""py-web-lp Literate Programming.

Yet another simple literate programming tool derived from **nuweb**, 
implemented entirely in Python.
With a suitable configuration, this weaves documents with any markup language,
and tangles source files for any programming language.
"""
__version__ = """3.3"""

### DO NOT EDIT THIS FILE!
### It was created by src/pyweb.py, __version__='3.3'.
### From source web/impl.w modified Wed Oct 23 08:22:43 2024.
### In working directory '/Users/slott/Documents/Projects/py-web-tool'.

from collections import defaultdict
from collections.abc import Iterator
from dataclasses import dataclass, field
from functools import cache
import logging
from pathlib import Path
from types import SimpleNamespace
from typing import Any, Literal, ClassVar
from weakref import ref, ReferenceType
from typing import TypeVar, Generic
import abc
from collections import ChainMap
from textwrap import dedent, shorten
from jinja2 import Environment, DictLoader, select_autoescape
import jinja2.nodes
import filecmp
import tempfile
import os
import builtins
import sys
import platform

from typing import TextIO, cast
import re
from collections.abc import Iterator, Iterable

import argparse
import shlex

import logging
import logging.config

import os
import time
import datetime
import sys
import tomllib as toml
import types




class Error(Exception): pass




class TypeId:
    """
    This makes a given class name into an attribute with a 
    True value. Any other attribute reference will return False.
    
    >>> class A:
    ...     typeid = TypeId()
    >>> a = A()
    >>> a.typeid.A 
    True
    >>> a.typeid.B
    False
    """             
    def __set_name__(self, owner: type, name: str) -> "TypeId":
        """Invoked automatically during object construction."""
        self.my_class = owner
        return self

    def __getattr__(self, item: str) -> bool:
        return self.my_class.__name__ == item
        
from collections.abc import Mapping

class TypeIdMeta(type):
    """Inject the ``typeid`` attribute into a class definition."""
    @classmethod
    def __prepare__(metacls, name: str, bases: tuple[type, ...], **kwds: Any) -> Mapping[str, object]:  # type: ignore[override]
        return {"typeid": TypeId()}




class Command(metaclass=TypeIdMeta):
    typeid: TypeId
    has_name = False
    has_text = False
        
    def __init__(self, location: tuple[str, int]) -> None:
        self.location = location  #: The (filename, line number)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.web: ReferenceType["Web"]
        self.text: str  #: The body of this command
        
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(location={self.location!r})"
        
    @abc.abstractmethod
    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        ...



type HasText = "CodeCommand | TextCommand"



class TextCommand(Command):
    """Text outside any other command."""    
    has_text = True
    
    def __init__(self, text: str, location: tuple[str, int]) -> None:
        super().__init__(location)
        self.text = text  #: The text
            
    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        message = f"attempt to tangle a text block {self.location} {shorten(self.text, 32)!r}"
        self.logger.error(message)
        raise Error(message)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(text={self.text!r}, location={self.location!r})"


class CodeCommand(Command):
    """Code inside a ``@o``, or ``@d`` command."""    
    has_text = True

    def __init__(self, text: str, location: tuple[str, int]) -> None:
        super().__init__(location)
        self.text = text  #: The text

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        self.logger.debug(f"tangle {self.text=!r}")
        aTangler.codeBlock(target, self.text)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(text={self.text!r}, location={self.location!r})"


class ReferenceCommand(Command):
    """
    Reference to a ``NamedChunk`` in code, a ``@< name @>`` construct.
    In a CodeChunk or OutputChunk, it tangles to the definition from a ``NamedChunk``.
    In text, it can weave to the text of a ``NamedDocumentChunk``.
    """    
    has_name = True

    def __init__(self, name: str, location: tuple[str, int]) -> None:
        super().__init__(location)
        self.name = name  #: The name that is referenced.
    
    @property
    def full_name(self) -> str:
        return cast(Web, self.web()).resolve_name(self.name)

    @property
    def seq(self) -> int | None:
        return cast(Web, self.web()).resolve_chunk(self.name)[0].seq

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        """Expand this reference.
        The starting position is the indentation for all **subsequent** lines.
        Provide the indent before ``@<``, in ``tangler.fragment`` back to the tangler. 
        """
        self.logger.debug(f"tangle reference to {self.name=}, context: {aTangler.fragment=}")
        chunk_list = cast(Web, self.web()).resolve_chunk(self.name)
        if len(chunk_list) == 0:
            message = f"Attempt to tangle an undefined Chunk, {self.name!r}"
            self.logger.error(message)
            raise Error(message) 
        aTangler.reference_names.add(self.name)
        aTangler.addIndent(len(aTangler.fragment))
        aTangler.fragment = ""

        for chunk in chunk_list:
            # TODO: if chunk.indent is not None: do a setIndent before tangling.
            for command in chunk.commands:
                command.tangle(aTangler, target)
                
        aTangler.clrIndent()

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name={self.name!r}, location={self.location!r})"


class FileXrefCommand(Command):
    """The ``@f`` command."""    
    def __init__(self, location: tuple[str, int]) -> None:
        super().__init__(location)

    @property
    def files(self) -> list["OutputChunk"]:
        return cast(Web, self.web()).files

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        raise Error('Illegal tangling of a cross reference command.')

class MacroXrefCommand(Command):
    """The ``@m`` command."""    
    def __init__(self, location: tuple[str, int]) -> None:
        super().__init__(location)

    @property
    def macros(self) -> list[SimpleNamespace]:
        return cast(Web, self.web()).macros

    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        raise Error('Illegal tangling of a cross reference command.')

class UserIdXrefCommand(Command):
    """The ``@u`` command."""    
    def __init__(self, location: tuple[str, int]) -> None:
        super().__init__(location)

    @property
    def userids(self) -> list[SimpleNamespace]:
        return cast(Web, self.web()).userids
        
    def tangle(self, aTangler: "Tangler", target: TextIO) -> None:
        raise Error('Illegal tangling of a cross reference command.')




@dataclass
class Chunk:
    """Superclass for OutputChunk, NamedChunk, NamedDocumentChunk.
    """
    #: Parsed options for @d and @o chunks; used by __post_init__() to set other attributes.
    options: list[str] = field(default_factory=list)

    #: Short name of the chunk.
    name: str | None = None
    
    #: Unique sequence number of chunk in the WEB.
    seq: int | None = None  
    
    #: Sequence of commands inside this chunk.
    commands: list["Command"] = field(default_factory=list)

    #: Names defined after ``@|`` in this chunk.
    def_names: list[str] = field(default_factory=list)
      
    #: Is this the first use of a given Chunk name?
    initial: bool = False  
    
    #: If injecting location details when tangling, this is the comment prefix.
    comment_start: str | None = None
    
    #: If injecting location details, this is the comment suffix. 
    comment_end: str | None = None

    #: When weaving, set weave=False to skip this.
    weave: bool = True

    #: When weaving, this is a style to use.
    style: str | None = None

    #: Count of references to this Chunk.
    references: int = field(init=False, default=0)
    
    #: The immediate reference to this chunk.
    referencedBy: "Chunk | None" = field(init=False, default=None)
    
    #: Weak reference to the ``Web`` containing this ``Chunk``.
    web: ReferenceType["Web"] | None = field(init=False, repr=False, default=None)
    
    #: Logger for any chunk-specific messages.
    logger: logging.Logger = field(init=False, default=logging.getLogger("Chunk"))

    #: Indentation Rule; None means indent; number is the amount to indent.
    indent: None | int = None

    def __post_init__(self) -> None:
        """Parse options."""
        if self.options:
            self.logger.warning("attempt to create %s with options %r", self.__class__.__name__, self.options)

    @property
    def full_name(self) -> str | None:
        if self.web is None:
            raise ValueError("no web assigned to chunk {self!s}")
        if self.name:
            return cast(Web, self.web()).resolve_name(self.name)
        else:
            return None

    @property
    def path(self) -> Path | None:
        return None

    @property
    def location(self) -> tuple[str, int]:
        return self.commands[0].location

    @property
    def transitive_referencedBy(self) -> list["Chunk"]:
        if self.referencedBy:
            return [self.referencedBy] + self.referencedBy.transitive_referencedBy
        else:
            return []
        
    def add_text(self, text: str, location: tuple[str, int]) -> "Chunk":
        if self.commands and self.commands[-1].typeid.TextCommand:
            cast(HasText, self.commands[-1]).text += text
        else:
            # Empty list OR previous command was not ``TextCommand``
            self.commands.append(TextCommand(text, location))
        return self
             
    def type_is(self, name: str) -> bool:
        """
        Instead of type name matching, we could check for these features:
        - has_code() (i.e., NamedChunk and OutputChunk)
        - has_text() (i.e., Chunk and NamedDocumentChunk)
        Since this is for template rendering, where proper Liskov
        Substitution is irrelevant, we match class names.

        This can't **easily** use the ``typeid`` metaclass because it's a dataclass.
        """
        return self.__class__.__name__ == name

class OutputChunk(Chunk):
    """An output file from an ``@o`` Chunk"""
    option_parser: argparse.ArgumentParser | None = None

    def __post_init__(self) -> None:
        """Parse options."""
        if not self.option_parser:
            self.option_parser = argparse.ArgumentParser(add_help=False, exit_on_error=False)
            self.option_parser.add_argument("-start", dest='start', type=str, default=None)
            self.option_parser.add_argument("-end", dest='end', type=str, default="")
            self.option_parser.add_argument("-noweave", dest="weave", action='store_false', default=True)
            # All remaining arguments form the chunk name
            self.option_parser.add_argument("argument", type=str, nargs="*")
        options = self.option_parser.parse_args(self.options)
        self.name = ' '.join(options.argument)
        self.comment_start = options.start if '-start' in options else "# "
        self.comment_end = options.end if '-end' in options else ""
        self.weave = options.weave

    @property
    def path(self) -> Path | None:
        if self.name:
            return Path(self.name)
        else:
            return None

    @property
    def full_name(self) -> str | None:
        return None

    def add_text(self, text: str, location: tuple[str, int]) -> Chunk:
        if self.commands and self.commands[-1].typeid.CodeCommand:
            cast(HasText, self.commands[-1]).text += text
        else:
            # Empty list OR previous command was not ``CodeCommand``
            self.commands.append(CodeCommand(text, location))
        return self
             
class NamedChunk(Chunk): 
    """
    A defined name with code from a ``@d`` Chunk

    ..  note:: syntex for ``-indent``/``-noindent``.

        - ``-indent`` provides None, normal indent

        - ``-noindent`` is effectively ``-indent 0``.
    """

    option_parser: argparse.ArgumentParser | None = None

    def __post_init__(self) -> None:
        if not self.option_parser:
            self.option_parser = argparse.ArgumentParser(add_help=False, exit_on_error=False)
            self.option_parser.add_argument("-style", dest="style", action="store", default=None)
            self.option_parser.add_argument("-indent", dest='indent', action='store_const',
             const=None, default=None)
            self.option_parser.add_argument("-noindent", dest='indent', action='store_const', const=0, default=None)
            self.option_parser.add_argument("argument", type=str, nargs="*")
        options = self.option_parser.parse_args(self.options)
        self.name = ' '.join(options.argument)
        if 'noindent' in options and options.noindent:
            self.indent = 0
        elif 'indent' in options and options.indent:
            self.indent = int(options.indent)
        self.style = options.style

    def add_text(self, text: str, location: tuple[str, int]) -> Chunk:
        if self.commands and self.commands[-1].typeid.CodeCommand:
            cast(HasText, self.commands[-1]).text += text
        else:
            # Empty list OR previous command was not ``CodeCommand``
            self.commands.append(CodeCommand(text, location))
        return self
             
class NamedDocumentChunk(Chunk):
    """
    A defined name with text.

    ..  todo:: Refactor parse_options to base class
    """
    option_parser: argparse.ArgumentParser | None = None

    def __post_init__(self) -> None:
        if not self.option_parser:
            self.option_parser = argparse.ArgumentParser(add_help=False, exit_on_error=False)
            self.option_parser.add_argument("-style", action="store", type=str, default=None)
            # All remaining arguments form the chunk name
            self.option_parser.add_argument("argument", type=str, nargs="*")
        options = self.option_parser.parse_args(self.options)
        self.name = ' '.join(options.argument)





@dataclass
class Web:
    chunks: list["Chunk"]  #: The source sequence of chunks.

    # The ``@d`` chunk names and locations where they're defined.
    chunk_map: dict[str, list["Chunk"]] = field(init=False)
    
    # The ``@|`` defined names and chunks with which they're associated.
    userid_map: defaultdict[str, list["Chunk"]] = field(init=False)
        
    logger: logging.Logger = field(init=False, default=logging.getLogger("Web"))
    
    web_path: Path = field(init=False)  #: Source WEB file; set by ```WebParse``

    strict_match: ClassVar[bool] = True  #: Report ... names without a definition.


    def __post_init__(self) -> None:
        """
        Populate weak references throughout the web to make full_name properties work.
        Then. Locate all macro definitions and userid references. 
        """
        # Pass 1 -- set all Chunk and Command back references.
        for c in self.chunks:
            c.web = ref(self)
            for cmd in c.commands:
                cmd.web = ref(self)
                
        # Named Chunks = Union of macro_iter and file_iter
        named_chunks = list(filter(lambda c: c.name is not None, self.chunks))

        # Pass 2 -- locate the unabbreviated names in chunks and references to chunks.
        self.chunk_map = {}
        for seq, c in enumerate(named_chunks, start=1):
            c.seq = seq
            if not c.path:
                # Use ``@d name`` chunks (reject ``@o`` and text)
                if c.name and not c.name.endswith('...'):
                    self.logger.debug(f"__post_init__ 2a {c.name=!r}")
                    self.chunk_map.setdefault(c.name, [])
            for cmd in c.commands:
                # Find ``@< name @>`` in ``@d name`` chunks or ``@o`` chunks 
                if cmd.has_name:
                    if not cast(ReferenceCommand, cmd).name.endswith('...'):
                        self.logger.debug(f"__post_init__ 2b {cast(ReferenceCommand, cmd).name=!r}")
                        self.chunk_map.setdefault(cast(ReferenceCommand, cmd).name, [])
                    
        # Pass 3 -- accumulate chunk lists, output lists, and name definition lists.
        self.userid_map = defaultdict(list)
        for c in named_chunks:
            for name in c.def_names:
                self.userid_map[name].append(c)
            if not c.path:
                # Named ``@d name`` chunks
                if full_name := c.full_name:
                    c.initial = len(self.chunk_map[full_name]) == 0
                    self.chunk_map[full_name].append(c)
                    self.logger.debug(f"__post_init__ 3 {c.name=!r} -> {c.full_name=!r}")
            else:
                # Output ``@o`` and anonymous chunks.
                # Assume all @o chunks are unique. If they're not, they overwrite each other.
                # Also, there's not ``full_name`` for these chunks.
                c.initial = True
                
            # TODO: Accumulate all chunks that contribute to a named file...

        # Pass 4 -- set referencedBy a command in a chunk.
        # ONLY set this in references embedded in named chunk or output chunk.
        # In a generic Chunk (which is text) there's no anchor to refer to.
        # NOTE: Assume single references *only*
        # We should raise an exception when updating a non-None referencedBy value.
        # Or incrementing ref_chunk.references > 1.
        for c in named_chunks:
            for cmd in c.commands:
                if cmd.has_name:
                    ref_to_list = self.resolve_chunk(cast(ReferenceCommand, cmd).name)
                    for ref_chunk in ref_to_list:
                        ref_chunk.referencedBy = c
                        ref_chunk.references += 1
            
    def __repr__(self) -> str:
        NL = ",\n"
        return (
            f"{self.__class__.__name__}("
            f"{NL.join(repr(c) for c in self.chunks)}"
            f")"
        )

    def resolve_name(self, target: str) -> str:
        """Map short names to full names, if possible."""
        if target in self.chunk_map:
            # self.logger.debug(f"resolve_name {target=} in self.chunk_map")
            return target
        elif target.endswith('...'):
            # The ... is equivalent to regular expression .*
            matches = list(
                c_name
                for c_name in self.chunk_map
                if c_name.startswith(target[:-3])
            )
            # self.logger.debug(f"resolve_name {target=} {matches=} in self.chunk_map")
            match matches:
                case []:
                    if self.strict_match:
                        raise Error(f"No full name for {target!r}")
                    else:
                        self.logger.warning(f"resolve_name {target=} unknown")
                        self.chunk_map[target] = []
                    return target
                case [head]:
                    return head
                case [head, *tail]:
                    message = f"Ambiguous abbreviation {target!r}, matches {[head] + tail!r}"
                    raise Error(message)
            raise RuntimeError(f"unexpected {matches}")
        else:
            self.logger.warning(f"resolve_name {target=} unknown")
            self.chunk_map[target] = []
            return target

    def resolve_chunk(self, target: str) -> list["Chunk"]:
        """Map name (short or full) to the defining sequence of chunks."""
        full_name = self.resolve_name(target)
        chunk_list = self.chunk_map[full_name]
        self.logger.debug(f"resolve_chunk {target=!r} -> {full_name=!r} -> {chunk_list=}")
        return chunk_list

    def file_iter(self) -> Iterator[OutputChunk]:
        return (cast(OutputChunk, c) for c in self.chunks if c.type_is("OutputChunk"))

    def macro_iter(self) -> Iterator[NamedChunk]:
        return (cast(NamedChunk, c) for c in self.chunks if c.type_is("NamedChunk"))

    def userid_iter(self) -> Iterator[SimpleNamespace]:
        yield from (SimpleNamespace(def_name=n, chunk=c) for c in self.file_iter() for n in c.def_names)
        yield from (SimpleNamespace(def_name=n, chunk=c) for c in self.macro_iter() for n in c.def_names)

    @property
    def files(self) -> list["OutputChunk"]:
        return list(self.file_iter())

    @property
    def macros(self) -> list[SimpleNamespace]:
        """
        The chunk_map has the list of Chunks that comprise a macro definition.
        We separate those to make it slightly easier to format the first definition.
        """
        first_list = (
            (self.chunk_map[name][0], self.chunk_map[name])
            for name in sorted(self.chunk_map)
            if self.chunk_map[name]
        )
        macro_list = list(
            SimpleNamespace(name=first_def.name, full_name=first_def.full_name, seq=first_def.seq, def_list=def_list)
            for first_def, def_list in first_list
        )
        # self.logger.debug(f"macros: {defs}")
        return macro_list

    @property
    def userids(self) -> list[SimpleNamespace]:
        userid_list = list(
            SimpleNamespace(userid=userid, ref_list=self.userid_map[userid])
            for userid in sorted(self.userid_map)
        )
        # self.logger.debug(f"userids: {userid_list}")
        return userid_list
            
    def no_reference(self) -> list[Chunk]:
        return list(filter(lambda c: c.name and not c.path and c.references == 0, self.chunks))
        
    def multi_reference(self) -> list[Chunk]:
        return list(filter(lambda c: c.name and not c.path and c.references > 1, self.chunks))




class Emitter(abc.ABC):
    def __init__(self, output: Path): 
        self.logger = logging.getLogger(self.__class__.__qualname__)
        self.log_indent = logging.getLogger("indent." + self.__class__.__qualname__)
        self.output = output
    
    @abc.abstractmethod
    def emit(self, web: Web) -> None:
        pass



# Template Definitions


class QuoteRules:
    def __init__(self, *mapping: tuple[str, str]) -> None:
        self.mapping = mapping
    def __call__(self, text: str) -> str:
        clean = text
        for from_, to_ in self.mapping:
            clean = clean.replace(from_, to_)
        return clean



debug_quote_rules = repr
    
debug_macros = [
    dedent("""\
        {%- macro text(command) -%}
        text: {{command}}
        {%- endmacro -%}
    """),
    dedent("""\
        {%- macro begin_code(chunk) %}
        begin_code: {{chunk}}
        {%- endmacro -%}
    """),
    dedent("""\
        {%- macro code(command) %}
        code: {{command}}
        {%- endmacro -%}
    """),
    dedent("""\
        {%- macro ref(id) %}
        ref: {{id}}
        {%- endmacro -%}
    """),
    dedent("""\
        {%- macro end_code(chunk) %}
        end_code: {{chunk}}
        {% endmacro -%}
    """),
    dedent("""\
        {%- macro file_xref(command) -%}
        file_xref {{command.files}}
        {%- endmacro -%}
    """),
    dedent("""\
        {%- macro macro_xref(command) -%}
        macro_xref {{command.macros}}
        {%- endmacro -%}
    """),
    dedent("""\
        {%- macro userid_xref(command) -%}
        userid_xref {{command.userids}}
        {%- endmacro -%}
    """)
    ]



rst_quote_rules = str

 # Old rules, used with ``..  parsed-literal::``
 #rst_quote_rules = QuoteRules(
 #       ('\\', r'\\'), # Must be first.
 #       ('`', r'\`'),
 #       ('_', r'\_'),
 #       ('*', r'\*'),
 #       ('|', r'\|'),
 #   )

rst_macros = [
    dedent("""
        {%- macro text(command) -%}
        {{command.text}}
        {%- endmacro -%}
    """),
    dedent("""\
        {%- macro begin_code(chunk) %}
        ..  _`{{chunk.full_name or chunk.name}} ({{chunk.seq}})`:
        ..  rubric:: {{chunk.full_name or chunk.name}} ({{chunk.seq}}) {% if chunk.initial %}={% else %}+={% endif %}
        ..  code-block::
            :class: code

        {% endmacro -%}
    """),
    dedent("""\
        {# For RST, each line must be indented. #}
        {%- macro code(command) %}{% for line in command.text.splitlines() %}    {{line | quote_rules}}
        {% endfor -%}{% endmacro -%}
    """),
    dedent("""\
        {%- macro ref(id) %}    \N{RIGHTWARDS ARROW} `{{id.full_name or id.name}} ({{id.seq}})`_{% endmacro -%}
    """),
   dedent("""\
        {%- macro end_code(chunk) %}
        ..

        ..  container:: small

            \N{END OF PROOF} *{{chunk.full_name or chunk.name}} ({{chunk.seq}})*.
            {% if chunk.referencedBy %}Used by {{ref(chunk.referencedBy)}}.{% endif %}

        {% endmacro -%}
    """),
    dedent("""\
        {%- macro file_xref(command) -%}
        {% for file in command.files -%}
        :{{file.name}}:
            \N{RIGHTWARDS ARROW} `{{file.name}} ({{file.seq}})`_
        {%- endfor %}
        {%- endmacro -%}
    """),
    dedent("""\
        {%- macro macro_xref(command) -%}
        {% for macro in command.macros -%}
        :{{macro.full_name}}:
            {% for d in macro.def_list -%}\N{RIGHTWARDS ARROW} `{{d.full_name or d.name}} ({{d.seq}})`_{% if loop.last %}{% else %}, {% endif %}{%- endfor %}

        {% endfor %}
        {%- endmacro -%}
    """),
    dedent("""\
        {%- macro userid_xref(command) -%}
        {% for userid in command.userids -%}
        :{{userid.userid}}:
            {% for r in userid.ref_list -%}\N{RIGHTWARDS ARROW} `{{r.full_name or r.name}} ({{r.seq}})`_{% if loop.last %}{% else %}, {% endif %}{%- endfor %}

        {% endfor %}
        {%- endmacro -%}
    """)
    ]

rst_docutils_macros = [
    dedent("""\
        {%- macro end_code(chunk) %}
        ..

        ..  class:: small

            \N{END OF PROOF} *{{chunk.full_name or chunk.name}} ({{chunk.seq}})*

        {% endmacro -%}
    """)
    ]



html_quote_rules = QuoteRules(
        ("&", "&amp;"),  # Must be first
        ("<", "&lt;"),
        (">", "&gt;"),
        ('"', "&quot;"),  # Only applies inside tags...
    )

html_macros = [
    dedent("""\
    {%- macro text(command) -%}
    {{command.text}}
    {%- endmacro -%}
    """),
    dedent("""\
    {%- macro begin_code(chunk) %}
    <a name="pyweb_{{chunk.seq}}"></a>
    <!--line number {{chunk.location}}-->
    <p><em>{{chunk.full_name or chunk.name}} ({{chunk.seq}})</em> {% if chunk.initial %}={% else %}+={% endif %}</p>
    <pre><code>
    {%- endmacro -%}
    """),
    dedent("""\
    {%- macro code(command) -%}{{command.text | quote_rules}}{%- endmacro -%}
    """),
    dedent("""\
    {%- macro ref(id) %}&rarr;<a href="#pyweb_{{id.seq}}"><em>{{id.full_name or id.name}} ({{id.seq}})</em></a>{% endmacro -%}
    """),
    dedent("""\
    {%- macro end_code(chunk) %}
    </code></pre>
    <p>&#8718; <em>{{chunk.full_name or chunk.name}} ({{chunk.seq}})</em>.
    {% if chunk.referencedBy %}Used by {{ref(chunk.referencedBy)}}.{% endif %}
    </p> 
    {% endmacro -%}
    """),
    dedent("""\
    {%- macro file_xref(command) %}
    <dl>
    {% for file in command.files -%}
      <dt>{{file.name}}</dt><dd>{{ref(file)}}</dd>
    {%- endfor %}
    </dl>
    {% endmacro -%}
    """),
    dedent("""\
    {%- macro macro_xref(command) %}
    <dl>
    {% for macro in command.macros -%}
      <dt>{{macro.full_name}}<dt>
      <dd>{% for d in macro.def_list -%}{{ref(d)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}</dd>
    {% endfor %}
    </dl>
    {% endmacro -%}
    """),
    dedent("""\
    {%- macro userid_xref(command) %}
    <dl>
    {% for userid in command.userids -%}
      <dt>{{userid.userid}}</dt>
      <dd>{% for r in userid.ref_list -%}{{ref(r)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}</dd>
    {% endfor %}
    </dl>
    {% endmacro -%}
    """)
    ]



latex_quote_rules = QuoteRules(
        ("\\end{Verbatim}", "\\end\\,{Verbatim}"),  # Allow \end{Verbatim} in a Verbatim context
        ("\\{", "\\\\,{"), # Prevent unexpected commands in Verbatim
        ("$", "\\$"), # Prevent unexpected math in Verbatim
    )

latex_minted_quote_rules = QuoteRules(
        ("\\end{minted}", "\\end\\,{minted}"),  # Allow \end{minted} in a minted context
    )

tex_macros = [
    dedent("""\
    {%- macro text(command) -%}
    {{command.text}}
    {%- endmacro -%}
    """),
    dedent("""\
    {%- macro begin_code(chunk) %}
    \\label{pyweb-{{chunk.seq}}}
    \\begin{flushleft}
    \\textit{Code example {{chunk.full_name or chunk.name}} ({{chunk.seq}})}
    \\begin{Verbatim}[commandchars=\\\\\\{\\},codes={\\catcode`$$=3\\catcode`^=7},frame=single]
    {%- endmacro -%}
    """),
    dedent("""\
    {%- macro code(command) -%}{{command.text | quote_rules}}{%- endmacro -%}
    """),
    dedent("""\
    {%- macro ref(id) %}$$\\rightarrow$$ Code Example {{id.full_name or id.name}} ({{id.seq}}){% endmacro -%}
    """),
    dedent("""\
    {%- macro end_code(chunk) %}
    \\end{Verbatim}
    \\end{flushleft}
    {% endmacro -%}
    """),
    dedent("""\
    {%- macro file_xref(command) %}
    \\begin{itemize}
    {% for file in command.files -%}
      \\item {{file.name}}: {{ref(file)}}
    {%- endfor %}
    \\end{itemize}
    {% endmacro -%}
    """),
    dedent("""\
    {%- macro macro_xref(command) %}
    \\begin{itemize}
    {% for macro in command.macros -%}
      \\item {{macro.full_name}} \\\\
            {% for d in macro.def_list -%}{{ref(d)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
    {% endfor %}
    \\end{itemize}
    {% endmacro -%}
    """),
    dedent("""\
    {%- macro userid_xref(command) %}
    \\begin{itemize}
    {% for userid in command.userids -%}
      \\item {{userid.userid}} \\\\
            {% for r in userid.ref_list -%}{{ref(r)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
    {% endfor %}
    \\end{itemize}
    {% endmacro -%}
    """)
    ]

tex_minted_macros = [
    dedent("""\
    {%- macro begin_code(chunk) %}
    \\label{pyweb-{{chunk.seq}}}
    \\textit{Code example {{chunk.full_name or chunk.name}} ({{chunk.seq}})}
    \\begin{minted}{{'{'}}{{chunk.style}}{{'}'}}
    {%- endmacro -%}
    """),
    dedent("""\
    {%- macro end_code(chunk) %}
    \\end{minted}
    {% endmacro -%}
    """),
    ]



base_weaver_template = dedent("""\
    {%- from macros import text, begin_code, code, ref, end_code, file_xref, macro_xref, userid_xref -%}
    {% for chunk in web.chunks -%}
        {%- if chunk.type_is('OutputChunk') or chunk.type_is('NamedChunk') -%}
            {% if chunk.weave -%}
                {{begin_code(chunk)}}
                {%- for command in chunk.commands -%}
                    {%- if command.typeid.CodeCommand -%}{{code(command)}}
                    {%- elif command.typeid.ReferenceCommand -%}{{ref(command)}}
                    {%- endif -%}
                {%- endfor -%}
                {{end_code(chunk)}}
            {%- endif -%}
        {%- elif chunk.type_is('Chunk') -%}
            {%- for command in chunk.commands -%}
                {%- if command.typeid.TextCommand %}{{text(command)}}
                {%- elif command.typeid.ReferenceCommand %}{{ref(command)}}
                {%- elif command.typeid.FileXrefCommand %}{{file_xref(command)}}
                {%- elif command.typeid.MacroXrefCommand %}{{macro_xref(command)}}
                {%- elif command.typeid.UserIdXrefCommand %}{{userid_xref(command)}}
                {%- endif -%}
            {%- endfor -%}
        {%- endif -%}
    {%- endfor %}
""")


class Weaver(Emitter):

    def __init__(self, output: Path = Path.cwd()) -> None:
        super().__init__(output)
        #: map markup name to macros in priority order: override, base
        self.template_name_map = {
            "debug": (debug_macros,),
            "rst": (rst_macros,),
            "html": (html_macros,),
            "tex": (tex_macros,),
            "latex": (tex_macros,),

            "rst-sphinx": (rst_macros,),
            "rst-nosphinx": (rst_docutils_macros, rst_macros,),
            "rst-docutils": (rst_docutils_macros, rst_macros,),

            "tex-verbatim": (tex_macros,),
            "tex-minted": (tex_minted_macros, tex_macros),
            "latex-verbatim": (tex_macros,),
            "latex-minted": (tex_minted_macros, tex_macros),
        }

        #: map markup name to quote rules.
        self.quote_rules = {
        "debug": debug_quote_rules,
        "rst": rst_quote_rules,
        "rst-sphinx": rst_quote_rules,
        "rst-nosphinx": rst_quote_rules,
        "rst-docutils": rst_quote_rules,
        "html": html_quote_rules,
        "tex": latex_quote_rules,
        "tex-verbatim": latex_quote_rules,
        "tex-minted": latex_minted_quote_rules,
        "latex": latex_quote_rules,
        "latex-verbatim": latex_quote_rules,
        "latex-minted": latex_minted_quote_rules,
        }

        #: macros found in the config file.
        self.config_macros = []

        #: final mapping from macro name to definition.
        self.template_map = {}

        #: Working JINJA environment.
        self.env = Environment(
            autoescape=select_autoescape()
        )

        #: Summary
        self.linesWritten = 0
        
    def set_markup(self, markup: str = "rst") -> "Weaver":
        self.markup = markup
        return self

    def emit(self, web: Web) -> None:
        """Open output files. Then generate text."""
        self.target_path = (self.output / web.web_path.name).with_suffix(f".{self.markup}")
        self.logger.info("Weaving %s using %s markup", self.target_path, self.markup)
        with self.target_path.open('w') as target_file:
            for text in self.generate_text(web):
                self.linesWritten += text.count("\n")
                target_file.write(text)

    def macro_name_iter(self, source: list[str]) -> Iterator[tuple[str, str]]:
        for m in source:
            ast = self.env.parse(m)
            for child in ast.iter_child_nodes():
                match child:
                    case jinja2.nodes.Macro() as macro:
                        yield macro.name, m
                    case _:
                        raise RuntimeError(f"improper macro text {type(child)!s}: {child!r}")

    def configure_macros(self, web: Web) -> None:
        if self.template_map: return
        self.env.filters |= {
            "quote_rules": self.quote_rules[self.markup]
        }
        ordered_definitions = (
            # list(web_template_iter())
            [self.config_macros] +
            list(self.template_name_map[self.markup])
        )
        ordered_macro_name_maps = [
            dict(self.macro_name_iter(priority))
            for priority in ordered_definitions
        ]
        all_macros = ChainMap(*ordered_macro_name_maps)
        macro_template = "\n\n".join(
            all_macros[k] for k in all_macros.keys()
        )
        self.template_map = {
            'base_weaver_template': base_weaver_template,
            'macros': macro_template
        }
        self.env.loader=DictLoader(self.template_map)

    def generate_text(self, web: Web) -> Iterator[str]:
        self.configure_macros(web)
        macros = self.env.get_template(f"macros")
        base_weaver_template = self.env.get_template("base_weaver_template")
        return base_weaver_template.generate(web=web, macros=macros)



class Tangler(Emitter):
    code_indent = 0  #: Initial indent

    def __init__(self, output: Path = Path.cwd()) -> None:
        super().__init__(output)
        self.include_line_numbers = False
        self.context: list[int] = []  #: Indentations
        self.fragment = ""  # Nothing written yet.
        # Create context and initial lastIndent values
        self.resetIndent(self.code_indent)
        # Summaries
        self.reference_names: set[str] = set()
        self.linesWritten = 0
        self.totalFiles = 0
        self.totalLines = 0
        self.logger.debug("output base: %r, line numbers %s", self.output, self.include_line_numbers)

    def emit(self, web: Web) -> None:
        for file_chunk in web.files:
            self.logger.info("Tangling %s", file_chunk.name)
            self.emit_file(web, file_chunk)
            
    def emit_file(self, web: Web, file_chunk: Chunk) -> None:
        target_path = self.output / (file_chunk.name or "Untitled.out")
        self.logger.debug("Writing %s", target_path)
        self.logger.debug("Chunk %r", file_chunk)
        with target_path.open("w") as target:
            # An initial command to provide indentations.
            for command in file_chunk.commands:
                command.tangle(self, target)
                
        
    def codeBlock(self, target: TextIO, text: str) -> None:
        """Indented write of text in a ``CodeCommand``. 
        Counts lines and saves position to indent to when expanding ``@<...@>`` references.
        
        The ``fragment`` is the prevailing indent used in reference expansion.
        """
        for line in text.splitlines(keepends=True):
            self.logger.debug("codeBlock(%r)", line)
            indent = self.context[-1]
            if len(line) == 0:
                # Degenerate case of empty CodeText command. Should not occur.
                pass
            elif not line.endswith('\n'):
                # Possible start of indentation prior to a ``@<name@>``
                target.write(indent*' ')
                wrote = target.write(line)
                self.fragment = ' ' * wrote
                # May be used by a ``ReferenceCommand``, if needed.
            elif line.endswith('\n'):
                target.write(indent*' ')
                target.write(line)
                self.linesWritten += 1
            else:
                raise RuntimeError("Non-exhaustive if statement.")
    
    


        
    def addIndent(self, increment: int) -> None:
        self.lastIndent = self.context[-1]+increment
        self.context.append(self.lastIndent)
        self.log_indent.debug("addIndent %d: %r", increment, self.context)
        self.fragment = ""
        
    def setIndent(self, indent: int) -> None:
        self.context.append(indent)
        self.lastIndent = self.context[-1]
        self.log_indent.debug("setIndent %d: %r", indent, self.context)
        self.fragment = ""
    
    def clrIndent(self) -> None:
        if len(self.context) > 1:
            self.context.pop()
        self.lastIndent = self.context[-1]
        self.log_indent.debug("clrIndent %r", self.context)
        self.fragment = ""
    
    def resetIndent(self, indent: int = 0) -> None:
        """Resets the indentation context."""
        self.lastIndent = indent
        self.context = [self.lastIndent]
        self.log_indent.debug("resetIndent %d: %r", indent, self.context)
    

 


class TanglerMake(Tangler):
    def emit_file(self, web: Web, file_chunk: Chunk) -> None:
        target_path = self.output / (file_chunk.name or "Untitled.out")
        self.logger.debug("Writing %s via a temp file", target_path)
        self.logger.debug("Chunk %r", file_chunk)

        fd, tempname = tempfile.mkstemp(dir=os.curdir)
        with os.fdopen(fd, "w") as target:
            for command in file_chunk.commands:
                command.tangle(self, target)
                
        try:
            same = filecmp.cmp(tempname, target_path)
        except OSError as e:
            same = False  # Doesn't exist. (Could check for errno.ENOENT)
            
        if same:
            self.logger.info("Unchanged '%s'", target_path)
            os.remove(tempname)
        else:
            # Windows requires the original file name be removed first.
            try: 
                target_path.unlink()
            except OSError as e:
                pass  # Doesn't exist. (Could check for errno.ENOENT)
            target_path.parent.mkdir(parents=True, exist_ok=True)
            target_path.hardlink_to(tempname)
            os.remove(tempname)
            self.logger.info("Wrote %d lines to %s", self.linesWritten, target_path)



class Tokenizer(Iterator[str]):
    def __init__(self, stream: TextIO, command_char: str='@') -> None:
        self.command = command_char
        self.parsePat = re.compile(f'({self.command}.|\\n)')
        self.token_iter = (t for t in self.parsePat.split(stream.read()) if len(t) != 0)
        self.lineNumber = 0
        
    def __next__(self) -> str:
        token = next(self.token_iter)
        self.lineNumber += token.count('\n')
        return token
        
    def __iter__(self) -> Iterator[str]:
        return self




class WebReader:
    """Parse an input file, creating Chunks and Commands."""

    # Configuration
    #: The command prefix, default ``@``.
    command: str 
    #: Permitted errors, usually @i commands
    permitList: list[str]
    #: Working directory to resolve @i commands  
    base_path: Path  
    #: The tokenizer used to find commands
    tokenizer: Tokenizer  
    
    # State of the reader
    #: Parent context for @i commands      
    parent: "WebReader | None"
    #: Input Path 
    filePath: Path 
    #: Input file-like object, default is self.filePath.open()
    _source: TextIO  
    #: The sequence of Chunk instances being built
    content: list[Chunk] 
    
    def __init__(self, parent: "WebReader | None" = None) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)

        # Configuration comes from the parent or defaults if there is no parent.
        self.parent = parent
        if self.parent: 
            self.command = self.parent.command
            self.permitList = self.parent.permitList
        else: # Defaults until overridden
            self.command = '@'
            self.permitList = []
                    
        # Summary
        self.totalLines = 0
        self.totalFiles = 0
        self.errors = 0 
        
                
        # Structural ("major") commands
        self.cmdo = self.command+'o'
        self.cmdd = self.command+'d'
        self.cmdlcurl = self.command+'{'
        self.cmdrcurl = self.command+'}'
        self.cmdlbrak = self.command+'['
        self.cmdrbrak = self.command+']'
        self.cmdi = self.command+'i'
        
        # Inline ("minor") commands
        self.cmdlangl = self.command+'<'
        self.cmdrangl = self.command+'>'
        self.cmdpipe = self.command+'|'
        self.cmdlexpr = self.command+'('
        self.cmdrexpr = self.command+')'
        self.cmdcmd = self.command+self.command
        
        # Content "minor" commands
        self.cmdf = self.command+'f'
        self.cmdm = self.command+'m'
        self.cmdu = self.command+'u'

        
    def __str__(self) -> str:
        return self.__class__.__name__
        
        
    def location(self) -> tuple[str, int]:
        return (str(self.filePath), self.tokenizer.lineNumber+1)
    

    
        
    def load(self, filepath: Path, source: TextIO | None = None) -> list[Chunk]:
        """Returns a flat list of chunks to be made into a Web. 
        Also used to expand ``@i`` included files.
        """
        self.filePath = filepath
        self.base_path = self.filePath.parent
    
        if source:
            self._source = source
            self.parse_source()
        else:
            with self.filePath.open() as self._source:
                self.parse_source()
        return self.content
    
    def parse_source(self) -> None:
        """Builds a sequence of Chunks."""
        self.tokenizer = Tokenizer(self._source, self.command)
        self.totalFiles += 1
    
        # Initial anonymous chunk.
        self.content = [Chunk()]
    
        for token in self.tokenizer:
            if len(token) >= 2 and token.startswith(self.command):
                if self.handleCommand(token):
                    continue
                else:
                    self.logger.error('Unknown @-command in input: %r near %r', token, self.location())
                    self.content[-1].add_text(token, self.location())
                    
            elif token:
                # Accumulate a non-empty block of text in the current chunk.
                self.content[-1].add_text(token, self.location())
    
            else:
                # Whitespace
                pass
        self.logger.debug("parse_source: [")
        for c in self.content:
            self.logger.debug("  %r", c)
        self.logger.debug("]")
    

    
        
    def handleCommand(self, token: str) -> bool:
        self.logger.debug("Reading %r", token)
        new_chunk: Chunk | None = None
        match token[:2]:
            case self.cmdo:
                                
                arg_str = next(self.tokenizer)
                self.expect({self.cmdlcurl})
                new_chunk = OutputChunk(options=shlex.split(arg_str))
                self.content.append(new_chunk)
                # capture an OutputChunk up to @}
    
            case self.cmdd:
                                
                arg_str = next(self.tokenizer)
                brack = self.expect({self.cmdlcurl, self.cmdlbrak})
                
                # REFACTOR parse_options into various CHUNK types.
                # REFACTOR remove NamedChunk_Noindent as a distinct subclass.
                if brack == self.cmdlbrak:
                    # options = NamedDocumentChunk.parse_options(shlex.split(arg_str))
                    # name = ' '.join(options.argument)
                    new_chunk = NamedDocumentChunk(options=shlex.split(arg_str))
                elif brack == self.cmdlcurl:
                    # options = NamedChunk.parse_options(shlex.split(arg_str))
                    # indent: None | int = None
                    # name = ' '.join(options.argument)
                    # if 'noindent' in options and options.noindent:
                    #     indent = 0
                    # elif 'indent' in options and options.indent:
                    #     indent = int(options.indent)
                    new_chunk = NamedChunk(options=shlex.split(arg_str))
                elif brack == None:
                    new_chunk = None
                    pass  # Error already noted by ``expect()``
                else:
                    raise RuntimeError("Design Error")
                
                if new_chunk:
                    self.content.append(new_chunk)
                # capture a NamedChunk up to @} or @]
    
            case self.cmdi:
                                
                incPath = Path(next(self.tokenizer).strip())
                try:
                    include = WebReader(parent=self)
                    if not incPath.is_absolute():
                        incPath = self.base_path / incPath
                    self.logger.info("Including '%s'", incPath)
                    self.content.extend(include.load(incPath))
                    self.totalLines += include.tokenizer.lineNumber
                    self.totalFiles += include.totalFiles
                    if include.errors:
                        self.errors += include.errors
                        self.logger.error("Errors in included file '%s', output is incomplete.", incPath)
                except Error as e:
                    self.logger.error("Problems with included file '%s', output is incomplete.", incPath)
                    self.errors += 1
                except IOError as e:
                    self.logger.error("Problems finding included file '%s', output is incomplete.", incPath)
                    # Discretionary -- sometimes we want to continue
                    if self.cmdi in self.permitList: pass
                    else: raise  # Seems heavy-handed, but, the file wasn't found!
                # Start a new context for text or commands *after* the ``@i``.
                self.content.append(Chunk())
    
            case self.cmdrcurl | self.cmdrbrak:
                                
                # Start a new context for text or commands *after* this command.
                self.content.append(Chunk())
    
            case self.cmdpipe:
                                
                try:
                    names = next(self.tokenizer).strip().split()
                    self.content[-1].def_names.extend(names)
                except AttributeError:
                    # Out of place @| user identifier command
                    self.logger.error("Unexpected references near %r: %r", self.location(), token)
                    self.errors += 1
    
            case self.cmdf:
                self.content[-1].commands.append(FileXrefCommand(self.location()))
            case self.cmdm:
                self.content[-1].commands.append(MacroXrefCommand(self.location()))
            case self.cmdu:
                self.content[-1].commands.append(UserIdXrefCommand(self.location()))
            case self.cmdlangl:
                                
                # get the name, introduce into the named Chunk dictionary
                name = next(self.tokenizer).strip()
                closing = self.expect({self.cmdrangl})
                self.content[-1].commands.append(ReferenceCommand(name, self.location()))
                self.logger.debug("Reading %r %r", name, closing)
    
            case self.cmdlexpr:
                                
                # get the Python expression, create the expression result
                expression = next(self.tokenizer)
                self.expect({self.cmdrexpr})
                try:
                    # Build Context
                    # **TODO:** Parts of this are static and can be built as part of ``__init__()``.
                    dangerous = {
                        'breakpoint', 'compile', 'eval', 'exec', 'execfile', 'globals', 'help', 'input', 
                        'memoryview', 'open', 'print', 'super', '__import__'
                    }
                    safe = types.SimpleNamespace(**dict(
                        (name, obj) 
                        for name,obj in builtins.__dict__.items() 
                        if name not in dangerous
                    ))
                    globals = dict(
                        __builtins__=safe, 
                        os=types.SimpleNamespace(path=os.path, getcwd=os.getcwd, name=os.name),
                        time=time,
                        datetime=datetime,
                        platform=platform,
                        theWebReader=self,
                        theFile=self.filePath,
                        thisApplication=sys.argv[0],
                        __version__=__version__,  # Legacy compatibility. Deprecated.
                        version=__version__,
                        theLocation=str(self.location()),  # The only thing that's dynamic
                        )
                    # Evaluate
                    result = str(eval(expression, globals))
                except Exception as exc:
                    self.logger.error('Failure to process %r: exception is %r', expression, exc)
                    self.errors += 1
                    result = f"@({expression!r}: Error {exc!r}@)"
                self.content[-1].add_text(result, self.location())
    
            case self.cmdcmd:
                                
                self.logger.debug(f"double-command: {self.content[-1]=}")
                self.content[-1].add_text(self.command, self.location())
    
            case self.cmdlcurl | self.cmdlbrak:
                # These should have been consumed as part of @o and @d parsing
                self.logger.error("Extra %r (possibly missing chunk name) near %r", token, self.location())
                self.errors += 1
            case _:
                return False  # did not recogize the command
        return True  # did recognize the command
    
    
    def expect(self, tokens: set[str]) -> str | None:
        """Compare next token with expectation, quietly skipping whitespace (i.e., ``\n``)."""
        try:
            t = next(self.tokenizer)
            while t == '\n':
                t = next(self.tokenizer)
        except StopIteration:
            self.logger.error("At %r: end of input, %r not found", self.location(), tokens)
            self.errors += 1
            return None
        if t in tokens:
            return t
        else:
            self.logger.error("At %r: expected %r, found %r", self.location(), tokens, t)
            self.errors += 1
            return None
    





class Action:
    """An action performed by pyWeb."""
    start: float
    options: argparse.Namespace

    def __init__(self, name: str) -> None:
        self.name = name
        self.logger = logging.getLogger(self.__class__.__qualname__)

    def __str__(self) -> str:
        return f"{self.name!s} [{self.options.web!s}]"
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        self.logger.info("Starting %s", self.name)
        self.options = options
        self.start = time.process_time()
    

    
        
    def duration(self) -> float:
        """Return duration of the action."""
        return (self.start and time.process_time()-self.start) or 0
        
    def summary(self) -> str:
        return f"{self.name!s} in {self.duration():0.3f} sec."
    




class ActionSequence(Action):
    """An action composed of a sequence of other actions."""
    def __init__(self, name: str, opSequence: list[Action] | None = None) -> None:
        super().__init__(name)
        if opSequence: self.opSequence = opSequence
        else: self.opSequence = []
        
    def __str__(self) -> str:
        return "; ".join([str(x) for x in self.opSequence])
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        for o in self.opSequence:
            o(self.options)
    

        
        
    def summary(self) -> str:
        return ", ".join([o.summary() for o in self.opSequence])
    




class WeaveAction(Action):
    """Weave the final document."""
    def __init__(self) -> None:
        super().__init__("Weave")
        
    def __str__(self) -> str:
        return f"{self.name!s} [{self.options.web!s}, {self.options.theWeaver!s}]"

        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        try:
            self.options.theWeaver.set_markup(self.options.weaver)
            self.options.theWeaver.emit(self.options.web)
            self.logger.info("Finished Normally")
        except Error as e:
            self.logger.error("Problems weaving document from %r (weave file is faulty).", self.options.web.web_path)
            #raise
    

    
        
    def summary(self) -> str:
        if self.options.theWeaver and self.options.theWeaver.linesWritten > 0:
            return (
                f"{self.name!s} {self.options.theWeaver.linesWritten:d} lines in {self.duration():0.3f} sec."
            )
        return f"did not {self.name!s}"
    




class TangleAction(Action):
    """Tangle source files."""
    def __init__(self) -> None:
        super().__init__("Tangle")
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        self.options.theTangler.include_line_numbers = self.options.tangler_line_numbers
        try:
            self.options.theTangler.emit(self.options.web)
        except Error as e:
            self.logger.error("Problems tangling outputs from %r (tangle files are faulty).", self.options.web.web_path)
            #raise
    

    
        
    def summary(self) -> str:
        if self.options.theTangler and self.options.theTangler.linesWritten > 0:
            return (
                f"{self.name!s} {self.options.theTangler.totalLines:d} lines in {self.duration():0.3f} sec."
            )
        return f"did not {self.name!r}"
    




class LoadAction(Action):
    """Load the source web."""
    def __init__(self) -> None:
        super().__init__("Load")
        
    def __str__(self) -> str:
        return f"Load [{self.webReader!s}, {self.options.web!s}]"
        
        
    def __call__(self, options: argparse.Namespace) -> None:
        super().__call__(options)
        self.webReader = self.options.webReader
        self.webReader.command = self.options.command
        self.webReader.permitList = self.options.permitList
        self.logger.debug("Reader Class %s", self.webReader.__class__.__name__)
    
        error = f"Problems with source file {self.options.source_path!r}, no output produced."
        try:
            chunks = self.webReader.load(self.options.source_path)
            if self.webReader.errors != 0:
                raise Error("Syntax Errors in the Web")
            self.logger.debug("Read %d Chunks", len(chunks))
            self.options.web = Web(chunks)
            self.options.web.web_path = self.options.source_path
            self.logger.debug("Web contains %3d chunks", len(self.options.web.chunks))
            self.logger.debug("Web defines  %3d files", len(self.options.web.files))
            self.logger.debug("Web defines  %3d macros", len(self.options.web.macros))
            self.logger.debug("Web defines  %3d names", len(self.options.web.userids))
        except Error as e:
            self.logger.error(error)
            raise  # Could not be parsed or built.
        except IOError as e:
            self.logger.error(error)
            raise
    

    
        
    def summary(self) -> str:
        return (
            f"{self.name!s} {self.webReader.totalLines:d} lines from {self.webReader.totalFiles:d} files in {self.duration():0.3f} sec."
        )
    





class Application:
    def __init__(self) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)
                
        self.defaults = argparse.Namespace(
            verbosity=logging.INFO,
            command='@',
            weaver='rst', 
            skip='',  # Don't skip any steps
            permit='',  # Don't tolerate failing commands
            reference='s',  # Simple references
            tangler_line_numbers=False,
            output=Path.cwd() / "docs",  # Weaving output
            target=Path.cwd(),  # Tangling output
            )

        
        
    def parseArgs(self, argv: list[str], **config: str) -> argparse.Namespace:
        p = argparse.ArgumentParser()
        p.add_argument("-v", "--verbose", dest="verbosity", action="store_const", const=logging.INFO)
        p.add_argument("-s", "--silent", dest="verbosity", action="store_const", const=logging.WARN)
        p.add_argument("-d", "--debug", dest="verbosity", action="store_const", const=logging.DEBUG)
        p.add_argument("-c", "--command", dest="command", action="store")
        p.add_argument("-w", "--weaver", dest="weaver", action="store")
        p.add_argument("-x", "--except", dest="skip", action="store", choices=('w', 't'))
        p.add_argument("-p", "--permit", dest="permit", action="store")
        p.add_argument("-n", "--linenumbers", dest="tangler_line_numbers", action="store_true")
        p.add_argument("-o", "--output", dest="output", action="store", type=Path, help="Weaver output")
        p.add_argument("-t", "--target", dest="target", action="store", type=Path, help="Tangler output")
        p.add_argument("-V", "--Version", action='version', version=f"py-web-lp pyweb.py {__version__}")
        p.add_argument("files", nargs='+', type=Path)
    
        defaults = vars(self.defaults) | config
        args = argparse.Namespace(**defaults)
        p.parse_args(argv, namespace=args)
    
        # Expand the permitted errors, usual case is ``-pi`` to permit the ``@i`` command to fail.
        if args.permit:
            args.permitList = [f'{args.command!s}{c!s}' for c in args.permit]
        else:
            args.permitList = []
    
        return args
    
    def inject(self, args: argparse.Namespace) -> argparse.Namespace:
        """Inject final classes by creating instances.
        This **updates** the args namespace.
        It puts concrete classes in place.
        """
        # Primitive Actions
        self.loadOp = LoadAction()
        self.weaveOp = WeaveAction()
        self.tangleOp = TangleAction()
    
        # Composite Actions
        self.doWeave = ActionSequence("load and weave", [self.loadOp, self.weaveOp])
        self.doTangle = ActionSequence("load and tangle", [self.loadOp, self.tangleOp])
        self.theAction = ActionSequence("load, tangle and weave", [self.loadOp, self.tangleOp, self.weaveOp])
    
        # Create Weaver & Tangler used by the Actions.
        # Update Weaver macros from config file.
        args.theWeaver = Weaver(args.output)
        if "macros" in args:
            args.theWeaver.config_macros = args.macros
        args.theTangler = TanglerMake(args.target)
    
        # Create the configured WebReader used by the Actions.
        args.webReader = WebReader()
    
        self.logger.debug("config: %r", args)
        return args
    

    
        
    def process(self, config: argparse.Namespace) -> None:
        root = logging.getLogger()
        root.setLevel(config.verbosity)
        self.logger.debug("Setting root log level to %r", logging.getLevelName(root.getEffectiveLevel()))
    
        self.inject(config)
    
        if config.command:
            self.logger.debug("Command character %r", config.command)
            
        if config.skip:
            if config.skip.lower().startswith('w'):  # not weaving == tangling
                self.theAction = self.doTangle
            elif config.skip.lower().startswith('t'):  # not tangling == weaving
                self.theAction = self.doWeave
            else:
                raise Exception(f"Unknown -x option {config.skip!r}")
    
        for f in config.files:
            self.logger.info("%s %s %r", self.theAction.name, __version__, f)
            config.source_path = f
            self.theAction(config)
            self.logger.info(self.theAction.summary())
    




class Logger:
    def __init__(self, dict_config: dict[str, Any] | None = None, **kw_config: Any) -> None:
        self.dict_config = dict_config
        self.kw_config = kw_config
        
    def __enter__(self) -> "Logger":
        if self.dict_config:
            logging.config.dictConfig(self.dict_config)
        else:
            logging.basicConfig(**self.kw_config)
        return self
        
    def __exit__(self, *args: Any) -> Literal[False]:
        logging.shutdown()
        return False

default_logging_config = {
    'version': 1,
    'disable_existing_loggers': False, # Allow pre-existing loggers to work.
    'style': '{',
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'stream': 'ext://sys.stderr',
            'formatter': 'basic',
        },
    },
    'formatters': {
        'basic': {
            'format': "{levelname}:{name}:{message}",
            'style': "{",
        }
    },
    
    'root': {'handlers': ['console'], 'level': logging.INFO,},
    
    # For specific debugging support...
    'loggers': {
        'Weaver': {'level': logging.INFO},
        'WebReader': {'level': logging.INFO},
        'Tangler': {'level': logging.INFO},
        'TanglerMake': {'level': logging.INFO},
        'indent.TanglerMake': {'level': logging.INFO},
        'Web': {'level': logging.INFO},
        # Unit test requires this...
        'ReferenceCommand': {'level': logging.INFO},
    },
}


def main(argv: list[str] = sys.argv[1:], base_config: dict[str, Any] | None=None) -> None:
    a = Application()
    config = a.parseArgs(argv, **(base_config or {}))
    a.process(config)


if __name__ == "__main__":
    config_dirs = Path.cwd(), Path.home(), Path(__file__).parent
    base_config: dict[str, Any] = {}
    for dir in config_dirs:
        cp = dir / "pyweb.toml"
        if cp.exists():
            with cp.open('rb') as config_file:
                base_config = toml.load(config_file)
            break
    log_config = base_config.get('logging', default_logging_config)
    with Logger(log_config):
        main(base_config=base_config.get('pyweb', {}))
