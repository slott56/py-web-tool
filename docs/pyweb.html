<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>pyWeb Literate Programming 3.3</title>
<--- Cannot embed stylesheet ''/Users/slott/miniconda3/envs/pywebtool/lib/python3.10/site-packages/docutils/writers/html4css1/html4css1.css'': No such file or directory. --->
<style type="text/css">

/* Page layout tweaks */
div.document { width: 7in; }
.small { font-size: smaller; }
.code
{
	color: #101080;
	display: block;
	border-color: black;
	border-width: thin;
	border-style: solid;
	background-color: #E0FFFF;
	/*#99FFFF*/
	padding: 0 0 0 1%;
	margin: 0 6% 0 6%;
	text-align: left;
	font-size: smaller;
}

</style>
</head>
<body>
<div class="document" id="pyweb-literate-programming-3-3">
<h1 class="title">pyWeb Literate Programming 3.3</h1>

<p><strong>Yet Another Literate Programming Tool</strong></p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a><ul>
<li><a class="reference internal" href="#background" id="toc-entry-2">Background</a></li>
<li><a class="reference internal" href="#other-tools" id="toc-entry-3">Other Tools</a></li>
<li><a class="reference internal" href="#py-web-lp" id="toc-entry-4"><strong>py-web-lp</strong></a></li>
<li><a class="reference internal" href="#acknowledgements" id="toc-entry-5">Acknowledgements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#installing" id="toc-entry-6">Installing</a></li>
<li><a class="reference internal" href="#using" id="toc-entry-7">Using</a><ul>
<li><a class="reference internal" href="#create-web-file" id="toc-entry-8">Create WEB File</a></li>
<li><a class="reference internal" href="#tangle-source-files" id="toc-entry-9">Tangle Source Files</a></li>
<li><a class="reference internal" href="#weave-documentation" id="toc-entry-10">Weave Documentation</a></li>
<li><a class="reference internal" href="#running-py-web-lp-to-tangle-and-weave" id="toc-entry-11">Running <strong>py-web-lp</strong> to Tangle and Weave</a><ul>
<li><a class="reference internal" href="#command-line-options" id="toc-entry-12">Command Line Options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bootstrapping" id="toc-entry-13">Bootstrapping</a></li>
<li><a class="reference internal" href="#dependencies" id="toc-entry-14">Dependencies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#more-advanced-usage" id="toc-entry-15">More Advanced Usage</a><ul>
<li><a class="reference internal" href="#tangle-test-and-weave-with-test-results" id="toc-entry-16">Tangle, Test, and Weave with Test Results</a></li>
<li><a class="reference internal" href="#template-changes" id="toc-entry-17">Template Changes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-py-web-lp-markup-language" id="toc-entry-18">The <strong>py-web-lp</strong> Markup Language</a><ul>
<li><a class="reference internal" href="#concepts" id="toc-entry-19">Concepts</a></li>
<li><a class="reference internal" href="#boilerplate" id="toc-entry-20">Boilerplate</a><ul>
<li><a class="reference internal" href="#latex" id="toc-entry-21">LaTeX</a></li>
<li><a class="reference internal" href="#html" id="toc-entry-22">HTML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#structural-tags" id="toc-entry-23">Structural Tags</a></li>
<li><a class="reference internal" href="#inline-tags" id="toc-entry-24">Inline Tags</a></li>
<li><a class="reference internal" href="#content-tags" id="toc-entry-25">Content Tags</a></li>
<li><a class="reference internal" href="#additional-features" id="toc-entry-26">Additional Features</a></li>
<li><a class="reference internal" href="#controlling-indentation" id="toc-entry-27">Controlling Indentation</a></li>
<li><a class="reference internal" href="#tracking-source-line-numbers" id="toc-entry-28">Tracking Source Line Numbers</a></li>
<li><a class="reference internal" href="#expression-context" id="toc-entry-29">Expression Context</a></li>
</ul>
</li>
<li><a class="reference internal" href="#architecture-and-design-overview" id="toc-entry-30">Architecture and Design Overview</a><ul>
<li><a class="reference internal" href="#overall-structure" id="toc-entry-31">Overall Structure</a></li>
<li><a class="reference internal" href="#core-web-representation" id="toc-entry-32">Core WEB Representation</a></li>
<li><a class="reference internal" href="#reading-and-parsing" id="toc-entry-33">Reading and Parsing</a></li>
<li><a class="reference internal" href="#emitters" id="toc-entry-34">Emitters</a></li>
<li><a class="reference internal" href="#weaving" id="toc-entry-35">Weaving</a></li>
<li><a class="reference internal" href="#tangling" id="toc-entry-36">Tangling</a></li>
<li><a class="reference internal" href="#application" id="toc-entry-37">Application</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation" id="toc-entry-38">Implementation</a><ul>
<li><a class="reference internal" href="#base-classes" id="toc-entry-39">Base Classes</a><ul>
<li><a class="reference internal" href="#web-class" id="toc-entry-40">Web Class</a></li>
<li><a class="reference internal" href="#chunk-class-hierarchy" id="toc-entry-41">Chunk Class Hierarchy</a></li>
<li><a class="reference internal" href="#command-class-hierarchy" id="toc-entry-42">Command Class Hierarchy</a><ul>
<li><a class="reference internal" href="#the-typeid-class" id="toc-entry-43">The TypeId Class</a></li>
<li><a class="reference internal" href="#the-command-class" id="toc-entry-44">The Command Class</a></li>
<li><a class="reference internal" href="#the-hastext-classes" id="toc-entry-45">The HasText Classes</a></li>
<li><a class="reference internal" href="#the-textcommand-class" id="toc-entry-46">The TextCommand Class</a></li>
<li><a class="reference internal" href="#the-codecommand-class" id="toc-entry-47">The CodeCommand Class</a></li>
<li><a class="reference internal" href="#the-referencecommand-class" id="toc-entry-48">The ReferenceCommand Class</a></li>
<li><a class="reference internal" href="#the-xrefcommand-classes" id="toc-entry-49">The XrefCommand Classes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#output-serialization" id="toc-entry-50">Output Serialization</a><ul>
<li><a class="reference internal" href="#the-weaver-subclass" id="toc-entry-51">The Weaver Subclass</a><ul>
<li><a class="reference internal" href="#common-base-template" id="toc-entry-52">Common Base Template</a></li>
<li><a class="reference internal" href="#debug-template" id="toc-entry-53">Debug Template</a></li>
<li><a class="reference internal" href="#rst-template" id="toc-entry-54">RST Template</a></li>
<li><a class="reference internal" href="#html-template" id="toc-entry-55">HTML Template</a></li>
<li><a class="reference internal" href="#latex-template" id="toc-entry-56">LaTeX Template</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-tangler-subclasses" id="toc-entry-57">The Tangler Subclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#input-parsing" id="toc-entry-58">Input Parsing</a><ul>
<li><a class="reference internal" href="#the-webreader-class" id="toc-entry-59">The WebReader Class</a></li>
<li><a class="reference internal" href="#the-tokenizer-class" id="toc-entry-60">The Tokenizer Class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-application-components" id="toc-entry-61">Other Application Components</a><ul>
<li><a class="reference internal" href="#error-class" id="toc-entry-62">Error class</a></li>
<li><a class="reference internal" href="#action-class-hierarchy" id="toc-entry-63">Action Class Hierarchy</a></li>
<li><a class="reference internal" href="#actionsequence-class" id="toc-entry-64">ActionSequence Class</a></li>
<li><a class="reference internal" href="#weaveaction-class" id="toc-entry-65">WeaveAction Class</a></li>
<li><a class="reference internal" href="#tangleaction-class" id="toc-entry-66">TangleAction Class</a></li>
<li><a class="reference internal" href="#loadaction-class" id="toc-entry-67">LoadAction Class</a></li>
<li><a class="reference internal" href="#the-application-class" id="toc-entry-68">The Application Class</a></li>
<li><a class="reference internal" href="#logging-setup" id="toc-entry-69">Logging Setup</a></li>
<li><a class="reference internal" href="#the-main-function" id="toc-entry-70">The Main Function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyweb-module-file" id="toc-entry-71"><strong>pyWeb</strong> Module File</a><ul>
<li><a class="reference internal" href="#python-library-imports" id="toc-entry-72">Python Library Imports</a></li>
<li><a class="reference internal" href="#overheads" id="toc-entry-73">Overheads</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#unit-tests" id="toc-entry-74">Unit Tests</a></li>
<li><a class="reference internal" href="#handy-scripts-and-other-files" id="toc-entry-75">Handy Scripts and Other Files</a><ul>
<li><a class="reference internal" href="#tangle-py-script" id="toc-entry-76"><tt class="docutils literal">tangle.py</tt> Script</a></li>
<li><a class="reference internal" href="#weave-py-script" id="toc-entry-77"><tt class="docutils literal">weave.py</tt> Script</a></li>
</ul>
</li>
<li><a class="reference internal" href="#to-do" id="toc-entry-78">To Do</a><ul>
<li><a class="reference internal" href="#restructuring" id="toc-entry-79">Restructuring</a></li>
<li><a class="reference internal" href="#additional-features-1" id="toc-entry-80">Additional Features</a></li>
<li><a class="reference internal" href="#other-extensions" id="toc-entry-81">Other Extensions</a></li>
<li><a class="reference internal" href="#some-additional-ideas" id="toc-entry-82">Some additional ideas</a></li>
<li><a class="reference internal" href="#from-the-code" id="toc-entry-83">From the code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#change-log" id="toc-entry-84">Change Log</a></li>
<li><a class="reference internal" href="#indices" id="toc-entry-85">Indices</a><ul>
<li><a class="reference internal" href="#files" id="toc-entry-86">Files</a></li>
<li><a class="reference internal" href="#macros" id="toc-entry-87">Macros</a></li>
<li><a class="reference internal" href="#user-identifiers" id="toc-entry-88">User Identifiers</a></li>
</ul>
</li>
</ul>
</div>
<!-- py-web-tool/src/intro.w -->
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#toc-entry-1">Introduction</a></h1>
<p>Literate programming was pioneered by Knuth as a method for
developing readable, understandable presentations of programs.
These would present a program in a literate fashion for people
to read and understand; this would be in parallel with presentation as source text
for a compiler to process and both would be generated from a common source file.</p>
<p>One intent is to synchronize the program source with the
documentation about that source.  If the program and the documentation
have a common origin, then the traditional gaps between intent
(expressed in the documentation) and action (expressed in the
working program) are significantly reduced.</p>
<p><strong>py-web-lp</strong> is a literate programming tool that combines the actions
of <em>weaving</em> a document with <em>tangling</em> source files.
It is independent of any source language.
While is designed to work with RST document markup, it should be amenable to any other
flavor of markup.
It uses a small set of markup tags to define chunks of code and
documentation.</p>
<div class="section" id="background">
<h2><a class="toc-backref" href="#toc-entry-2">Background</a></h2>
<p>The following is an almost verbatim quote from Briggs' <em>nuweb</em> documentation,
and provides an apt summary of Literate Programming.</p>
<blockquote>
<p>In 1984, Knuth introduced the idea of <em>literate programming</em> and
described a pair of tools to support the practise (Donald E. Knuth,
&quot;Literate Programming&quot;, <em>The Computer Journal</em> 27 (1984), no. 2, 97-111.)
His approach was to combine Pascal code with T<sub>e</sub>X documentation to
produce a new language, <tt class="docutils literal">WEB</tt>, that offered programmers a superior
approach to programming. He wrote several programs in <tt class="docutils literal">WEB</tt>,
including <tt class="docutils literal">weave</tt> and <tt class="docutils literal">tangle</tt>, the programs used to support
literate programming.
The idea was that a programmer wrote one document, the web file, that
combined documentation written in T<sub>e</sub>X (Donald E. Knuth,
T<sub>e</sub>X book, Computers and Typesetting, 1986) with code (written in Pascal).</p>
<p>Running <tt class="docutils literal">tangle</tt> on the web file would produce a complete
Pascal program, ready for compilation by an ordinary Pascal compiler.
The primary function of <tt class="docutils literal">tangle</tt> is to allow the programmer to
present elements of the program in any desired order, regardless of
the restrictions imposed by the programming language. Thus, the
programmer is free to present his program in a top-down fashion,
bottom-up fashion, or whatever seems best in terms of promoting
understanding and maintenance.</p>
<p>Running <tt class="docutils literal">weave</tt> on the web file would produce a  T<sub>e</sub>X file, ready
to be processed by  T<sub>e</sub>X. The resulting document included a variety of
automatically generated indices and cross-references that made it much
easier to navigate the code. Additionally, all of the code sections
were automatically prettyprinted, resulting in a quite impressive
document.</p>
<p>Knuth also wrote the programs for T<sub>e</sub>X and <tt class="docutils literal">METAFONT</tt>
entirely in <tt class="docutils literal">WEB</tt>, eventually publishing them in book
form. These are probably the
largest programs ever published in a readable form.</p>
</blockquote>
</div>
<div class="section" id="other-tools">
<h2><a class="toc-backref" href="#toc-entry-3">Other Tools</a></h2>
<p>Numerous tools have been developed based on Knuth's initial
work.  A relatively complete survey is available at sites
like <a class="reference external" href="http://www.literateprogramming.com">Literate Programming</a>,
and the OASIS
<a class="reference external" href="http://www.oasis-open.org/cover/xmlLitProg.html">XML Cover Pages: Literate Programming with SGML and XML</a>.</p>
<p>The immediate predecessors to this <strong>py-web-lp</strong> tool are
<a class="reference external" href="http://www.ross.net/funnelweb">FunnelWeb</a>,
<a class="reference external" href="http://www.eecs.harvard.edu/~nr/noweb/">noweb</a> and
<a class="reference external" href="http://sourceforge.net/projects/nuweb/">nuweb</a>.  The ideas lifted from these other
tools created the foundation for <strong>py-web-lp</strong>.</p>
<p>There are several Python-oriented literate programming tools.
These include
<a class="reference external" href="http://personalpages.tds.net/~edream/front.html&quot;">LEO</a>,
<a class="reference external" href="http://interscript.sourceforge.net/">interscript</a>,
<a class="reference external" href="http://www.danbala.com/python/lpy/">lpy</a>,
<a class="reference external" href="http://www.egenix.com/files/python/SoftwareDescriptions.html#py2html.py">py2html</a>,
<a class="reference external" href="https://github.com/slott56/PyLit-3">PyLit-3</a></p>
<p>The <em>FunnelWeb</em> tool is independent of any programming language
and only mildly dependent on T<sub>e</sub>X.
It has 19 commands, many of which duplicate features of HTML or
L<sub>a</sub>T<sub>e</sub>X.</p>
<p>The <em>noweb</em> tool was written by Norman Ramsey.
This tool uses a sophisticated multi-processing framework, via Unix
pipes, to permit flexible manipulation of the source file to tangle
and weave the programming language and documentation markup files.</p>
<p>The <em>nuweb</em> Simple Literate Programming Tool was developed by
Preston Briggs (<a class="reference external" href="mailto:preston&#64;tera.com">preston&#64;tera.com</a>).  His work was supported by ARPA,
through ONR grant N00014-91-J-1989.  It is written
in C, and very focused on producing L<sub>a</sub>T<sub>e</sub>X documents.  It can
produce HTML, but this is clearly added after the fact.  It cannot be
easily extended, and is not object-oriented.</p>
<p>The <em>LEO</em> tool is a structured GUI editor for creating
source.  It uses XML and <em>noweb</em>-style chunk management.  It is more
than a simple weave and tangle tool.</p>
<p>The <em>interscript</em> tool is very large and sophisticated, but doesn't gracefully
tolerate HTML markup in the document.  It can create a variety of
markup languages from the interscript source, making it suitable for
creating HTML as well as L<sub>a</sub>T<sub>e</sub>X.</p>
<p>The <em>lpy</em> tool can produce very complex HTML representations of
a Python program.  It works by locating documentation markup embedded
in Python comments and docstrings.  This is called &quot;inverted literate
programming&quot;.</p>
<p>The <em>py2html</em> tool does very sophisticated syntax coloring.</p>
<p>The <em>PyLit-3</em> tool is perhaps the very best approach to Literate
programming, since it leverages an existing lightweight markup language
and it's output formatting. However, it's limited in the presentation order,
making it difficult to present a complex Python module out of the proper
Python required presentation.</p>
</div>
<div class="section" id="py-web-lp">
<h2><a class="toc-backref" href="#toc-entry-4"><strong>py-web-lp</strong></a></h2>
<p><strong>py-web-lp</strong> works with any
programming language. It can work with any markup language, but is currently
configured to work with RST.  This philosophy
comes from <em>FunnelWeb</em>
<em>noweb</em>, <em>nuweb</em> and <em>interscript</em>.  The primary differences
between <strong>py-web-lp</strong> and other tools are the following.</p>
<ul class="simple">
<li><strong>py-web-lp</strong> is object-oriented, permitting easy extension.
<em>noweb</em> extensions
are separate processes that communicate through a sophisticated protocol.
<em>nuweb</em> is not easily extended without rewriting and recompiling
the C programs.</li>
<li><strong>py-web-lp</strong> is built in the very portable Python programming
language.  This allows it to run anywhere that Python 3.3 runs, with
only the addition of docutils.  This makes it a useful
tool for programmers in any language.</li>
<li><strong>py-web-lp</strong> is much simpler than <em>FunnelWeb</em>, <em>LEO</em> or <em>Interscript</em>.  It has
a very limited selection of commands, but can still produce
complex programs and HTML documents.</li>
<li><strong>py-web-lp</strong> does not invent a complex markup language like <em>Interscript</em>.
Because <em>Iterscript</em> has its own markup, it can generate L<sub>a</sub>T<sub>e</sub>X or HTML or other
output formats from a unique input format.  While powerful, it seems simpler to
avoid inventing yet another sophisticated markup language.  The language <strong>py-web-lp</strong>
uses is very simple, and the author's use their preferred markup language almost
exclusively.</li>
<li><strong>py-web-lp</strong> supports the forward literate programming philosophy,
where a source document creates programming language and markup language.
The alternative, deriving the document from markup embedded in
program comments (&quot;inverted literate programming&quot;), seems less appealing.
The disadvantage of inverted literate programming is that the final document
can't reflect the original author's preferred order of exposition,
since that informtion generally isn't part of the source code.</li>
<li><strong>py-web-lp</strong> also specifically rejects some features of <em>nuweb</em>
and <em>FunnelWeb</em>.  These include the macro capability with parameter
substitution, and multiple references to a chunk.  These two capabilities
can be used to grow object-like applications from non-object programming
languages (<em>e.g.</em> C or Pascal).  Since most modern languages (Python,
Java, C++) are object-oriented, this macro capability is more of a problem
than a help.</li>
<li>Since <strong>py-web-lp</strong> is built in the Python interpreter, a source document
can include Python expressions that are evaluated during weave operation to
produce time stamps, source file descriptions or other information in the woven
or tangled output.</li>
</ul>
<p><strong>py-web-lp</strong> works with any programming language; it can work with any markup language.
The initial release supports RST via simple templates.</p>
<p>The following is extensively quoted from Briggs' <em>nuweb</em> documentation,
and provides an excellent background in the advantages of the very
simple approach started by <em>nuweb</em> and adopted by <strong>py-web-lp</strong>.</p>
<blockquote>
<p>The need to support arbitrary
programming languages has many consequences:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">No prettyprinting:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">Both <tt class="docutils literal">WEB</tt> and <tt class="docutils literal">CWEB</tt> are able to
prettyprint the code sections of their documents because they
understand the language well enough to parse it. Since we want to use
<em>any</em> language, we've got to abandon this feature.
However, we do allow particular individual formulas or fragments
of L<sub>a</sub>T<sub>e</sub>X
or HTML code to be formatted and still be part of the output files.</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Limited index of identifiers:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">Because <tt class="docutils literal">WEB</tt> knows about Pascal,
it is able to construct an index of all the identifiers occurring in
the code sections (filtering out keywords and the standard type
identifiers). Unfortunately, this isn't as easy in our case. We don't
know what an identifier looks like in each language and we certainly
don't know all the keywords.  We provide a mechanism to mark
identifiers, and we use a pretty standard pattern for recognizing
identifiers almost most programming languages.</td>
</tr>
</tbody>
</table>
<p>Of course, we've got to have some compensation for our losses or the
whole idea would be a waste. Here are the advantages I [Briggs] can see:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Simplicity:</th><td class="field-body">The majority of the commands in <tt class="docutils literal">WEB</tt> are concerned with control of the
automatic prettyprinting. Since we don't prettyprint, many commands are
eliminated. A further set of commands is subsumed by L<sub>a</sub>T<sub>e</sub>X
and may also be eliminated. As a result, our set of commands is reduced to
only about seven members (explained in the next section).
This simplicity is also reflected in the size of this tool,
which is quite a bit smaller than the tools used with other approaches.</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">No prettyprinting:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">Everyone disagrees about how their code should look, so automatic
formatting annoys many people. One approach is to provide ways to
control the formatting. Our approach is simpler -- we perform no
automatic formatting and therefore allow the programmer complete
control of code layout.</td>
</tr>
<tr class="field"><th class="field-name">Control:</th><td class="field-body">We also offer the programmer reasonably complete control of the
layout of his output files (the files generated during tangling).
Of course, this is essential for languages that are sensitive to layout;
but it is also important in many practical situations, <em>e.g.</em>, debugging.</td>
</tr>
<tr class="field"><th class="field-name">Speed:</th><td class="field-body">Since [<strong>py-web-lp</strong>] doesn't do too much, it runs very quickly.
It combines the functions of <tt class="docutils literal">tangle</tt> and <tt class="docutils literal">weave</tt> into a single
program that performs both functions at once.</td>
</tr>
<tr class="field"><th class="field-name">Chunk numbers:</th><td class="field-body">Inspired by the example of <strong>noweb</strong>, [<strong>py-web-lp</strong>] refers to all program code
chunks by a simple, ascending sequence number through the file.
This becomes the HTML anchor name, also.</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Multiple file output:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">The programmer may specify more than one output file in a single [<strong>py-web-lp</strong>]
source file. This is required when constructing programs in a combination of
languages (say, Fortran and C). It's also an advantage when constructing
very large programs.</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
<div class="section" id="acknowledgements">
<h2><a class="toc-backref" href="#toc-entry-5">Acknowledgements</a></h2>
<dl class="docutils">
<dt>This application is very directly based on (derived from?) work that</dt>
<dd>preceded this, particularly the following:</dd>
</dl>
<ul class="simple">
<li>Ross N. Williams' <em>FunnelWeb</em> <a class="reference external" href="http://www.ross.net/funnelweb/">http://www.ross.net/funnelweb/</a></li>
<li>Norman Ramsey's <em>noweb</em> <a class="reference external" href="http://www.eecs.harvard.edu/~nr/noweb/">http://www.eecs.harvard.edu/~nr/noweb/</a></li>
<li>Preston Briggs' <em>nuweb</em> <a class="reference external" href="http://sourceforge.net/projects/nuweb/">http://sourceforge.net/projects/nuweb/</a>
Currently supported by Charles Martin and Marc W. Mengel</li>
</ul>
<p>Also, after using John Skaller's <em>interscript</em> <a class="reference external" href="http://interscript.sourceforge.net/">http://interscript.sourceforge.net/</a>
for two large development efforts, I finally understood the feature set I really wanted.</p>
<p>Jason Fruit and others contributed to the previous version.</p>
<!-- py-web-tool/src/usage.w -->
</div>
</div>
<div class="section" id="installing">
<h1><a class="toc-backref" href="#toc-entry-6">Installing</a></h1>
<p>This requires Python 3.12.</p>
<pre class="literal-block">
python -m pip install py-web-lp
</pre>
<p>This will install a <tt class="docutils literal">pyweb</tt> module.
Running the various commands is done with the <tt class="docutils literal">python <span class="pre">-m</span> pyweb</tt> command.</p>
</div>
<div class="section" id="using">
<h1><a class="toc-backref" href="#toc-entry-7">Using</a></h1>
<p><strong>py-web-lp</strong> supports two use cases: <a class="reference internal" href="#tangle-source-files">Tangle Source Files</a> and <a class="reference internal" href="#weave-documentation">Weave Documentation</a>.
These are often combined to both tangle and weave an application and its documentation.
The work starts with creating a WEB file with both the documentation and code.</p>
<div class="section" id="create-web-file">
<h2><a class="toc-backref" href="#toc-entry-8">Create WEB File</a></h2>
<p>See <a class="reference internal" href="#the-py-web-lp-markup-language">The py-web-lp Markup Language</a> for more details on the language.
For a simple example, we'll use the following WEB file: <tt class="docutils literal">examples/hw.w</tt>.</p>
<pre class="literal-block">
###########
Hello World
###########

This file has a <em>small</em> example.

&#64;d The Body Of The Script &#64;{
print(&quot;Hello, World!&quot;)
&#64;}

The Python module includes a small script.

&#64;o hw.py &#64;{
&#64;&lt;The Body...&#64;&gt;
&#64;}
</pre>
<p>This example will create an RST markup document.
The WEB file includes some <tt class="docutils literal">&#64;d</tt> and <tt class="docutils literal">&#64;o</tt> chunks to define code blocks.
The <tt class="docutils literal">&#64;d</tt> is the definition of a chunk with the longish name <tt class="docutils literal">The Body Of The Script</tt>.
The <tt class="docutils literal">&#64;o</tt> defines an output file to be tangled.
This file has a reference to the <tt class="docutils literal">The Body Of The Script</tt> chunk.</p>
<p>When tangling, the code will be used to build the file(s) defined by the <tt class="docutils literal">&#64;o</tt> chunk(s).
In this example, it will write the <tt class="docutils literal">hw.py</tt> file by tangling the referenced chunk.</p>
<p>When weaving, the <tt class="docutils literal">&#64;d</tt> and <tt class="docutils literal">&#64;o</tt> chunks will have some additional RST markup inserted to create a readable document.
The output file will have a name based on the source WEB document.
In this case it will be <tt class="docutils literal">hw.rst</tt>.</p>
</div>
<div class="section" id="tangle-source-files">
<h2><a class="toc-backref" href="#toc-entry-9">Tangle Source Files</a></h2>
<p>A user initiates this process when they have a complete <tt class="docutils literal">.w</tt> file that contains  a description of source files.
These source files are described with <tt class="docutils literal">&#64;o</tt> commands in the WEB file.</p>
<p>The use case is successful when the source files are produced.</p>
<p>The use case is a failure when the source files cannot be produced, due to  errors in the <tt class="docutils literal">.w</tt> file.
The log messages detail the problems found.</p>
<p>A typical command to tangle (without weaving) is:</p>
<pre class="literal-block">
python -m pyweb -xw examples/hw.w -o examples
</pre>
<p>The outputs will be defined by the <tt class="docutils literal">&#64;o</tt> commands in the source.
The <tt class="docutils literal"><span class="pre">-o</span></tt> option writes the resulting tangled files to the named directory.
The <tt class="docutils literal"><span class="pre">-xw</span></tt> option excludes weaving.</p>
</div>
<div class="section" id="weave-documentation">
<h2><a class="toc-backref" href="#toc-entry-10">Weave Documentation</a></h2>
<p>A user initiates this process when they have a <tt class="docutils literal">.w</tt> file that contains  a document to produce.
The document is described by the entire WEB file.
The default is to use ReSTructured Text (RST) markup.
The output file will have the <tt class="docutils literal">.rst</tt> suffix.</p>
<p>The use case is successful when the documentation file is produced.</p>
<p>The use case is a failure when the documentation file cannot be produced, due to  errors in the <tt class="docutils literal">.w</tt> file.
The log messages detail the problems found.</p>
<p>A typical command to weave (without tangling) is:</p>
<pre class="literal-block">
python -m pyweb -xt examples/hw.w -o examples
</pre>
<p>The output will be named <tt class="docutils literal">examples/hw.rst</tt>.
The <tt class="docutils literal"><span class="pre">-o</span></tt> option made sure the file was written to the <tt class="docutils literal">examples</tt> directory.
The <tt class="docutils literal"><span class="pre">-xt</span></tt> option excludes tangling.</p>
</div>
<div class="section" id="running-py-web-lp-to-tangle-and-weave">
<h2><a class="toc-backref" href="#toc-entry-11">Running <strong>py-web-lp</strong> to Tangle and Weave</a></h2>
<p>The following command will run both weaving and tanglging:</p>
<pre class="code bash literal-block">
python<span class="whitespace"> </span>-m<span class="whitespace"> </span>pyweb<span class="whitespace"> </span>examples/hw.w<span class="whitespace"> </span>-o<span class="whitespace"> </span>examples
</pre>
<p>The <tt class="docutils literal">&#64;o</tt> commands in <tt class="docutils literal">examples/hw.w</tt> define the files to tangle.
It will also weave the output, and create <tt class="docutils literal">examples/hw.rst</tt>.
This can be processed by tools like <strong>docutils</strong> to create an HTML file.</p>
<div class="section" id="command-line-options">
<h3><a class="toc-backref" href="#toc-entry-12">Command Line Options</a></h3>
<p>Currently, the following command line options are accepted.</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-v</span></kbd></td>
<td>Verbose logging.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-s</span></kbd></td>
<td>Silent operation.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>-c <em>x</em></dt>
<dd>Change the command character from <tt class="docutils literal">&#64;</tt> to <tt class="docutils literal">*x*</tt>.</dd>
<dt>-w <em>weaver</em></dt>
<dd>Choose a particular documentation weaver template. Currently the choices
are <tt class="docutils literal">rst</tt>, <tt class="docutils literal">tex</tt>, and <tt class="docutils literal">html</tt>.</dd>
</dl>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-x<var>w</var></span></kbd></td>
<td>Exclude weaving.  This does tangling of source program files only.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-x<var>t</var></span></kbd></td>
<td>Exclude tangling.  This does weaving of the document file only.</td></tr>
</tbody>
</table>
<dl class="docutils">
<dt>-p <em>command</em></dt>
<dd>Permit errors in the given list of commands.  The most common
version is <tt class="docutils literal"><span class="pre">-pi</span></tt> to permit errors in locating an include file.
For more, see the <a class="reference internal" href="#tangle-test-and-weave-with-test-results">Tangle, Test, and Weave with Test Results</a> section.</dd>
<dt>-o <em>directory</em></dt>
<dd>The directory to which to write output files.</dd>
</dl>
</div>
</div>
<div class="section" id="bootstrapping">
<h2><a class="toc-backref" href="#toc-entry-13">Bootstrapping</a></h2>
<p><strong>py-web-lp</strong> is written using <strong>py-web-lp</strong>.
The distribution includes the original <tt class="docutils literal">.w</tt> files as well as a <tt class="docutils literal">.py</tt> module.</p>
<p>The bootstrap procedure is to run a &quot;known good&quot; <tt class="docutils literal">pyweb</tt> to transform a working copy into a new version of <tt class="docutils literal">pyweb</tt>.
We provide the previous release in the <tt class="docutils literal">bootstrap</tt> directory.</p>
<pre class="literal-block">
python bootstrap/pyweb.py pyweb.w
rst2html.py pyweb.rst pyweb.html
</pre>
<p>The resulting <tt class="docutils literal">pyweb.html</tt> file is the updated documentation.
The <tt class="docutils literal">pyweb.py</tt> is the updated candidate release of <strong>py-web-lp</strong>.</p>
<p>Similarly, the tests built from a <tt class="docutils literal">.w</tt> files.</p>
<pre class="code bash literal-block">
python<span class="whitespace"> </span>pyweb.py<span class="whitespace"> </span>tests/pyweb_test.w<span class="whitespace"> </span>-o<span class="whitespace"> </span>tests<span class="whitespace">
</span><span class="name variable">PYTHONPATH</span><span class="operator">=</span>..<span class="whitespace"> </span>pytest<span class="whitespace">
</span>rst2html.py<span class="whitespace"> </span>tests/pyweb_test.rst<span class="whitespace"> </span>tests/pyweb_test.html
</pre>
</div>
<div class="section" id="dependencies">
<h2><a class="toc-backref" href="#toc-entry-14">Dependencies</a></h2>
<p><strong>py-web-lp</strong> requires Python 3.12 or newer.</p>
<p>The following components are listed in the <tt class="docutils literal">requirements.txt</tt> file.
These can be loaded via</p>
<pre class="code bash literal-block">
python<span class="whitespace"> </span>-m<span class="whitespace"> </span>pip<span class="whitespace"> </span>install<span class="whitespace"> </span>-r<span class="whitespace"> </span>requirements.txt
</pre>
<p>This project uses <a class="reference external" href="https://palletsprojects.com/p/jinja/">Jinja</a> for template processing.</p>
<p>The <a class="reference external" href="https://pypi.org/project/tomli/">tomli</a> library is used to parse configuration files
for older Python that lack a <tt class="docutils literal">tomllib</tt> in the standard library.</p>
<p>If you create RST output, you'll want to use either <a class="reference external" href="https://docutils.sourceforge.io">docutils</a> or <a class="reference external" href="https://www.sphinx-doc.org/en/master/">Sphinx</a> to translate the RST to HTML or LaTeX or any of the other formats supported by docutils or Sphinx.
This is not a proper requirement to run the tool.
It's a common part of an overall document production tool chain.</p>
<p>The overview contains PlantUML diagrams.
See <a class="reference external" href="https://plantuml.com/">https://plantuml.com/</a> for more information.
The <a class="reference external" href="https://github.com/sphinx-contrib/plantuml">PlantUML for Sphinx</a> plug-in can be used to render the diagrams automatically.</p>
<p>For development, additional components like <tt class="docutils literal">pytest</tt>, <tt class="docutils literal">tox</tt>, and <tt class="docutils literal">mypy</tt> are also used for development.</p>
</div>
</div>
<div class="section" id="more-advanced-usage">
<h1><a class="toc-backref" href="#toc-entry-15">More Advanced Usage</a></h1>
<p>Here are two more advanced use cases.</p>
<div class="section" id="tangle-test-and-weave-with-test-results">
<h2><a class="toc-backref" href="#toc-entry-16">Tangle, Test, and Weave with Test Results</a></h2>
<p>A user initiates this process when the final document should include test output  from the source files created by the tangle operation.
This is an extension to  the example shown earlier.</p>
<pre class="literal-block">
###########
Hello World
###########

This file has a <em>small</em> example.

&#64;d The Body Of The Script &#64;{
print(&quot;Hello, World!&quot;)
&#64;}

The Python module includes a small script.

&#64;o hw.py &#64;{
&#64;&lt;The Body...&#64;&gt;
&#64;}

Example Output
==============

&#64;i examples/hw_output.log
</pre>
<p>The use case is successful when the documentation file is produced, including current test output.</p>
<p>The use case is a failure when the documentation file cannot be produced, due to
errors in the <tt class="docutils literal">.w</tt> file.
The log will detail the problems preventing processing.</p>
<p>The use case can also be a failure when the documentation file does not include correct test output.</p>
<p>The sequence is as follows:</p>
<pre class="literal-block">
python -m pyweb -xw -pi examples/hw.w -o examples
python examples/hw.py &gt;examples/hw_output.log
python -m pyweb -xt examples/hw.w -o examples
</pre>
<p>The first step uses <tt class="docutils literal"><span class="pre">-xw</span></tt> to excludes document weaving.
The <tt class="docutils literal"><span class="pre">-pi</span></tt> option will permits errors on the <tt class="docutils literal">&#64;i</tt> command.
This is necessary in the event that the log file does not yet exist.</p>
<p>The second step runs the test, creating a log file.</p>
<p>The third step weaves the final document, including the test output file.
The <tt class="docutils literal"><span class="pre">-xt</span></tt> option excludes tangling, since output file had already been produced.</p>
</div>
<div class="section" id="template-changes">
<h2><a class="toc-backref" href="#toc-entry-17">Template Changes</a></h2>
<p>The woven document is based -- primarily -- on the text in the source WEB file.
This is processed using a small set of Jinja2 macros to modify behavior.
To fine-tune the results, we can adjust the templates used by this application.</p>
<p>The easiest way to do this is to work with the <tt class="docutils literal">weave.py</tt> script which shows how to create a customized subclass of <tt class="docutils literal">Weaver</tt>.
The <a class="reference internal" href="#handy-scripts-and-other-files">Handy Scripts and Other Files</a> section shows this script and how to build it from a few <tt class="docutils literal">pyweb</tt> components.</p>
<!-- py-web-tool/src/language.w -->
</div>
</div>
<div class="section" id="the-py-web-lp-markup-language">
<h1><a class="toc-backref" href="#toc-entry-18">The <strong>py-web-lp</strong> Markup Language</a></h1>
<p>The essence of literate programming is a markup language that includes both code as well as documentation.
For tangling, the code is relevant.
For weaving, both code and documentation are relevant.</p>
<p>The source document is a &quot;Web&quot; document that includes the code.
It's important to understand the <tt class="docutils literal">.w</tt> file as the only source for code and documentation.
The code is tangled out  of the source web file.</p>
<p>The <strong>py-web-lp</strong> tool parses the <tt class="docutils literal">.w</tt> file, and performs the tangle and weave operations.
It <em>tangles</em> each individual output file from the program source chunks.
It <em>weaves</em> the final documentation file file from the entire sequence of chunks provided, mixing the author's  original documentation with some markup around the embedded program source.</p>
<div class="section" id="concepts">
<h2><a class="toc-backref" href="#toc-entry-19">Concepts</a></h2>
<p>The <tt class="docutils literal">.w</tt> file has two tiers of markup in it.</p>
<ul class="simple">
<li>At the top, a file will have <strong>py-web-lp</strong> markup to distinguish
documentation chunks from code chunks.</li>
<li>Within the documentation chunks, there can be markup for the target publication tool chain.
This might be RST, LaTeX, HTML, or some other markup language.</li>
</ul>
<p>The <strong>py-web-lp</strong> markup decomposes the source document a sequence of <em>Chunks</em>.</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 583)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    object web
    object chunk
    object documentation
    object &quot;source code&quot; as code

    web *-- chunk
    chunk *-- documentation
    chunk *-- code

</pre>
</div>
<p>The chunks have the following two overall sets of features:</p>
<ul>
<li><p class="first">Program source code to be <em>tangled</em> and <em>woven</em>. There are two important varieties:</p>
<ul class="simple">
<li>&quot;defined&quot; chunks that have names,</li>
<li>&quot;output&quot; chunks that lead to writing a tangled file.</li>
</ul>
<p>Output chunks can have references to defined code chunks defined anywhere else in the web file.
This permits tangling output files in a compiler-friendly order, separate from a sensible presentation order.</p>
</li>
<li><p class="first">Documentation to be <em>woven</em>.  These are the blocks of text between commands.</p>
</li>
</ul>
<p>The bulk of the file is typically documentation chunks that describe the program in
some publication-oriented markup language like RST, HTML, or LaTeX.</p>
<p>All code chunks have two transformations applied:</p>
<ul class="simple">
<li>When Tangling, the indentation is adjusted to match the context in which they were originally defined.
This assures that Python (which relies on indentation) parses correctly.
For other languages, proper indentation is expected but not required.</li>
<li>When Weaving, selected characters can be quoted so they don't break the publication tool.
For HTML, <tt class="docutils literal">&amp;</tt>, <tt class="docutils literal">&lt;</tt>, <tt class="docutils literal">&gt;</tt> are quoted properly.
For LaTeX, a few escapes are used to avoid problems with the <tt class="docutils literal">fancyvrb</tt> environment.</li>
</ul>
<p>The non-code documentation chunks are not transformed up in any way.
Everything that's not explicitly a code chunk is output without modification.</p>
<p>All of the <strong>py-web-lp</strong> tags begin with <tt class="docutils literal">&#64;</tt>.
This is sometimes called the command prefix.
(This can be changed.)
The tags were historically referred to as &quot;commands.&quot;
For Python code using decorators, the symbol must be doubled, <tt class="docutils literal">&#64;&#64;</tt>, because all <tt class="docutils literal">&#64;</tt> symbols are commands, irrespective of context.</p>
<p>The <em>Structural</em> tags (historically called &quot;major commands&quot;) partition the input and define the various chunks.
The <em>Inline</em> tags are (called &quot;minor commands&quot;) are used to control the woven and tangled output from the defined chunks.
There are <em>Content</em> tags which generate  summary cross-reference content in woven files.</p>
</div>
<div class="section" id="boilerplate">
<h2><a class="toc-backref" href="#toc-entry-20">Boilerplate</a></h2>
<p>There is some mandatory &quot;boilerplate&quot; required to make a working document.
Requirements vary by markup language.</p>
<div class="section" id="latex">
<h3><a class="toc-backref" href="#toc-entry-21">LaTeX</a></h3>
<p>The LaTeX templates use <tt class="docutils literal">\\fancyvrb</tt>.
The following is required.</p>
<pre class="literal-block">
\\usepackage{fancyvrb}
</pre>
<p>Some minimal boilerplate document looks like this:</p>
<pre class="literal-block">
\documentclass{article}
\usepackage{fancyvrb}
\title{ <em>Title</em> }
\author{ <em>Author</em> }

\begin{document}

\maketitle
\tableofcontents

<em>Your Document Starts Here</em>

\end{document}
</pre>
</div>
<div class="section" id="html">
<h3><a class="toc-backref" href="#toc-entry-22">HTML</a></h3>
<p>There's often a fairly large amount of HTML boilerplate.
Currently, the templates used do <strong>not</strong> provide any CSS classes.
For more sophisticated HTML documents, it may be necessary to
provide customized templates with CSS classes to make the
document look good.</p>
</div>
</div>
<div class="section" id="structural-tags">
<h2><a class="toc-backref" href="#toc-entry-23">Structural Tags</a></h2>
<p>There are two definitional tags; these define the various chunks
in an input file.</p>
<p><tt class="docutils literal">&#64;o</tt> <em>file</em> <tt class="docutils literal">&#64;{</tt> <em>text</em> <tt class="docutils literal">&#64;}</tt></p>
<blockquote>
<p>The <tt class="docutils literal">&#64;o</tt> (output) command defines a named output file chunk.
The text is tangled to the named
file with no alteration.  It is woven into the document
in an appropriate fixed-width font.</p>
<p>There are options available to specify comment conventions
for the tangled output; this allows inclusion of source
line numbers.</p>
</blockquote>
<p><tt class="docutils literal">&#64;d</tt> <em>name</em> <tt class="docutils literal">&#64;{</tt> <em>text</em> <tt class="docutils literal">&#64;}</tt></p>
<blockquote>
<p>The <tt class="docutils literal">&#64;d</tt> (define) command defines a named chunk of program source.
This text is tangled or woven when it is referenced by the <em>reference</em> inline tag.</p>
<p>There are options available to specify the indentation for this particular chunk.
In rare cases, it can be helpful to override the indentation context.</p>
</blockquote>
<p>Each <tt class="docutils literal">&#64;o</tt> and <tt class="docutils literal">&#64;d</tt> tag is followed by a chunk which is delimited by <tt class="docutils literal">&#64;{</tt> and <tt class="docutils literal">&#64;}</tt> tags.
At the end of that chunk, there is an optional &quot;major&quot; tag.</p>
<p><tt class="docutils literal">&#64;|</tt></p>
<blockquote>
A chunk may define user identifiers.
The list of defined identifiers is placed in the chunk, separated by the <tt class="docutils literal">&#64;|</tt> separator.
This is used to create the index material.</blockquote>
<p>Additionally, these tags provide for the inclusion of additional input files.
This is necessary for decomposing a long document into easy-to-edit sections.</p>
<p><tt class="docutils literal">&#64;i</tt> <em>file</em></p>
<blockquote>
The <tt class="docutils literal">&#64;i</tt> (include) command includes another file.  The previous chunk
is ended.  The file is processed completely, then a new chunk
is started for the text after the <tt class="docutils literal">&#64;i</tt> command.</blockquote>
<p>All material that is not explicitly in a <tt class="docutils literal">&#64;o</tt> or <tt class="docutils literal">&#64;d</tt> named chunk is implicitly collected into a sequence of anonymous document source chunks.
These anonymous chunks form the backbone of the document that is woven.
The anonymous chunks are never tangled into output program source files.
They are woven into the document without any alteration.</p>
<p>Note that white space (line breaks (<tt class="docutils literal">'\n'</tt>), tabs and spaces) have no effect on the input parsing.
They are completely preserved on output.</p>
<p>The following example has three chunks:</p>
<pre class="literal-block">
Some RST-format documentation that describes the following piece of the
program.

&#64;o myFile.py
&#64;{
import math
print( math.pi )
&#64;| math math.pi
&#64;}

Some more RST documentation.
</pre>
<p>This starts with an anonymous chunk of documentation.
It includes a named output chunk which will write to <tt class="docutils literal">myFile.py</tt>.
It ends with an anonymous chunk of documentation.</p>
</div>
<div class="section" id="inline-tags">
<h2><a class="toc-backref" href="#toc-entry-24">Inline Tags</a></h2>
<p>There are several tags that are replaced by content in the woven output.</p>
<p><tt class="docutils literal">&#64;&#64;</tt></p>
<blockquote>
The <tt class="docutils literal">&#64;&#64;</tt> command creates a single <tt class="docutils literal">&#64;</tt> in the output file.
This is replaced in tangled as well as woven output.</blockquote>
<p><tt class="docutils literal">&#64;&lt;</tt><em>name</em><tt class="docutils literal">&#64;&gt;</tt></p>
<blockquote>
The <em>name</em> references a named chunk.
When tangling, the referenced chunk replaces the reference tag.
When weaving, a reference marker is used.
For example, in RST, this can be replaced with RST <tt class="docutils literal">`reference`_</tt> markup.
Note that the indentation prior to the <tt class="docutils literal">&#64;&lt;</tt> tag is preserved for the tangled chunk that replaces the tag.</blockquote>
<p><tt class="docutils literal">&#64;(</tt><em>Python expression</em><tt class="docutils literal">&#64;)</tt></p>
<blockquote>
The <em>Python expression</em> is evaluated and the result is tangled or woven in place.
A few global variables and modules are available.
These are described in <a class="reference internal" href="#expression-context">Expression Context</a>.</blockquote>
</div>
<div class="section" id="content-tags">
<h2><a class="toc-backref" href="#toc-entry-25">Content Tags</a></h2>
<p>There are three index creation tags that are replaced by content in the woven output.</p>
<p><tt class="docutils literal">&#64;f</tt></p>
<blockquote>
The <tt class="docutils literal">&#64;f</tt> command inserts a file cross reference.
This lists the name of each file created by an <tt class="docutils literal">&#64;o</tt> command, and all of the various chunks that are concatenated to create this file.</blockquote>
<p><tt class="docutils literal">&#64;m</tt></p>
<blockquote>
The <tt class="docutils literal">&#64;m</tt> command inserts a named chunk (&quot;macro&quot;) cross reference.
This lists the name of each chunk created by a <tt class="docutils literal">&#64;d</tt> command, and all of the various chunks that are concatenated to create the complete chunk.</blockquote>
<p><tt class="docutils literal">&#64;u</tt></p>
<blockquote>
The <tt class="docutils literal">&#64;u</tt> command inserts a user identifier cross reference.
This index lists the name of each chunk created by an <tt class="docutils literal">&#64;d</tt> command or <tt class="docutils literal">&#64;|</tt>,
and all of the various chunks that are concatenated to create the complete chunk.</blockquote>
</div>
<div class="section" id="additional-features">
<h2><a class="toc-backref" href="#toc-entry-26">Additional Features</a></h2>
<p><strong>Sequence Numbers</strong>. The named chunks (from both <tt class="docutils literal">&#64;o</tt> and <tt class="docutils literal">&#64;d</tt> commands) are assigned
unique sequence numbers to simplify cross references.</p>
<p><strong>Case Sensitive</strong>. Chunk names and file names are case sensitive.</p>
<p><strong>Abbreviations</strong>. Chunk names can be abbreviated.
A partial name can have a trailing ellipsis (<tt class="docutils literal">...</tt>), this will be resolved to the full name.
The most typical use for this is shown in the following example:</p>
<pre class="literal-block">
Some RST-format documentation.

&#64;o myFile.py
&#64;{
&#64;&lt;imports of the various packages used&#64;&gt;
print(math.pi,time.time())
&#64;}

Some notes on the packages used.

&#64;d imports...
&#64;{
import math,time
&#64;| math time
&#64;}

Some more RST-format documentation.
</pre>
<p>This example shows five chunks.</p>
<ol class="arabic simple">
<li>An anonymous chunk of documentation.</li>
<li>A named chunk that tangles the <tt class="docutils literal">myFile.py</tt> output.
It has a reference to the <tt class="docutils literal">imports of the various packages used</tt> chunk.
Note that the full name of the chunk is essentially a line of  documentation,
traditionally done as a comment line in a non-literate programming environment.</li>
<li>An anonymous chunk of documentation.</li>
<li>A named chunk with an abbreviated name.
The <tt class="docutils literal"><span class="pre">imports...</span></tt> reference matches the defined name <tt class="docutils literal">imports of the various packages used</tt>.
Set off after the <tt class="docutils literal">&#64;|</tt> separator is the list of user-specified identifiers defined in this chunk.</li>
<li>An anonymous chunk of documentation.</li>
</ol>
<p>Note that the first time a name appears (in a reference or definition), it <strong>must</strong> be the full name.
All subsequent uses can be elisions.
Also not that ambiguous elision is an annoying problem when you first start creating a document.</p>
<p><strong>Concatenation</strong>. Named chunks are concatenated from their various pieces.
This allows a named chunk to be broken into several pieces, simplifying the description.
This is most often used when producing  fairly complex output files.</p>
<pre class="literal-block">
An anonymous chunk with some RST documentation.

&#64;o myFile.py
&#64;{
import math, time
&#64;}

Some notes on the packages used.

&#64;o myFile.py
&#64;{
print(math.pi, time.time())
&#64;}

Some more HTML documentation.
</pre>
<p>This example shows five chunks.</p>
<ol class="arabic simple">
<li>An anonymous chunk of documentation.</li>
<li>A named chunk that tangles the <tt class="docutils literal">myFile.py</tt> output.  It has
the first part of the file.  In the woven document
this is marked with <tt class="docutils literal">&quot;=&quot;</tt>.</li>
<li>An anonymous chunk of documentation.</li>
<li>A named chunk that also tangles the <tt class="docutils literal">myFile.py</tt> output. This
chunk's content is appended to the first chunk.  In the woven document
this is marked with <tt class="docutils literal"><span class="pre">&quot;+=&quot;</span></tt>.</li>
<li>An anonymous chunk of documentation.</li>
</ol>
<p><strong>Newline Preservation</strong>. Newline characters are preserved on input.
Because of this the output may appear to have excessive newlines.
In all of the above examples, each named chunk was defined with the following.</p>
<pre class="literal-block">
&#64;{
import math, time
&#64;}
</pre>
<p>This puts a newline character before and after the import line.</p>
</div>
<div class="section" id="controlling-indentation">
<h2><a class="toc-backref" href="#toc-entry-27">Controlling Indentation</a></h2>
<p>We have two choices in indentation:</p>
<ul class="simple">
<li>Context-Sensitive.</li>
<li>Consistent.</li>
</ul>
<p>If we have context-sensitive indentation, then the indentation of a chunk reference  is applied to the entire chunk when expanded in place of the reference.
This makes it simpler to prepare source for languages (like Python) where indentation is important.</p>
<p>There are cases, however, when this is not desirable.
There are some places in Python where we want to create long, triple-quoted strings with indentation that does not follow the prevailing indentations of the surrounding code.</p>
<p>Here's how the context-sensitive indentation works.</p>
<pre class="literal-block">
&#64;o myFile.py
&#64;{
def aFunction(a, b):
    &#64;&lt;body of aFunction&#64;&gt;
&#64;| aFunction &#64;}

&#64;d body...
&#64;{
&quot;&quot;&quot;doc string&quot;&quot;&quot;
return a + b
&#64;}
</pre>
<p>The <tt class="docutils literal">&#64;&lt;body of aFunction&#64;&gt;</tt> command is indented.
The tangled output from this will look like the following.
All of the newline characters are preserved, and the reference to <em>body of the aFunction</em> is indented to match the prevailing indent where it was referenced.
In the following example,  explicit line markers of <tt class="docutils literal">~</tt> are provided to make the blank lines  more obvious.</p>
<pre class="literal-block">
~
~def aFunction(a, b):
~
~    &quot;&quot;&quot;doc string&quot;&quot;&quot;
~    return a + b
~
</pre>
<p>[The <tt class="docutils literal">&#64;|</tt> command shows that this chunk defines the identifier <tt class="docutils literal">aFunction</tt>.]</p>
<p>This leads to the use of &quot;options&quot; for some commands.
This seems to go against the utter simplicity we're cribbing from <strong>noweb</strong>.</p>
<p>The syntax to define a section the will not the indentation context applied looks like this:</p>
<pre class="literal-block">
&#64;d -noindent some chunk name
&#64;{<em>First partial line</em>
<em>More that uses &quot;&quot;&quot;</em>
&#64;}
</pre>
<p>We might reference such a section like this.</p>
<pre class="literal-block">
&#64;d some bigger chunk...
&#64;{<em>code</em>
    &#64;&lt;some chunk name&#64;&gt;
&#64;}
</pre>
<p>The <tt class="docutils literal"><span class="pre">-noindent</span></tt> section will be included by resetting the contextual indentation to zero.
The <em>First partial line</em> line will be output after the four spaces
provided by the <tt class="docutils literal">some bigger chunk</tt> context.</p>
<p>After the first newline, the remaining lines will be at the left margin.</p>
</div>
<div class="section" id="tracking-source-line-numbers">
<h2><a class="toc-backref" href="#toc-entry-28">Tracking Source Line Numbers</a></h2>
<p>Since the tangled output files are -- well -- tangled, it can be difficult to
trace back from a Python error stack to the original line in the <tt class="docutils literal">.w</tt> file that
needs to be fixed.
To facilitate this, there is a two-step operation to get more detailed information
on how tangling worked.</p>
<ol class="arabic simple">
<li>Use the <tt class="docutils literal"><span class="pre">-n</span></tt> command-line option to include line numbers in the tangled output.</li>
<li>Include comment indicators on the <tt class="docutils literal">&#64;o</tt> commands to show what comment syntax is used.</li>
</ol>
<p>The expanded syntax for <tt class="docutils literal">&#64;o</tt> looks like this.</p>
<pre class="literal-block">
&#64;o -start /* -end */ page-layout.css
&#64;{
<em>Some CSS code</em>
&#64;}
</pre>
<p>We've added two options: <tt class="docutils literal"><span class="pre">-start</span> /*</tt> and <tt class="docutils literal"><span class="pre">-end</span> */</tt> to define comment start and end syntax.
This will lead to comments embedded in the tangled output to show source line numbers for every (every!) chunk.</p>
</div>
<div class="section" id="expression-context">
<h2><a class="toc-backref" href="#toc-entry-29">Expression Context</a></h2>
<p>Expressions are evaluated as they are encountered during input parsing.
They produce a <tt class="docutils literal">TextCommand</tt> in the current <tt class="docutils literal">Chunk</tt>.
This means a limited context is available for the Python expression.</p>
<p>The context has the following variables defined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">os.path:</th><td class="field-body">This is the standard <tt class="docutils literal">os.path</tt> module.</td>
</tr>
<tr class="field"><th class="field-name">os.getcwd:</th><td class="field-body">The complete <tt class="docutils literal">os</tt> module is not available. Just this function.</td>
</tr>
<tr class="field"><th class="field-name">datetime:</th><td class="field-body">This is the standard <tt class="docutils literal">datetime</tt> module.</td>
</tr>
<tr class="field"><th class="field-name">time:</th><td class="field-body">The standard <tt class="docutils literal">time</tt> module.</td>
</tr>
<tr class="field"><th class="field-name">platform:</th><td class="field-body">This is the standard <tt class="docutils literal">platform</tt> module.</td>
</tr>
<tr class="field"><th class="field-name">__builtins__:</th><td class="field-body">Most of the built-ins are available, too. Not all.
<tt class="docutils literal">exec()</tt>, <tt class="docutils literal">eval()</tt>, <tt class="docutils literal">open()</tt> and <tt class="docutils literal">__import__()</tt> aren't available.</td>
</tr>
<tr class="field"><th class="field-name">theLocation:</th><td class="field-body">A tuple with the file name, first line number and last line number
for the original expression's location.</td>
</tr>
<tr class="field"><th class="field-name">theWebReader:</th><td class="field-body">The <tt class="docutils literal">WebReader</tt> instance doing the parsing.</td>
</tr>
<tr class="field"><th class="field-name">theFile:</th><td class="field-body">The <tt class="docutils literal">.w</tt> file being processed.</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">thisApplication:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">The name of the running <strong>py-web-lp</strong> application. It may not be pyweb.py,
if some other script is being used.</td>
</tr>
<tr class="field"><th class="field-name">__version__:</th><td class="field-body">The version string in the <strong>py-web-lp</strong> application.</td>
</tr>
</tbody>
</table>
<!-- py-web-tool/src/overview.w -->
</div>
</div>
<div class="section" id="architecture-and-design-overview">
<h1><a class="toc-backref" href="#toc-entry-30">Architecture and Design Overview</a></h1>
<p>This application breaks the overall problem of literate programming into the following sub-problems:</p>
<ol class="arabic simple">
<li>Representation of the WEB document as Chunks and Commands</li>
<li>Reading and parsing the input WEB document.</li>
<li>Weaving a document file.</li>
<li>Tangling the desired program source files.</li>
</ol>
<p>Here's the overall Context Diagram for this application:</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 1060)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    left to right direction
    skinparam actorStyle awesome

    actor &quot;Developer&quot; as Dev
    rectangle PyWeb {
        usecase &quot;Tangle Source&quot; as UC_Tangle
        usecase &quot;Weave Document&quot; as UC_Weave
    }
    rectangle IDE {
        usecase &quot;Create WEB&quot; as UC_Create
        usecase &quot;Run Tests&quot; as UC_Test
        usecase &quot;Build Documentation&quot; as UC_Doc
        usecase &quot;Build Application&quot; as UC_App
    }
    database WEB
    component App
    folder Documentation

    Dev --&gt; UC_Create
    Dev --&gt; UC_Test
    Dev --&gt; UC_Doc
    Dev --&gt; UC_App

    UC_Create --&gt; WEB
    WEB --&gt; UC_Tangle
    WEB --&gt; UC_Weave

    UC_Tangle --&gt; App
    UC_Weave --&gt; Documentation

    UC_Test ..&gt; UC_Tangle
    UC_Doc ..&gt; UC_Weave
    UC_App ..&gt; UC_Tangle

</pre>
</div>
<p>The idea here is a central WEB document contains both the application source code and the documentation that describes the code.
The documentation can present information in an order that's meaningful and helpful
to people.
The tangling operation orders information for the benefit of compilers and tools.</p>
<p>Since this is often part of an Integrated Development Environment (IDE), the container for all of these software components is the developer's desktop.
(We don't need a diagram for that.)</p>
<p>Here's a summary of the application-level components.
These are the most visible libraries and command-line applications:</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 1107)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    component pyweb
    package jinja
    pyweb ..&gt; jinja

    package templates
    pyweb *-- templates
    jinja ..&gt; templates

    component weave
    weave ..&gt; pyweb

    component tangle
    tangle ..&gt; pyweb


</pre>
</div>
<p>The <tt class="docutils literal">weave</tt> and <tt class="docutils literal">tangle</tt> are convenient scripts that import and customize the underlying <tt class="docutils literal">pyweb</tt> application.
We've used the dotted &quot;depends-on&quot; arrow to depict this.
The <tt class="docutils literal">pyweb</tt> application depends on Jinja2 to define the various templates for weaving the output documents.
The <tt class="docutils literal">pyweb</tt> application contains the templates; this is shown with a solid line.</p>
<p>We can modify the templates to alter the look and feel.
The  supplied <tt class="docutils literal">weave.py</tt> script shows how to do this.</p>
<p>In many cases, the final production will multiple steps,  as shown below:</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 1134)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

     database WEB
     component pyweb
     artifact &quot;.rst File&quot; as RST
     component sphinx
     artifact &quot;.html File&quot; as HTML

     WEB --&gt; pyweb
     pyweb --&gt; RST
     RST --&gt; sphinx
     sphinx --&gt; HTML

</pre>
</div>
<p>We can use <strong>pyweb-lp</strong> to create an <tt class="docutils literal">.rst</tt> file with the documentation.
This is then processed by Sphinx to inject a Sphinx theme and necessary CSS to make
responsive web document(s).</p>
<p>This is often automated with a <tt class="docutils literal">Makefile</tt>.</p>
<div class="section" id="overall-structure">
<h2><a class="toc-backref" href="#toc-entry-31">Overall Structure</a></h2>
<p>Generally, the code breaks into three functional areas</p>
<ul class="simple">
<li>The core representation of a WEB.</li>
<li>A parser to read the source WEB.</li>
<li>The emitters to produce woven and tangled output. This includes both weavers and tanglers.</li>
</ul>
<p>We could depict it as follows:</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 1167)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    folder core {
        class Web
        class Chunk
        abstract class Command
        Web *-- &quot;1..*&quot; Chunk
        Chunk *-- &quot;1..*&quot; Command
    }
    folder parser {
        class WebReader
        WebReader --&gt; Web
    }
    folder emitters {
        abstract class Emitter
        class Tangler
        class Weaver
        Emitter &lt;|-- Tangler
        Emitter &lt;|-- Weaver
        Emitter --&gt; Web
    }


</pre>
</div>
<p>We'll look at the core model, first.</p>
</div>
<div class="section" id="core-web-representation">
<h2><a class="toc-backref" href="#toc-entry-32">Core WEB Representation</a></h2>
<p>The basic structure has three layers, as shown in the following diagram:</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 1199)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    class Web &lt;&lt; dataclass &gt;&gt; {
        chunks: list[Chunk]
    }
    class Chunk {
        name: str
        commands: list[Command]
    }
    abstract class Command

    Web *-- &quot;1..*&quot; Chunk
    Chunk *-- &quot;1..*&quot; Command

    class CodeChunk
    Chunk &lt;|-- CodeChunk

    class NamedChunk
    Chunk &lt;|-- NamedChunk

    class OutputChunk
    Chunk &lt;|-- OutputChunk

    class NamedCodeChunk
    Chunk &lt;|-- NamedCodeChunk

    class TextCommand
    Command &lt;|-- TextCommand

    class CodeCommand
    Command &lt;|-- CodeCommand

    class ReferenceCommand
    Command &lt;|-- ReferenceCommand

    class XRefCommand
    Command &lt;|-- XRefCommand

    class FileXRefCommand
    XRefCommand &lt;|-- FileXRefCommand

    class MacroXRefCommand
    XRefCommand &lt;|-- MacroXRefCommand

    class UseridXRefCommand
    XRefCommand &lt;|-- UseridXRefCommand

</pre>
</div>
<p>The source document is transformed into a <tt class="docutils literal">Web</tt>,  which is the overall container.
The source is decomposed into a sequence of <tt class="docutils literal">Chunk</tt> instances.
Each <tt class="docutils literal">Chunk</tt> is a sequence of <tt class="docutils literal">Commands</tt>.</p>
<p><tt class="docutils literal">Chunk</tt> objects and <tt class="docutils literal">Command</tt> objects cannot be nested, leading to delightful simplification.</p>
<p>The overall <tt class="docutils literal">Web</tt> includes both the original sequence of <tt class="docutils literal">Chunk</tt> objects as well as an index for the named <tt class="docutils literal">Chunk</tt> instances.</p>
<p>Note that a named chunk may be created through a number of <tt class="docutils literal">&#64;d</tt> commands.
This means that each named <tt class="docutils literal">Chunk</tt> may be a sequence of definitions sharing a common name.
They are concatenated in order to permit decomposing a single concept into sequentially described pieces.</p>
<p>The various layers of <tt class="docutils literal">Web</tt>, <tt class="docutils literal">Chunk</tt>, and <tt class="docutils literal">Command</tt> each have attributes designed to be usable by a Jinja template when weaving output.
When tangling, however, the only attribute that matters is the text contained in the <tt class="docutils literal">&#64;{</tt> and <tt class="docutils literal">&#64;}</tt> brackets.
This makes tangling somewhat simpler than weaving.</p>
<p>There is a small interaction between a <tt class="docutils literal">Tangler</tt> and each <tt class="docutils literal">Chunk</tt> to work out the indentation. based in the context in which a <tt class="docutils literal">&#64;&lt; name &#64;&gt;</tt> reference occurs.</p>
</div>
<div class="section" id="reading-and-parsing">
<h2><a class="toc-backref" href="#toc-entry-33">Reading and Parsing</a></h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 1267)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    class Web
    class WebReader {
        parse(source) : Web
    }
    WebReader ..&gt; Web
    class Tokenizer
    WebReader ..&gt; Tokenizer

    class OptionParser

    class OptionDef

    OptionParser *-- OptionDef

    WebReader ..&gt; OptionParser

</pre>
</div>
<p>A solution to the reading and parsing problem depends on a convenient  tool for breaking up the input stream and a representation for the chunks of input  and the sequence of commands.
Input decomposition is done with something we might call the <strong>Splitter</strong> design pattern.</p>
<p>The <strong>Splitter</strong> pattern is widely used in text processing, and has a long legacy
in a variety of languages and libraries.
A <strong>Splitter</strong> decomposes a string into a sequence of strings using some split pattern.
There are many variant implementations.
For example, one variant locates only a single occurence (usually the left-most); this is
commonly implemented as a Find or Search string function.
Another variant locates all occurrences of a specific string or character, and discards the matching string or character.</p>
<p>The variation on <strong>Splitter</strong> in this application creates each element in the resulting sequence as either
(1) an instance of the  split regular expression or
(2) the text between split patterns.</p>
<p>We define our splitting pattern with the regular
expression <tt class="docutils literal"><span class="pre">'&#64;.|\n'</span></tt>.  This will split on either of these patterns:</p>
<ul class="simple">
<li><tt class="docutils literal">&#64;</tt> followed by a single character,</li>
<li>or, a newline.</li>
</ul>
<p>For the most part, <tt class="docutils literal">\n</tt> is only text, and as almost no special significance.
The exception is the <tt class="docutils literal">&#64;i</tt> <em>filename</em> command, which ends at the end of the line, making the <tt class="docutils literal">\n</tt> significant syntax in this case.</p>
<p>We could be more specific with the following as a split pattern: <tt class="docutils literal"><span class="pre">'&#64;[doOifmu\|&lt;&gt;(){}\[\]]|\n'</span></tt>.
This would silently ignore unknown commands,  merging them in with the surrounding text.
This would leave the <tt class="docutils literal"><span class="pre">'&#64;&#64;'</span></tt> sequences  completely alone, allowing us to replace <tt class="docutils literal"><span class="pre">'&#64;&#64;'</span></tt> with <tt class="docutils literal">'&#64;'</tt> in every text chunk.
It's not clear this additional level of detail is helpful.</p>
<p>Within the <tt class="docutils literal">&#64;d</tt> and <tt class="docutils literal">&#64;o</tt> commands, there is a name and options.
These follow the syntax rules for Tcl or the shell.
Optional fields are prefaced with <tt class="docutils literal">-</tt>.
All options must come before all positional arguments.
The positional arguments provide the name being defined.
In effect, the name is <tt class="docutils literal">' '.join(args.split(' ')</tt>;
this means multiple adjacent spaces in a name will be collapsed to a single space.</p>
</div>
<div class="section" id="emitters">
<h2><a class="toc-backref" href="#toc-entry-34">Emitters</a></h2>
<p>There are two possible outputs from this application:</p>
<ul class="simple">
<li>A woven document.</li>
<li>One or more tangled source files.</li>
</ul>
<p>The overall structure of the classes is shown in the following diagram.</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 1334)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    class Web

    abstract class Emitter {
        emit(web)
    }

    Emitter ..&gt; Web

    class Weaver
    Emitter &lt;|-- Weaver

    class Tangler
    Emitter &lt;|-- Tangler

    class TanglerMake
    Tangler &lt;|-- TanglerMake

    abstract class ReferenceStyle
    Weaver --&gt; ReferenceStyle

    class Simple
    ReferenceStyle &lt;|-- Simple

    class Transitive
    ReferenceStyle &lt;|-- Transitive

    class Template
    Weaver --&gt; Template

    class &quot;Jinja Macro&quot; as macro
    Template *-- macro

</pre>
</div>
<p>We'll look at the weaving activity first, then the tangling activity.</p>
</div>
<div class="section" id="weaving">
<h2><a class="toc-backref" href="#toc-entry-35">Weaving</a></h2>
<p>The weaving activity depends on having a target document markup language.
There are several approaches to this problem.</p>
<ul class="simple">
<li>We can use a markup language unique to <strong>py-web-lp</strong>.
This would hide the final target markup language. It would mean
that <strong>py-web-lp</strong> would be equivalent to a tool like <strong>Pandoc</strong>,
producing a variety of target markup languages from a single, common source.</li>
<li>We can use any of the existing markup languages (HTML, RST, Markdown, LaTeX, etc.)
expand snippets of markup into author-supplied markup to create the
target woven document.</li>
</ul>
<p>The problem with the first method is defining yet-another-markup-language.
This seems needlessly complex.</p>
<p>The problem with the second method is the source WEB file is a mixture of the following two things:</p>
<ul class="simple">
<li>The background document in some standard markup and</li>
<li>The code elements, which need to be wrapped in some markup.</li>
</ul>
<p>In languages like RST and Markdown, there's a small textual wrapper around code samples.
In languages like HTML, the wrapper can be much more complex.
Also, certain code characters may need to be properly escaped if the code sample happens to contain markup that should <strong>not</strong> be processed, but treated as literal text.
In LaTeX, the wrapper can be quite complex.</p>
<p>The author should not be foreced to repeat the wrappers around each code examples.
This should be delegated to the literate programming tool.
Further, the author should not be narrowly constrained by the markup injected
by the weaving process; the weaver should be extensible to add features.</p>
<p>Currently, this leads to using the <strong>Facade</strong> design pattern.
The weaver is a <strong>Facade</strong> over the Jinja template engine.
The tool provides default templates in RST, HTML, and LaTeX.
These can be replaced; new templates can be added.
The templates used to wrap code sections can be tweaked relatively easily.</p>
<p>This is -- in the long run -- unsustainable.
It means some elements of the document are <strong>not</strong> in the <tt class="docutils literal">.w</tt> WEB file.
See the <a href="#system-message-1"><span class="problematic" id="problematic-1">:ref:`todo`</span></a> section for more on these new commands.</p>
<div class="system-message" id="system-message-1">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 1410); <em><a href="#problematic-1">backlink</a></em></p>
Unknown interpreted text role &quot;ref&quot;.</div>
</div>
<div class="section" id="tangling">
<h2><a class="toc-backref" href="#toc-entry-36">Tangling</a></h2>
<p>The tangling activity produces output files.
In other Literate Programming tools, some care was taken to understand the source code context for tangling, and
provide a correct indentation.
This required a command-line parameter to turn off indentation for languages like Fortran, where identation is not used.</p>
<p>In <strong>py-web-lp</strong>, there are two options:</p>
<ul class="simple">
<li>The default behavior is that the indent of a <tt class="docutils literal">&#64;&lt; name &#64;&gt;</tt> command is used to set the indent of the  material is expanded in place of this reference.
If all <tt class="docutils literal">&#64;&lt;</tt> commands are presented at the left margin, no indentation will be done.
This is helpful simplification, particularly for users of Python, where indentation is significant.</li>
<li>A flag on a <tt class="docutils literal">&#64;d</tt> chunk  can override the indentation rule to force the material to be placed at the left margin in spite of the <cite>&#64;&lt;`</cite> command being indented.</li>
</ul>
<p>Generally, tangling collects the <tt class="docutils literal">&#64;o</tt> chunks and referenced <tt class="docutils literal">&#64;d</tt> chunks into files.
The <tt class="docutils literal">&#64;&lt;</tt> references are expanded.
Other than indentation control, no additional transformation is performed.</p>
</div>
<div class="section" id="application">
<h2><a class="toc-backref" href="#toc-entry-37">Application</a></h2>
<p>The overall application has the following layers to it:</p>
<ul class="simple">
<li>An <tt class="docutils literal">Action</tt> class hierarchy that includes the actions of Load, Tangle, and Weave.</li>
<li>An overall <tt class="docutils literal">Application</tt> class that executes the actions.</li>
<li>A top-level main function parses the command line, creates and configures the actions, and executes the sequence
of actions.</li>
</ul>
<p>The idea is that the Weaver Action should be visible to tools like <a class="reference external" href="https://docs.pyinvoke.org/en/stable/index.html">PyInvoke</a>.
We want <tt class="docutils literal"><span class="pre">Weave(&quot;someFile.w&quot;)</span></tt> to be a sensible task.</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 1449)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    abstract class Action

    class ActionSequence
    Action &lt;|-- ActionSequence
    ActionSequence *-- &quot;2..m&quot; Action

    class LoadAction
    Action &lt;|-- LoadAction

    class WeaveAction
    Action &lt;|-- WeaveAction

    class TangleAction
    Action &lt;|-- TangleAction

    class Application

    Application *-- Action

</pre>
</div>
<p>This shows the essential structure of the top-level classes.</p>
<!-- py-web-tool/src/impl.w -->
</div>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#toc-entry-38">Implementation</a></h1>
<p>The implementation is contained in a single Python module defining the all of the classes and functions, as well as an overall <tt class="docutils literal">main()</tt> function.
The <tt class="docutils literal">main()</tt> function uses these base classes to weave and tangle the output files.</p>
<p>The broad outline of the presentation is as follows:</p>
<ul>
<li><p class="first"><a class="reference internal" href="#base-classes">Base Classes</a> that define a model for the <tt class="docutils literal">.w</tt> file.</p>
<ul class="simple">
<li><a class="reference internal" href="#web-class">Web Class</a> contains the overall Web of Chunks.
A Web is a sequence of <cite>Chunk</cite> objects.
It's also a mapping from chunk name to definition.</li>
<li><a class="reference internal" href="#chunk-class-hierarchy">Chunk Class Hierarchy</a> are pieces of the source document, built into a Web.
A <tt class="docutils literal">Chunk</tt> is a collection of <tt class="docutils literal">Command</tt> instances.
This can be either an anonymous chunk that will be sent directly to the output,
or a named chunks delimited by the structural <tt class="docutils literal">&#64;d</tt> or <tt class="docutils literal">&#64;o</tt> commands.</li>
<li><a class="reference internal" href="#command-class-hierarchy">Command Class Hierarchy</a> are the items within a <tt class="docutils literal">Chunk</tt>.
The text and the inline <tt class="docutils literal">&#64;&lt;name&#64;&gt;</tt> references are the principle command classes.
Additionally, there are some cross reference commands (<tt class="docutils literal">&#64;f</tt>, <tt class="docutils literal">&#64;m</tt>, and <tt class="docutils literal">&#64;u</tt>) that generate content.</li>
</ul>
</li>
<li><p class="first"><a class="reference internal" href="#output-serialization">Output Serialization</a>. The <tt class="docutils literal">Emitter</tt> class hierarchy writes various kinds of files.
These decompose into two subclasses:</p>
<blockquote>
<ul class="simple">
<li>A <tt class="docutils literal">Tangler</tt> creates source code.</li>
<li>A <tt class="docutils literal">Weaver</tt> creates documentation.
The various Jinja-based templates are part of weaving.</li>
</ul>
</blockquote>
</li>
<li><p class="first"><a class="reference internal" href="#input-parsing">Input Parsing</a> covers deserialization from the source <tt class="docutils literal">.w</tt> file
to the base model of <tt class="docutils literal">Web</tt>, <tt class="docutils literal">Chunk</tt>, and <tt class="docutils literal">Command</tt>.</p>
<ul class="simple">
<li><a class="reference internal" href="#the-webreader-class">The WebReader class</a> which parses the Web structure.</li>
<li><a class="reference internal" href="#the-tokenizer-class">The Tokenizer class</a> which tokenizes the raw input.</li>
</ul>
</li>
<li><p class="first">Other application components:</p>
<ul class="simple">
<li><a class="reference internal" href="#error-class">Error Class</a> defines an application-specific exception.
This covers all of the various kinds of problems that might arise.</li>
<li><a class="reference internal" href="#action-class-hierarchy">Action class hierarchy</a> defines things this program does.</li>
<li><a class="reference internal" href="#the-application-class">The Application class</a>. This is an overall class definition that includes
command line parsing, picking an Action, configuring and executing the Action.
It could be a set of related functions, but we've bound them into a class.</li>
<li><a class="reference internal" href="#logging-setup">Logging setup</a>. This includes a simple context manager for logging.</li>
<li><a class="reference internal" href="#the-main-function">The Main Function</a>.</li>
<li><a class="reference internal" href="#pyweb-module-file">pyWeb Module File</a> defines the final module file that contains the application.</li>
</ul>
</li>
</ul>
<p>We'll start with the base classes that define the data model for the source WEB of chunks.</p>
<div class="section" id="base-classes">
<h2><a class="toc-backref" href="#toc-entry-39">Base Classes</a></h2>
<p>Here are some of the base classes that define the structure and meaning of a <tt class="docutils literal">.w</tt> source file.</p>
<p class="rubric" id="base-class-definitions-1">Base Class Definitions (1) =</p>
<pre class="code literal-block">
→ <a class="reference internal" href="#command-class-hierarchy-used-to-describe-individual-commands-in-a-chunk-10">Command class hierarchy -- used to describe individual commands in a chunk (10)</a>

→ <a class="reference internal" href="#chunk-class-hierarchy-used-to-describe-individual-chunks-8">Chunk class hierarchy -- used to describe individual chunks (8)</a>

→ <a class="reference internal" href="#web-class-describes-the-overall-web-of-chunks-3">Web class -- describes the overall &quot;web&quot; of chunks (3)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Base Class Definitions (1)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>The above order is reasonably helpful for Python and minimizes forward references.
The <tt class="docutils literal">Chunk</tt>, <tt class="docutils literal">Command</tt>, and <tt class="docutils literal">Web</tt> instances do have a circular relationship, making a strict ordering a bit complex.</p>
<p>We'll start at the central collection of information, the <tt class="docutils literal">Web</tt> class of objects.</p>
<div class="section" id="web-class">
<h3><a class="toc-backref" href="#toc-entry-40">Web Class</a></h3>
<p>The overall web of chunks is contained in a single instance of the <tt class="docutils literal">Web</tt> class.
This is the principle parameter for the weaving and tangling actions.
Broadly, the functionality of a Web can be separated into the following areas:</p>
<ul class="simple">
<li>It is constructed by a <tt class="docutils literal">WebReader</tt>.</li>
<li>It also supports &quot;enrichment&quot; of the web, once all the <tt class="docutils literal">Chunk</tt> instances are known.
This is a stateful update to the web.
Each <tt class="docutils literal">Chunk</tt> is updated with  references it makes as well as references to it.</li>
<li>It supports <tt class="docutils literal">Chunk</tt> cross-reference methods that traverse this enriched data.
This includes a kind of validity check to be sure that everything is used once
and once only.</li>
</ul>
<p>Fundamentally, a <tt class="docutils literal">Web</tt> is a hybrid list+mapping. It as the following features:</p>
<ul class="simple">
<li>It's a <tt class="docutils literal">Sequence</tt> to retain all <tt class="docutils literal">Chunk</tt> instances in order.</li>
<li>It's a mapping of name-to-Chunk that also offers a moderately sophisticated lookup, including exact match for a <tt class="docutils literal">Chunk</tt> name and an approximate match for an abbreviated name.</li>
</ul>
<p>The <tt class="docutils literal">Web</tt> is built by the parser by loading the sequence of <tt class="docutils literal">Chunk</tt> instances.</p>
<p>Note that the WEB source language has a &quot;mixed content model&quot;.
This means the code chunks have specific tags with names.
The text, on the other hand, is interspersed among the code chunks.
The text belongs to implicit, unnamed text chunks.</p>
<p>A web instance has a number of attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">chunks:</th><td class="field-body">the sequence of <tt class="docutils literal">Chunk</tt> instances as seen in the input file.
To support anonymous chunks, and to assure that the original input document order
is preserved, we keep all chunks in a master sequential list.</td>
</tr>
<tr class="field"><th class="field-name">files:</th><td class="field-body">the <tt class="docutils literal">&#64;o</tt> named <tt class="docutils literal">OutputChunk</tt> chunks.
Each element of this  dictionary is a sequence of chunks that have the same name.
The first is the initial definition (marked with &quot;=&quot;), all others a second definitions
(marked with &quot;+=&quot;).</td>
</tr>
<tr class="field"><th class="field-name">macros:</th><td class="field-body">the <tt class="docutils literal">&#64;d</tt> named <tt class="docutils literal">NamedChunk</tt> chunks.  Each element of this
dictionary is a sequence of chunks that have the same name.  The first is the
initial definition (marked with &quot;=&quot;), all others a second definitions
(marked with &quot;+=&quot;).</td>
</tr>
<tr class="field"><th class="field-name">userids:</th><td class="field-body">the cross reference of chunks referenced by commands in other
chunks.</td>
</tr>
</tbody>
</table>
<p>This relies on the way a <tt class="docutils literal">&#64;dataclass</tt> does post-init processing.
One the raw sequence of <tt class="docutils literal">Chunks</tt> has been presented, some additional processing is done to link each <tt class="docutils literal">Chunk</tt> to the web.
This permits the <tt class="docutils literal">full_name</tt> property to expand abbreviated names to full names,
and, consequently, chunk references.</p>
<p class="rubric" id="imports-2">Imports (2) =</p>
<pre class="code literal-block">
from collections import defaultdict
from collections.abc import Iterator
from dataclasses import dataclass, field
from functools import cache
import logging
from pathlib import Path
from types import SimpleNamespace
from typing import Any, Literal, ClassVar
from weakref import ref, ReferenceType
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Imports (2)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>The class defines one visible element of a <tt class="docutils literal">Web</tt> instance, the <tt class="docutils literal">chunks</tt> list of <tt class="docutils literal">Chunk</tt> instances.
From this list of <tt class="docutils literal">Chunk</tt> objects, the remaining internal objects are built.
These include the following:</p>
<ul class="simple">
<li><tt class="docutils literal">chunk_map</tt> has the mapping of chunk names to list of chunks that provide the definition for the chunk.</li>
<li><tt class="docutils literal">userid_map</tt> has the mapping of user-defined names to the list of chunks that define the name.</li>
<li><tt class="docutils literal">references</tt> is the set of all referenced chunks.</li>
</ul>
<p>Additionally there are attributes to contain a logger, a reference to the WEB file path,
used to evaluate expressions, and a &quot;strict-match&quot; option that can report errors during
name resolution.
Disabling strict-match will allow documents to be tangled that are potentially incomplete.</p>
<p>Generally, a parser will create a list of <tt class="docutils literal">Chunk</tt> objects.
From this, the parser can create the final <tt class="docutils literal">Web</tt>.</p>
<p class="rubric" id="web-class-describes-the-overall-web-of-chunks-3">Web class -- describes the overall &quot;web&quot; of chunks (3) =</p>
<pre class="code literal-block">
&#64;dataclass
class Web:
    chunks: list[&quot;Chunk&quot;]  #: The source sequence of chunks.

    # The ``&#64;d`` chunk names and locations where they're defined.
    chunk_map: dict[str, list[&quot;Chunk&quot;]] = field(init=False)

    # The ``&#64;|`` defined names and chunks with which they're associated.
    userid_map: defaultdict[str, list[&quot;Chunk&quot;]] = field(init=False)

    logger: logging.Logger = field(init=False, default=logging.getLogger(&quot;Web&quot;))

    web_path: Path = field(init=False)  #: Source WEB file; set by ```WebParse``

    strict_match: ClassVar[bool] = True  #: Report ... names without a definition.
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Web class -- describes the overall &quot;web&quot; of chunks (3)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-1">Base Class Definitions (1)</a>.</div>
<p>The  <tt class="docutils literal">__post_init__()</tt> special method populates the detailed structure of the WEB document.
There are several passes through the WEB to digest the data:</p>
<ol class="arabic simple">
<li>Set all <tt class="docutils literal">Chunk</tt> and <tt class="docutils literal">Command</tt> back references to the <tt class="docutils literal">Web</tt> container.
This is required so a <tt class="docutils literal">Chunk</tt> with a <tt class="docutils literal">ReferenceCommand</tt> instance can properly
refer to a chunk elsewhere in the <tt class="docutils literal">Web</tt> container.
There are all weak references to faciliate garbgage collection.</li>
<li>Locate the unabbreviated names in chunks and references to chunks.
Names can found in two places:
the <tt class="docutils literal">&#64;d</tt> command provides a name, and
a <tt class="docutils literal">&#64;&lt;name&#64;&gt;</tt> command provides a reference to a name.
The unabbreviated names define the structure.
Unambiguous abbreviations can be used freely, since full names are located first.</li>
<li>Accumulate chunk lists, output lists, and name definition lists.
This pass does two things.
First any user-defined name after a <tt class="docutils literal">&#64;|</tt> command is accumulated.
Second, any abbreviated name is resolved to the full name,
and the complete mapping from chunk name to a sequence of defining chunks is completed.</li>
<li>Set the <tt class="docutils literal">referencedBy</tt> attribute of a <tt class="docutils literal">Chunk</tt> instance with all of the
commands that point to it.
The idea here is that a top-level <tt class="docutils literal">Chunk</tt> instance may have references to other <tt class="docutils literal">Chunk</tt> isntances.
This forms a kind of tree.
Any given low-level <tt class="docutils literal">Chunk</tt> object is named by a sequence of parent <tt class="docutils literal">Chunk</tt> objects.</li>
</ol>
<p>Once the initialization is complete, the <tt class="docutils literal">Web</tt> instance can be woven or tangled.</p>
<p class="rubric" id="web-class-describes-the-overall-web-of-chunks-4">Web class -- describes the overall &quot;web&quot; of chunks (4) +=</p>
<pre class="code literal-block">
    def __post_init__(self) -&gt; None:
        &quot;&quot;&quot;
        Populate weak references throughout the web to make full_name properties work.
        Then. Locate all macro definitions and userid references.
        &quot;&quot;&quot;
        # Pass 1 -- set all Chunk and Command back references.
        for c in self.chunks:
            c.web = ref(self)
            for cmd in c.commands:
                cmd.web = ref(self)

        # Named Chunks = Union of macro_iter and file_iter
        named_chunks = list(filter(lambda c: c.name is not None, self.chunks))

        # Pass 2 -- locate the unabbreviated names in chunks and references to chunks.
        self.chunk_map = {}
        for seq, c in enumerate(named_chunks, start=1):
            c.seq = seq
            if not c.path:
                # Use ``&#64;d name`` chunks (reject ``&#64;o`` and text)
                if c.name and not c.name.endswith('...'):
                    self.logger.debug(f&quot;__post_init__ 2a {c.name=!r}&quot;)
                    self.chunk_map.setdefault(c.name, [])
            for cmd in c.commands:
                # Find ``&#64;&lt; name &#64;&gt;`` in ``&#64;d name`` chunks or ``&#64;o`` chunks
                if cmd.has_name:
                    if not cast(ReferenceCommand, cmd).name.endswith('...'):
                        self.logger.debug(f&quot;__post_init__ 2b {cast(ReferenceCommand, cmd).name=!r}&quot;)
                        self.chunk_map.setdefault(cast(ReferenceCommand, cmd).name, [])

        # Pass 3 -- accumulate chunk lists, output lists, and name definition lists.
        self.userid_map = defaultdict(list)
        for c in named_chunks:
            for name in c.def_names:
                self.userid_map[name].append(c)
            if not c.path:
                # Named ``&#64;d name`` chunks
                if full_name := c.full_name:
                    c.initial = len(self.chunk_map[full_name]) == 0
                    self.chunk_map[full_name].append(c)
                    self.logger.debug(f&quot;__post_init__ 3 {c.name=!r} -&gt; {c.full_name=!r}&quot;)
            else:
                # Output ``&#64;o`` and anonymous chunks.
                # Assume all &#64;o chunks are unique. If they're not, they overwrite each other.
                # Also, there's not ``full_name`` for these chunks.
                c.initial = True

            # TODO: Accumulate all chunks that contribute to a named file...

        # Pass 4 -- set referencedBy a command in a chunk.
        # ONLY set this in references embedded in named chunk or output chunk.
        # In a generic Chunk (which is text) there's no anchor to refer to.
        # NOTE: Assume single references *only*
        # We should raise an exception when updating a non-None referencedBy value.
        # Or incrementing ref_chunk.references &gt; 1.
        for c in named_chunks:
            for cmd in c.commands:
                if cmd.has_name:
                    ref_to_list = self.resolve_chunk(cast(ReferenceCommand, cmd).name)
                    for ref_chunk in ref_to_list:
                        ref_chunk.referencedBy = c
                        ref_chunk.references += 1
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Web class -- describes the overall &quot;web&quot; of chunks (4)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-1">Base Class Definitions (1)</a>.</div>
<p>The representation of a <tt class="docutils literal">Web</tt> instance is a sequence of <tt class="docutils literal">Chunk</tt> instances.
This can be long and difficult to read.
It is, however, complete, and can be  used to build instances of <tt class="docutils literal">Web</tt> objects from a variety of sources.</p>
<p class="rubric" id="web-class-describes-the-overall-web-of-chunks-5">Web class -- describes the overall &quot;web&quot; of chunks (5) +=</p>
<pre class="code literal-block">
    def __repr__(self) -&gt; str:
        NL = &quot;,\n&quot;
        return (
            f&quot;{self.__class__.__name__}(&quot;
            f&quot;{NL.join(repr(c) for c in self.chunks)}&quot;
            f&quot;)&quot;
        )
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Web class -- describes the overall &quot;web&quot; of chunks (5)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-1">Base Class Definitions (1)</a>.</div>
<p>Name and Chunk resolution are similar.
Name resolution provides only the expanded name.
Chunk resolution provides the list of chunks that define a name.
Chunk resolution expands on the basic features of Name resolution.</p>
<p>The complex <tt class="docutils literal"><span class="pre">target.endswith('...')</span></tt> processing only happens once during <tt class="docutils literal">__post_init__()</tt> processing.
After the initalization is complete, all <tt class="docutils literal">ReferenceCommand</tt> objects will have a <tt class="docutils literal">full_name</tt> attribute that avoids the complication of resolving a name with a <tt class="docutils literal">...</tt> ellipsis.</p>
<p class="rubric" id="web-class-describes-the-overall-web-of-chunks-6">Web class -- describes the overall &quot;web&quot; of chunks (6) +=</p>
<pre class="code literal-block">
    def resolve_name(self, target: str) -&gt; str:
        &quot;&quot;&quot;Map short names to full names, if possible.&quot;&quot;&quot;
        if target in self.chunk_map:
            # self.logger.debug(f&quot;resolve_name {target=} in self.chunk_map&quot;)
            return target
        elif target.endswith('...'):
            # The ... is equivalent to regular expression .*
            matches = list(
                c_name
                for c_name in self.chunk_map
                if c_name.startswith(target[:-3])
            )
            # self.logger.debug(f&quot;resolve_name {target=} {matches=} in self.chunk_map&quot;)
            match matches:
                case []:
                    if self.strict_match:
                        raise Error(f&quot;No full name for {target!r}&quot;)
                    else:
                        self.logger.warning(f&quot;resolve_name {target=} unknown&quot;)
                        self.chunk_map[target] = []
                    return target
                case [head]:
                    return head
                case [head, *tail]:
                    message = f&quot;Ambiguous abbreviation {target!r}, matches {[head] + tail!r}&quot;
                    raise Error(message)
            raise RuntimeError(f&quot;unexpected {matches}&quot;)
        else:
            self.logger.warning(f&quot;resolve_name {target=} unknown&quot;)
            self.chunk_map[target] = []
            return target

    def resolve_chunk(self, target: str) -&gt; list[&quot;Chunk&quot;]:
        &quot;&quot;&quot;Map name (short or full) to the defining sequence of chunks.&quot;&quot;&quot;
        full_name = self.resolve_name(target)
        chunk_list = self.chunk_map[full_name]
        self.logger.debug(f&quot;resolve_chunk {target=!r} -&gt; {full_name=!r} -&gt; {chunk_list=}&quot;)
        return chunk_list
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Web class -- describes the overall &quot;web&quot; of chunks (6)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-1">Base Class Definitions (1)</a>.</div>
<p>The point of the <tt class="docutils literal">Web</tt> object is to be able to manage a variety of  structures.
These iterator methods and properties provide the list of <tt class="docutils literal">&#64;o</tt> chunks, <tt class="docutils literal">&#64;d</tt> chunks, and the usernames after <tt class="docutils literal">&#64;|</tt> in a chunk.</p>
<p>Additionally, we can confirm the overall structure by asserting that each <tt class="docutils literal">&#64;d</tt> name has one reference.
A name with no references indicates an omission, a name with multiple references suggests a spelling or ellipsis problem.</p>
<p class="rubric" id="web-class-describes-the-overall-web-of-chunks-7">Web class -- describes the overall &quot;web&quot; of chunks (7) +=</p>
<pre class="code literal-block">
    def file_iter(self) -&gt; Iterator[OutputChunk]:
        return (cast(OutputChunk, c) for c in self.chunks if c.type_is(&quot;OutputChunk&quot;))

    def macro_iter(self) -&gt; Iterator[NamedChunk]:
        return (cast(NamedChunk, c) for c in self.chunks if c.type_is(&quot;NamedChunk&quot;))

    def userid_iter(self) -&gt; Iterator[SimpleNamespace]:
        yield from (SimpleNamespace(def_name=n, chunk=c) for c in self.file_iter() for n in c.def_names)
        yield from (SimpleNamespace(def_name=n, chunk=c) for c in self.macro_iter() for n in c.def_names)

    &#64;property
    def files(self) -&gt; list[&quot;OutputChunk&quot;]:
        return list(self.file_iter())

    &#64;property
    def macros(self) -&gt; list[SimpleNamespace]:
        &quot;&quot;&quot;
        The chunk_map has the list of Chunks that comprise a macro definition.
        We separate those to make it slightly easier to format the first definition.
        &quot;&quot;&quot;
        first_list = (
            (self.chunk_map[name][0], self.chunk_map[name])
            for name in sorted(self.chunk_map)
            if self.chunk_map[name]
        )
        macro_list = list(
            SimpleNamespace(name=first_def.name, full_name=first_def.full_name, seq=first_def.seq, def_list=def_list)
            for first_def, def_list in first_list
        )
        # self.logger.debug(f&quot;macros: {defs}&quot;)
        return macro_list

    &#64;property
    def userids(self) -&gt; list[SimpleNamespace]:
        userid_list = list(
            SimpleNamespace(userid=userid, ref_list=self.userid_map[userid])
            for userid in sorted(self.userid_map)
        )
        # self.logger.debug(f&quot;userids: {userid_list}&quot;)
        return userid_list

    def no_reference(self) -&gt; list[Chunk]:
        return list(filter(lambda c: c.name and not c.path and c.references == 0, self.chunks))

    def multi_reference(self) -&gt; list[Chunk]:
        return list(filter(lambda c: c.name and not c.path and c.references &gt; 1, self.chunks))
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Web class -- describes the overall &quot;web&quot; of chunks (7)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-1">Base Class Definitions (1)</a>.</div>
<p>A <tt class="docutils literal">Web</tt> instance is built by a <tt class="docutils literal">WebReader</tt>.
It's used by an <tt class="docutils literal">Emitter</tt>, including a <tt class="docutils literal">Weaver</tt> as well as a <tt class="docutils literal">Tangler</tt>.
A <tt class="docutils literal">Web</tt> is composed of individual <tt class="docutils literal">Chunk</tt> instances.</p>
</div>
<div class="section" id="chunk-class-hierarchy">
<h3><a class="toc-backref" href="#toc-entry-41">Chunk Class Hierarchy</a></h3>
<p>A <tt class="docutils literal">Chunk</tt> is a piece of the input file.
It is a collection of <tt class="docutils literal">Command</tt> instances.
A <tt class="docutils literal">Chunk</tt> can be woven or tangled to create output.</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 1979)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    class Chunk {
        name: str
        seq: int
        commands: list[Command]
        options: list[str]
        def_names: list[str]
        initial: bool
    }

    class OutputChunk
    Chunk &lt;|-- OutputChunk

    class NamedChunk
    Chunk &lt;|-- NamedChunk

</pre>
</div>
<p>These subclasss reflect three kinds of content in the WEB source document:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><tt class="docutils literal">Chunk</tt> is the anonymous text context.</dt>
<dd>Text in the body generally becomes a <tt class="docutils literal">TextCommand</tt>.
Also, the various XREF commands (<tt class="docutils literal">&#64;m</tt>, <tt class="docutils literal">&#64;f</tt>, <tt class="docutils literal">&#64;u</tt>) can <em>only</em> appear here.
In principle, a <tt class="docutils literal">&#64;&lt; reference &#64;&gt;</tt> can appear in text.
It must name a <tt class="docutils literal">&#64;d name <span class="pre">&#64;[...&#64;]</span></tt> NamedDocumentChunk, which is expanded in place, not linked.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal">OutputChunk</tt> is the <tt class="docutils literal">&#64;o</tt> context.</dt>
<dd>Text in the body becomes a <tt class="docutils literal">CodeCommand</tt>.
Any <tt class="docutils literal">&#64;&lt; reference &#64;&gt;</tt> will be expanded when tangling, but become a link when weaving.
This defines an output file.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal">NamedChunk</tt> is the <tt class="docutils literal">&#64;d</tt> context.</dt>
<dd>Text in the body becomes a <tt class="docutils literal">CodeCommand</tt>.
Any <tt class="docutils literal">&#64;&lt; reference &#64;&gt;</tt> will be expanded when tangling, but become a link when weaving.</dd>
</dl>
</li>
</ul>
<p>Most of the attributes are pushed up to the superclass.
This makes type checking the complex WEB tree simpler.</p>
<p>The attributes are visible to the Jinja templates.
In particular the sequence number, <tt class="docutils literal">seq</tt>,  and the initial definition indicator, <tt class="docutils literal">initial</tt>, are often used to customize presentation of the woven content.</p>
<p>A <tt class="docutils literal">type_is()</tt> method is used to discern the various subtypes.
This slightly simplifies the work done by a template.
It's not easy to rely on proper inheritance because the templates are implemented in a separate language with their own processing rules.</p>
<p class="rubric" id="chunk-class-hierarchy-used-to-describe-individual-chunks-8">Chunk class hierarchy -- used to describe individual chunks (8) =</p>
<pre class="code literal-block">
&#64;dataclass
class Chunk:
    &quot;&quot;&quot;Superclass for OutputChunk, NamedChunk, NamedDocumentChunk.
    &quot;&quot;&quot;
    #: Short name of the chunk.
    name: str | None = None

    #: Unique sequence number of chunk in the WEB.
    seq: int | None = None

    #: Sequence of commands inside this chunk.
    commands: list[&quot;Command&quot;] = field(default_factory=list)

    #: Parsed options for &#64;d and &#64;o chunks.
    options: list[str] = field(default_factory=list)

    #: Names defined after ``&#64;|`` in this chunk.
    def_names: list[str] = field(default_factory=list)

    #: Is this the first use of a given Chunk name?
    initial: bool = False

    #: If injecting location details whenm tangling, this is the comment prefix.
    comment_start: str | None = None

    #: If injecting location details, this is the comment suffix.
    comment_end: str | None = None

    #: Count of references to this Chunk.
    references: int = field(init=False, default=0)

    #: The immediate reference to this chunk.
    referencedBy: &quot;Chunk | None&quot; = field(init=False, default=None)

    #: Weak reference to the ``Web`` containing this ``Chunk``.
    web: ReferenceType[&quot;Web&quot;] = field(init=False, repr=False)

    #: Logger for any chunk-specific messages.
    logger: logging.Logger = field(init=False, default=logging.getLogger(&quot;Chunk&quot;))

    &#64;property
    def full_name(self) -&gt; str | None:
        if self.name:
            return cast(Web, self.web()).resolve_name(self.name)
        else:
            return None

    &#64;property
    def path(self) -&gt; Path | None:
        return None

    &#64;property
    def location(self) -&gt; tuple[str, int]:
        return self.commands[0].location

    &#64;property
    def transitive_referencedBy(self) -&gt; list[&quot;Chunk&quot;]:
        if self.referencedBy:
            return [self.referencedBy] + self.referencedBy.transitive_referencedBy
        else:
            return []

    def add_text(self, text: str, location: tuple[str, int]) -&gt; &quot;Chunk&quot;:
        if self.commands and self.commands[-1].typeid.TextCommand:
            cast(HasText, self.commands[-1]).text += text
        else:
            # Empty list OR previous command was not ``TextCommand``
            self.commands.append(TextCommand(text, location))
        return self

    def type_is(self, name: str) -&gt; bool:
        &quot;&quot;&quot;
        Instead of type name matching, we could check for these features:
        - has_code() (i.e., NamedChunk and OutputChunk)
        - has_text() (i.e., Chunk and NamedDocumentChunk)
        This is for template rendering, where proper Liskov
        Substitution is irrelevant.
        &quot;&quot;&quot;
        return self.__class__.__name__ == name
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Chunk class hierarchy -- used to describe individual chunks (8)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-1">Base Class Definitions (1)</a>.</div>
<p>The subclasses do little more than partition thd Chunks in a way
that permits customization in the template rendering process.</p>
<p>An <tt class="docutils literal">OutputChunk</tt> is distinguished from a <tt class="docutils literal">NamedChunk</tt> by having
a <tt class="docutils literal">path</tt> property and not having a <tt class="docutils literal">full_name</tt> property.</p>
<p class="rubric" id="chunk-class-hierarchy-used-to-describe-individual-chunks-9">Chunk class hierarchy -- used to describe individual chunks (9) +=</p>
<pre class="code literal-block">
class OutputChunk(Chunk):
    &quot;&quot;&quot;An output file.&quot;&quot;&quot;
    &#64;property
    def path(self) -&gt; Path | None:
        if self.name:
            return Path(self.name)
        else:
            return None

    &#64;property
    def full_name(self) -&gt; str | None:
        return None

    def add_text(self, text: str, location: tuple[str, int]) -&gt; Chunk:
        if self.commands and self.commands[-1].typeid.CodeCommand:
            cast(HasText, self.commands[-1]).text += text
        else:
            # Empty list OR previous command was not ``CodeCommand``
            self.commands.append(CodeCommand(text, location))
        return self

class NamedChunk(Chunk):
    &quot;&quot;&quot;A defined name with code.&quot;&quot;&quot;
    def add_text(self, text: str, location: tuple[str, int]) -&gt; Chunk:
        if self.commands and self.commands[-1].typeid.CodeCommand:
            cast(HasText, self.commands[-1]).text += text
        else:
            # Empty list OR previous command was not ``CodeCommand``
            self.commands.append(CodeCommand(text, location))
        return self

class NamedChunk_Noindent(Chunk):
    &quot;&quot;&quot;A defined name with code and the -noIndent option.&quot;&quot;&quot;
    pass

class NamedDocumentChunk(Chunk):
    &quot;&quot;&quot;A defined name with text.&quot;&quot;&quot;
    pass
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Chunk class hierarchy -- used to describe individual chunks (9)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-1">Base Class Definitions (1)</a>.</div>
</div>
<div class="section" id="command-class-hierarchy">
<h3><a class="toc-backref" href="#toc-entry-42">Command Class Hierarchy</a></h3>
<p>A <tt class="docutils literal">Chunk</tt> is a sequence of <tt class="docutils literal">Command</tt> instances.
For the generic <tt class="docutils literal">Chunk</tt> superclass, the commands are -- mostly -- the <tt class="docutils literal">TextCommand</tt> subclass of <tt class="docutils literal">Command</tt>; these are blocks of text.
A <tt class="docutils literal">Chunk</tt> may also include some <tt class="docutils literal">XRefCommand</tt> instances which expand to cross-reference material for an index.</p>
<p>For the <tt class="docutils literal">CodeChunk</tt> and <tt class="docutils literal">NamedChunk</tt> subclasses, the commands are <tt class="docutils literal">CodeCommand</tt> instances intermixed with <tt class="docutils literal">ReferenceCommand</tt> instances.
A <tt class="docutils literal">CodeCommand</tt> has a wrapper applied to it when weaving.
Additionally, it will be tangled into the output.
A <tt class="docutils literal">ReferenceCommand</tt> becomes a link when weaving, and expands to its full body when being tangled.</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 2193)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    class Chunk {
        name: str
        commands: list[Command]
    }
    abstract class Command {
        {static} has_name: bool
        {static} has_text: bool
        {static} typeid: TypeId
        text: str
        tangle(Tangler, Target)
    }

    Chunk *-- &quot;1..*&quot; Command

    abstract HasText
    Command &lt;|-- HasText

    class TextCommand
    HasText &lt;|-- TextCommand

    class CodeCommand
    HasText &lt;|-- CodeCommand

    class ReferenceCommand
    Command &lt;|-- ReferenceCommand

    abstract XRefCommand
    Command &lt;|-- XRefCommand

    class FileXRefCommand
    XRefCommand &lt;|-- FileXRefCommand

    class MacroXRefCommand
    XRefCommand &lt;|-- MacroXRefCommand

    class UseridXRefCommand
    XRefCommand &lt;|-- UseridXRefCommand

    class TypeId {
        __getattr__(str) : bool
    }

    Command -- TypeId

</pre>
</div>
<p>Each of these variants has the possibility of distinct processing when weaving the final document.
The type information must be  visibile to the Jinja template processing.
This is done through an instance of the <tt class="docutils literal">TypeId</tt> class attached to each of these classes.</p>
<p>The input stream is broken into individual commands, based on the various <tt class="docutils literal">&#64;</tt><em>x</em> strings in the file.
There are several subclasses of <tt class="docutils literal">Command</tt>, each used to describe a different command or block of text in the input.</p>
<p>All instances of the <tt class="docutils literal">Command</tt> class are created by the <tt class="docutils literal">WebReader</tt> instance.
In this case, a <tt class="docutils literal">WebReader</tt> can be thought of as a factory for <tt class="docutils literal">Command</tt> instances.
Each <tt class="docutils literal">Command</tt> instance is appended to the sequence of commands that
belong to a <tt class="docutils literal">Chunk</tt>.</p>
<p>This model permits two kinds of serialization:</p>
<ul class="simple">
<li>Weaving a document from the WEB source file. This uses the various attributes
of the various subclasses.</li>
<li>Tangling target documents with code. This relies on a <tt class="docutils literal">tangle()</tt> method
in each subclass.</li>
</ul>
<p>We'll address the run-time type identification first,
the the definitions of the various <tt class="docutils literal">Command</tt> subclasses.</p>
<p class="rubric" id="command-class-hierarchy-used-to-describe-individual-commands-in-a-chunk-10">Command class hierarchy -- used to describe individual commands in a chunk (10) =</p>
<pre class="code literal-block">
→ <a class="reference internal" href="#the-typeid-class-to-help-the-template-engine-12">The TypeId Class -- to help the template engine (12)</a>

→ <a class="reference internal" href="#the-command-abstract-base-class-13">The Command Abstract Base Class (13)</a>

→ <a class="reference internal" href="#the-hastext-type-hint-used-instead-of-another-abstract-class-14">The HasText Type Hint -- used instead of another abstract class (14)</a>

→ <a class="reference internal" href="#the-textcommand-class-15">The TextCommand Class (15)</a>
→ <a class="reference internal" href="#the-codecommand-class-16">The CodeCommand Class (16)</a>
→ <a class="reference internal" href="#the-referencecommand-class-17">The ReferenceCommand Class (17)</a>
→ <a class="reference internal" href="#the-xrefcommand-subclasses-files-macros-and-user-names-18">The XrefCommand Subclasses -- files, macros, and user names (18)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Command class hierarchy -- used to describe individual commands in a chunk (10)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-1">Base Class Definitions (1)</a>.</div>
<div class="section" id="the-typeid-class">
<h4><a class="toc-backref" href="#toc-entry-43">The TypeId Class</a></h4>
<p>The <tt class="docutils literal">TypeId</tt> class provides run-time type identification to the Jinja templates.
The idea is <tt class="docutils literal">object.typeid.AClass</tt> is  equivalent to <tt class="docutils literal">isinstance(object, pyweb.AClass)</tt>.
It has simpler syntax and works better with Jinja templates.
It helps sort out the various nodes of the AST built from the source WEB document.</p>
<p>There are three parts to the <tt class="docutils literal">TypeId</tt> implementation:</p>
<ul class="simple">
<li>A <tt class="docutils literal">TypeId</tt> class definition to handle the attribute access.
A reference to <tt class="docutils literal">object.typeid.Name</tt> evaluates <tt class="docutils literal">__getattr__(object, 'Name')</tt>.</li>
<li>A metaclass definition, <tt class="docutils literal">TypeIdMeta</tt>, to inject the new <tt class="docutils literal">typeid</tt> attribute into each class.</li>
<li>The normal class initialization process, which evaluates <tt class="docutils literal">__set_name__()</tt>
for each attribute of a class that defines the method.
This provides the containing class to the <tt class="docutils literal">TypeId</tt> instance.</li>
</ul>
<p>The idea of run-time type identification is -- in a way -- a failure to properly
define the classes to follow the Liskov Substitution design principle.
This becomes awkwardly complex in the Jinja templates, because the templates exist
outside the class hierarchy.
We rely on the <tt class="docutils literal">typeid</tt> to map classes to macros appropriate to the class.</p>
<p class="rubric" id="imports-11">Imports (11) +=</p>
<pre class="code literal-block">
from typing import TypeVar, Generic
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Imports (11)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p class="rubric" id="the-typeid-class-to-help-the-template-engine-12">The TypeId Class -- to help the template engine (12) =</p>
<pre class="code literal-block">
class TypeId:
    &quot;&quot;&quot;
    This makes a given class name into an attribute with a
    True value. Any other attribute reference will return False.

    &gt;&gt;&gt; class A:
    ...     typeid = TypeId()
    &gt;&gt;&gt; a = A()
    &gt;&gt;&gt; a.typeid.A
    True
    &gt;&gt;&gt; a.typeid.B
    False
    &quot;&quot;&quot;
    def __set_name__(self, owner: type, name: str) -&gt; &quot;TypeId&quot;:
        &quot;&quot;&quot;Invoked automatically during object construction.&quot;&quot;&quot;
        self.my_class = owner
        return self

    def __getattr__(self, item: str) -&gt; bool:
        return self.my_class.__name__ == item

from collections.abc import Mapping

class TypeIdMeta(type):
    &quot;&quot;&quot;Inject the ``typeid`` attribute into a class definition.&quot;&quot;&quot;
    &#64;classmethod
    def __prepare__(metacls, name: str, bases: tuple[type, ...], **kwds: Any) -&gt; Mapping[str, object]:  # type: ignore[override]
        return {&quot;typeid&quot;: TypeId()}
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>The TypeId Class -- to help the template engine (12)</em>.
Used by     → <a class="reference internal" href="#command-class-hierarchy-used-to-describe-individual-commands-in-a-chunk-10">Command class hierarchy -- used to describe individual commands in a chunk (10)</a>.</div>
<p>The <tt class="docutils literal">TypeIdMeta</tt> metaclass sets the <tt class="docutils literal">typeid</tt> attribute of each class defined by this metaclass.
The ordinary class preparation automatically invokes the <tt class="docutils literal">__set_name__()</tt> special method to provide details to the attribute.</p>
<p>Once set, any reference to <tt class="docutils literal">c.typeid.name</tt> will be evaluated as <tt class="docutils literal">__getattr__(c, 'name')</tt>.
This permits the typeid to compare the name provided by <tt class="docutils literal">__set_name__()</tt> with the name
being inquired about.</p>
</div>
<div class="section" id="the-command-class">
<h4><a class="toc-backref" href="#toc-entry-44">The Command Class</a></h4>
<p>The <tt class="docutils literal">Command</tt> class is abstract, and describes most of the features of the various subclasses.</p>
<p class="rubric" id="the-command-abstract-base-class-13">The Command Abstract Base Class (13) =</p>
<pre class="code literal-block">
class Command(metaclass=TypeIdMeta):
    typeid: TypeId
    has_name = False
    has_text = False

    def __init__(self, location: tuple[str, int]) -&gt; None:
        self.location = location  #: The (filename, line number)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.web: ReferenceType[&quot;Web&quot;]
        self.text: str  #: The body of this command

    def __repr__(self) -&gt; str:
        return f&quot;{self.__class__.__name__}(location={self.location!r})&quot;

    &#64;abc.abstractmethod
    def tangle(self, aTangler: &quot;Tangler&quot;, target: TextIO) -&gt; None:
        ...
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>The Command Abstract Base Class (13)</em>.
Used by     → <a class="reference internal" href="#command-class-hierarchy-used-to-describe-individual-commands-in-a-chunk-10">Command class hierarchy -- used to describe individual commands in a chunk (10)</a>.</div>
</div>
<div class="section" id="the-hastext-classes">
<h4><a class="toc-backref" href="#toc-entry-45">The HasText Classes</a></h4>
<p>An Annotation summarizes some of the subclass relationships.</p>
<p class="rubric" id="the-hastext-type-hint-used-instead-of-another-abstract-class-14">The HasText Type Hint -- used instead of another abstract class (14) =</p>
<pre class="code literal-block">
type HasText = &quot;CodeCommand | TextCommand&quot;
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>The HasText Type Hint -- used instead of another abstract class (14)</em>.
Used by     → <a class="reference internal" href="#command-class-hierarchy-used-to-describe-individual-commands-in-a-chunk-10">Command class hierarchy -- used to describe individual commands in a chunk (10)</a>.</div>
<p>We don't formalize this as proper subclass definitions.
We probably should, but it doesn't seem to add any clarity.</p>
</div>
<div class="section" id="the-textcommand-class">
<h4><a class="toc-backref" href="#toc-entry-46">The TextCommand Class</a></h4>
<p>The <tt class="docutils literal">TextCommand</tt> class describes all of the text <strong>outside</strong> the <tt class="docutils literal">&#64;d</tt> and <tt class="docutils literal">&#64;o</tt> chunks.
These are <strong>not</strong> tangled, and any attempt to do this raises an exception .</p>
<p class="rubric" id="the-textcommand-class-15">The TextCommand Class (15) =</p>
<pre class="code literal-block">
class TextCommand(Command):
    &quot;&quot;&quot;Text outside any other command.&quot;&quot;&quot;
    has_text = True

    def __init__(self, text: str, location: tuple[str, int]) -&gt; None:
        super().__init__(location)
        self.text = text  #: The text

    def tangle(self, aTangler: &quot;Tangler&quot;, target: TextIO) -&gt; None:
        message = f&quot;attempt to tangle a text block {self.location} {shorten(self.text, 32)!r}&quot;
        self.logger.error(message)
        raise Error(message)

    def __repr__(self) -&gt; str:
        return f&quot;{self.__class__.__name__}(text={self.text!r}, location={self.location!r})&quot;
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>The TextCommand Class (15)</em>.
Used by     → <a class="reference internal" href="#command-class-hierarchy-used-to-describe-individual-commands-in-a-chunk-10">Command class hierarchy -- used to describe individual commands in a chunk (10)</a>.</div>
</div>
<div class="section" id="the-codecommand-class">
<h4><a class="toc-backref" href="#toc-entry-47">The CodeCommand Class</a></h4>
<p>The <tt class="docutils literal">CodeCommand</tt> class describes the text <strong>inside</strong> the <tt class="docutils literal">&#64;d</tt> and <tt class="docutils literal">&#64;o</tt>  chunks.
These are tangled without change.</p>
<p class="rubric" id="the-codecommand-class-16">The CodeCommand Class (16) =</p>
<pre class="code literal-block">
class CodeCommand(Command):
    &quot;&quot;&quot;Code inside a ``&#64;o``, or ``&#64;d`` command.&quot;&quot;&quot;
    has_text = True

    def __init__(self, text: str, location: tuple[str, int]) -&gt; None:
        super().__init__(location)
        self.text = text  #: The text

    def tangle(self, aTangler: &quot;Tangler&quot;, target: TextIO) -&gt; None:
        self.logger.debug(f&quot;tangle {self.text=!r}&quot;)
        aTangler.codeBlock(target, self.text)

    def __repr__(self) -&gt; str:
        return f&quot;{self.__class__.__name__}(text={self.text!r}, location={self.location!r})&quot;
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>The CodeCommand Class (16)</em>.
Used by     → <a class="reference internal" href="#command-class-hierarchy-used-to-describe-individual-commands-in-a-chunk-10">Command class hierarchy -- used to describe individual commands in a chunk (10)</a>.</div>
</div>
<div class="section" id="the-referencecommand-class">
<h4><a class="toc-backref" href="#toc-entry-48">The ReferenceCommand Class</a></h4>
<p>The <tt class="docutils literal">ReferenceCommand</tt> class describes a <tt class="docutils literal">&#64;&lt; name &#64;&gt;</tt> construct inside a chunk.
When tangled, these lead to inserting the referenced chunk's content.
Because this a reference to another chunk, the properties provide the values for the other chunk.</p>
<p class="rubric" id="the-referencecommand-class-17">The ReferenceCommand Class (17) =</p>
<pre class="code literal-block">
class ReferenceCommand(Command):
    &quot;&quot;&quot;
    Reference to a ``NamedChunk`` in code, a ``&#64;&lt; name &#64;&gt;`` construct.
    In a CodeChunk or OutputChunk, it tangles to the definition from a ``NamedChunk``.
    In text, it can weave to the text of a ``NamedDocumentChunk``.
    &quot;&quot;&quot;
    has_name = True

    def __init__(self, name: str, location: tuple[str, int]) -&gt; None:
        super().__init__(location)
        self.name = name  #: The name that is referenced.

    &#64;property
    def full_name(self) -&gt; str:
        return cast(Web, self.web()).resolve_name(self.name)

    &#64;property
    def seq(self) -&gt; int | None:
        return cast(Web, self.web()).resolve_chunk(self.name)[0].seq

    def tangle(self, aTangler: &quot;Tangler&quot;, target: TextIO) -&gt; None:
        &quot;&quot;&quot;Expand this reference.
        The starting position is the indentation for all **subsequent** lines.
        Provide the indent before ``&#64;&lt;``, in ``tangler.fragment`` back to the tangler.
        &quot;&quot;&quot;
        self.logger.debug(f&quot;tangle reference to {self.name=}, context: {aTangler.fragment=}&quot;)
        chunk_list = cast(Web, self.web()).resolve_chunk(self.name)
        if len(chunk_list) == 0:
            message = f&quot;Attempt to tangle an undefined Chunk, {self.name!r}&quot;
            self.logger.error(message)
            raise Error(message)
        aTangler.reference_names.add(self.name)
        aTangler.addIndent(len(aTangler.fragment))
        aTangler.fragment = &quot;&quot;

        for chunk in chunk_list:
            # TODO: if chunk.options includes '-indent': do a setIndent before tangling.
            for command in chunk.commands:
                command.tangle(aTangler, target)

        aTangler.clrIndent()

    def __repr__(self) -&gt; str:
        return f&quot;{self.__class__.__name__}(name={self.name!r}, location={self.location!r})&quot;
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>The ReferenceCommand Class (17)</em>.
Used by     → <a class="reference internal" href="#command-class-hierarchy-used-to-describe-individual-commands-in-a-chunk-10">Command class hierarchy -- used to describe individual commands in a chunk (10)</a>.</div>
</div>
<div class="section" id="the-xrefcommand-classes">
<h4><a class="toc-backref" href="#toc-entry-49">The XrefCommand Classes</a></h4>
<p>The <tt class="docutils literal">XRefCommand</tt> classes describes a <tt class="docutils literal">&#64;f</tt>, <tt class="docutils literal">&#64;m</tt>, and <tt class="docutils literal">&#64;u</tt> constructs inside a chunk.
These are <strong>not</strong> Tangled; they're only woven.</p>
<p>Each offers a unique property that can be used by the template rending to  get data about the WEB content.</p>
<p class="rubric" id="the-xrefcommand-subclasses-files-macros-and-user-names-18">The XrefCommand Subclasses -- files, macros, and user names (18) =</p>
<pre class="code literal-block">
class FileXrefCommand(Command):
    &quot;&quot;&quot;The ``&#64;f`` command.&quot;&quot;&quot;
    def __init__(self, location: tuple[str, int]) -&gt; None:
        super().__init__(location)

    &#64;property
    def files(self) -&gt; list[&quot;OutputChunk&quot;]:
        return cast(Web, self.web()).files

    def tangle(self, aTangler: &quot;Tangler&quot;, target: TextIO) -&gt; None:
        raise Error('Illegal tangling of a cross reference command.')

class MacroXrefCommand(Command):
    &quot;&quot;&quot;The ``&#64;m`` command.&quot;&quot;&quot;
    def __init__(self, location: tuple[str, int]) -&gt; None:
        super().__init__(location)

    &#64;property
    def macros(self) -&gt; list[SimpleNamespace]:
        return cast(Web, self.web()).macros

    def tangle(self, aTangler: &quot;Tangler&quot;, target: TextIO) -&gt; None:
        raise Error('Illegal tangling of a cross reference command.')

class UserIdXrefCommand(Command):
    &quot;&quot;&quot;The ``&#64;u`` command.&quot;&quot;&quot;
    def __init__(self, location: tuple[str, int]) -&gt; None:
        super().__init__(location)

    &#64;property
    def userids(self) -&gt; list[SimpleNamespace]:
        return cast(Web, self.web()).userids

    def tangle(self, aTangler: &quot;Tangler&quot;, target: TextIO) -&gt; None:
        raise Error('Illegal tangling of a cross reference command.')
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>The XrefCommand Subclasses -- files, macros, and user names (18)</em>.
Used by     → <a class="reference internal" href="#command-class-hierarchy-used-to-describe-individual-commands-in-a-chunk-10">Command class hierarchy -- used to describe individual commands in a chunk (10)</a>.</div>
</div>
</div>
</div>
<div class="section" id="output-serialization">
<h2><a class="toc-backref" href="#toc-entry-50">Output Serialization</a></h2>
<p>The <tt class="docutils literal">Emitter</tt> class hierarchy writes the output from the source <tt class="docutils literal">Web</tt> instance.
An <tt class="docutils literal">Emitter</tt> instance is responsible for control of an output file format.
This includes the necessary file naming, opening, writing and closing operations.</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 2659)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    abstract class Emitter {
        output: Path
        emit(Web)
    }

    class Web
    Emitter ..&gt; Web

    class Weaver
    Emitter &lt;|-- Weaver

    class Tangler
    Emitter &lt;|-- Tangler
    class TanglerMake
    Tangler &lt;|-- TanglerMake

    package jinja {
        class Environment
    }

    Weaver --&gt; Environment

    object template

    Weaver *-- template
    Environment --&gt; template

</pre>
</div>
<p>Here's how the definitions are provided in the application.
The two reference class definitions are used by by the <tt class="docutils literal">Emitter</tt> class, and needs to be defined first.
We'll look at them later, since they're a tiny strategy change in how cross-references
are displayed.</p>
<p class="rubric" id="base-class-definitions-19">Base Class Definitions (19) +=</p>
<pre class="code literal-block">
→ <a class="reference internal" href="#emitter-superclass-21">Emitter Superclass (21)</a>

→ <a class="reference internal" href="#weaver-subclass-uses-jinja-templates-to-weave-documentation-22">Weaver Subclass -- Uses Jinja templates to weave documentation (22)</a>

→ <a class="reference internal" href="#tangler-subclass-emits-the-output-files-28">Tangler Subclass -- emits the output files (28)</a>

→ <a class="reference internal" href="#tanglermake-subclass-extends-tangler-to-avoid-touching-files-that-didn-t-change-32">TanglerMake Subclass -- extends Tangler to avoid touching files that didn't change (32)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Base Class Definitions (19)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p class="rubric" id="imports-20">Imports (20) +=</p>
<pre class="code literal-block">
import abc
from textwrap import dedent, shorten
from jinja2 import Environment, DictLoader, select_autoescape
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Imports (20)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>The <tt class="docutils literal">Emitter</tt> class is an abstraction, used to check the consistency
of the subclasses.</p>
<p class="rubric" id="emitter-superclass-21">Emitter Superclass (21) =</p>
<pre class="code literal-block">
class Emitter(abc.ABC):
    def __init__(self, output: Path):
        self.logger = logging.getLogger(self.__class__.__qualname__)
        self.log_indent = logging.getLogger(&quot;indent.&quot; + self.__class__.__qualname__)
        self.output = output

    &#64;abc.abstractmethod
    def emit(self, web: Web) -&gt; None:
        pass
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Emitter Superclass (21)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-19">Base Class Definitions (19)</a>.</div>
<div class="section" id="the-weaver-subclass">
<h3><a class="toc-backref" href="#toc-entry-51">The Weaver Subclass</a></h3>
<p>The <tt class="docutils literal">Weaver</tt> is a <strong>Facade</strong> that wraps Jinja template processing.
The job is to build the necessary environment, locate the templates,
and then evaluate the template's <tt class="docutils literal">generate()</tt> method to fill the values
into the template to create the woven document.</p>
<p>There's &quot;base_weaver&quot; template that contains the essential structure of the output document.
This creates the needed macros, and then weaves the various chunks, in order.</p>
<p>Each markup language has macros that provide the unique markup required for the various chunks.
This permits customization of the markup.</p>
<p>We have an interesting wrinkle with RST-formatted output. There are two variants that may be important:</p>
<ul class="simple">
<li>When used with Sphinx, the &quot;small&quot; caption at the end of a code block uses <tt class="docutils literal">..&nbsp; <span class="pre">rst-class::</span> small</tt>.</li>
<li>When used without Sphinx, i.e., native docutils, the the &quot;small&quot; caption at the end of a code block uses <tt class="docutils literal">..&nbsp; class:: small</tt>.</li>
</ul>
<p>This is a minor change to the template being used.
The question is how to make that distinction in the weaver?
One view is to use subclasses of <a href="#system-message-2"><span class="problematic" id="problematic-2">:py:class:`Weaver`</span></a> for this.
However, the templates are found by name in the <tt class="docutils literal">template_map</tt> within the <tt class="docutils literal">Weaver</tt>.
The <tt class="docutils literal"><span class="pre">--weaver</span></tt> command-line option provides the string (e.g., <tt class="docutils literal">rst</tt> or <tt class="docutils literal">html</tt>) used
to build a key into the template map.</p>
<div class="system-message" id="system-message-2">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 2785); <em><a href="#problematic-2">backlink</a></em></p>
Unknown interpreted text role &quot;py:class&quot;.</div>
<p>We can, therefore, use the <tt class="docutils literal"><span class="pre">--weaver</span></tt> command-line option  to provide an expanded set of names for RST processing.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-w</span> rst</tt> is the Sphinx option.</li>
<li><tt class="docutils literal"><span class="pre">-w</span> <span class="pre">rst-sphinx</span></tt> is an alias for <tt class="docutils literal">rst</tt>. The dictionary key points to the same templates as <tt class="docutils literal">rst</tt>.</li>
<li><tt class="docutils literal"><span class="pre">-w</span> <span class="pre">rst-nosphinx</span></tt> is the &quot;pure-docutils&quot; version, using <tt class="docutils literal">.. class::</tt>.</li>
<li><tt class="docutils literal"><span class="pre">-w</span> <span class="pre">rst-docutils</span></tt> is an alias for the <tt class="docutils literal"><span class="pre">rst-nosphinx</span></tt> option.</li>
</ul>
<p>While this works out nicely, it turns out that the <tt class="docutils literal">..&nbsp; container:: small</tt> is, perhaps, a better markup that <tt class="docutils literal">..&nbsp; class:: small</tt>.
This work in docutils <strong>and</strong> Sphinx.</p>
<p class="rubric" id="weaver-subclass-uses-jinja-templates-to-weave-documentation-22">Weaver Subclass -- Uses Jinja templates to weave documentation (22) =</p>
<pre class="code literal-block">
→ <a class="reference internal" href="#debug-templates-these-display-debugging-information-24">Debug Templates -- these display debugging information (24)</a>

→ <a class="reference internal" href="#rst-templates-the-default-weave-output-25">RST Templates -- the default weave output (25)</a>

→ <a class="reference internal" href="#html-templates-emit-html-weave-output-26">HTML Templates -- emit HTML weave output (26)</a>

→ <a class="reference internal" href="#latex-templates-emit-latex-weave-output-27">LaTeX Templates -- emit LaTeX weave output (27)</a>

→ <a class="reference internal" href="#common-base-template-this-is-used-for-all-weaving-23">Common base template -- this is used for ALL weaving (23)</a>

class Weaver(Emitter):
    template_map = {
        &quot;debug_defaults&quot;: debug_weaver_template, &quot;debug_macros&quot;: &quot;&quot;,
        &quot;rst_defaults&quot;: rst_weaver_template, &quot;rst_macros&quot;: rst_overrides_template,
        &quot;html_defaults&quot;: html_weaver_template, &quot;html_macros&quot;: html_overrides_template,
        &quot;tex_defaults&quot;: latex_weaver_template, &quot;tex_macros&quot;: tex_overrides_template,

        &quot;rst-sphinx_defaults&quot;: rst_weaver_template, &quot;rst-sphinx_macros&quot;: rst_overrides_template,
        &quot;rst-nosphinx_defaults&quot;: rst_weaver_template, &quot;rst-nosphinx_macros&quot;: rst_nosphinx_template,
        &quot;rst-docutils_defaults&quot;: rst_weaver_template, &quot;rst-docutils_macros&quot;: rst_nosphinx_template,
    }

    quote_rules = {
        &quot;rst&quot;: rst_quote_rules,
        &quot;html&quot;: html_quote_rules,
        &quot;tex&quot;: latex_quote_rules,
        &quot;debug&quot;: debug_quote_rules,
    }

    def __init__(self, output: Path = Path.cwd()) -&gt; None:
        super().__init__(output)
        # Summary
        self.linesWritten = 0

    def set_markup(self, markup: str = &quot;rst&quot;) -&gt; &quot;Weaver&quot;:
        self.markup = markup
        return self

    def emit(self, web: Web) -&gt; None:
        self.target_path = (self.output / web.web_path.name).with_suffix(f&quot;.{self.markup}&quot;)
        self.logger.info(&quot;Weaving %s using %s markup&quot;, self.target_path, self.markup)
        with self.target_path.open('w') as target_file:
            for text in self.generate_text(web):
                self.linesWritten += text.count(&quot;\n&quot;)
                target_file.write(text)

    def generate_text(self, web: Web) -&gt; Iterator[str]:
        self.env = Environment(
            loader=DictLoader(
                self.template_map |
                {'base_weaver': base_template,}
            ),
            autoescape=select_autoescape()
        )
        self.env.filters |= {
            &quot;quote_rules&quot;: self.quote_rules[self.markup]
        }
        defaults = self.env.get_template(f&quot;{self.markup}_defaults&quot;)
        macros = self.env.get_template(f&quot;{self.markup}_macros&quot;)
        template = self.env.get_template(&quot;base_weaver&quot;)
        return template.generate(web=web, macros=macros, defaults=defaults)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Weaver Subclass -- Uses Jinja templates to weave documentation (22)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-19">Base Class Definitions (19)</a>.</div>
<p>There are several strategy plug-ins.
Each is unique for a particular flavort of markup.
These include the quoting function used to escape markup characters, and the templates used.</p>
<p>The objective is to have a generic &quot;weaver&quot; template which includes three levels
of template definition:</p>
<ol class="arabic simple">
<li>Defaults.</li>
<li>Configured overrides from <tt class="docutils literal">pyweb.toml</tt>.</li>
<li>Document overrides from the <tt class="docutils literal">.w</tt> file in <tt class="docutils literal">&#64;t name <span class="pre">&#64;{...&#64;}</span></tt> commands.</li>
</ol>
<p>This means there is a two-step binding between document and macros.</p>
<ol class="arabic">
<li><p class="first">The base weaver document should import three generic template definitions:</p>
<blockquote>
<p><tt class="docutils literal">{%- from 'markup' import * %}</tt></p>
<p><tt class="docutils literal">{%- from 'configured' import * %}</tt></p>
<p><tt class="docutils literal">{%- from 'document' import * %}</tt></p>
</blockquote>
</li>
<li><dl class="first docutils">
<dt>These names map (<em>somehow</em>) to specific templates based on markup language.</dt>
<dd><p class="first last"><tt class="docutils literal">markup</tt> -&gt; <tt class="docutils literal">rst/markup</tt>, etc.</p>
</dd>
</dl>
</li>
</ol>
<p>This allows us to provide all templates and make a final binding
at weave time. We can use a prefix loader with a given prefix.
Some kind of &quot;import rst/markup as markup&quot; would be ideal.</p>
<p>Jinja, however, doesn't seem to support this the same way Python does.
There's no <tt class="docutils literal">import as</tt> construct allowing very late binding.</p>
<p>The alternative is to  create the environment very late in the process, once we have all the information available.
We can then pick the templates to put into a DictLoader to support the standard weaving structure.</p>
<p>The quoting rules apply to the various template languages.
The idea is that a few characters must be escaped for proper presentation in the code sample sections.</p>
<div class="section" id="common-base-template">
<h4><a class="toc-backref" href="#toc-entry-52">Common Base Template</a></h4>
<p>The common base template expands each chunk and each command in order.
This involves some special case processing for <tt class="docutils literal">OutputChunk</tt> and <tt class="docutils literal">NamedChunk</tt>
which have a &quot;wrapper&quot; woven around the chunk's sequence of commands.</p>
<p>This relies on a number of individual macros:</p>
<ul class="simple">
<li>text(command). Emits a block of text -- this should do <em>nothing</em> with the text. The author's original
markup passes through untouched.</li>
<li>begin_code(chunk). Starts a block of code, either <tt class="docutils literal">&#64;d</tt> or <tt class="docutils literal">&#64;o</tt>.</li>
<li>code(command). Emits a block fo code. This may require escapes for special characters that would break
the markup being used.</li>
<li>ref(command). Emits a reference to a named block of code.</li>
<li>end_code(chunk). Ends a block of code.</li>
<li>file_xref(command). Emit the full <tt class="docutils literal">&#64;f</tt> output, usually some kind of definition list.</li>
<li>macro_xref(command). Emit the full <tt class="docutils literal">&#64;m</tt> output, usually some kind of definition list.</li>
<li>userid_xref(command). Emit the full <tt class="docutils literal">&#64;u</tt> output, usually some kind of definition list.</li>
</ul>
<p>The <tt class="docutils literal">ref()</tt> macro can also be used in the XREF output macros. It can also be used in the <tt class="docutils literal">end_code()</tt> macro.
After a block of code, some tools (like Interscript) will show where the block was referenced.
The point of using the <tt class="docutils literal">ref()</tt> macro in multiple places is to make all of them look identical.</p>
<p>There are a variety of optional formatting considerations.
First is cross-references, second is a variety of <tt class="docutils literal">begin_code()</tt> options.</p>
<p>There are four styles for the &quot;referencedBy&quot; information in a <tt class="docutils literal">Chunk</tt>.</p>
<ul class="simple">
<li>Nothing.</li>
<li>The immediate <tt class="docutils literal">&#64;&lt;name&#64;&gt;</tt> Chunk.</li>
<li>The entire transitive sequence of parents for the <tt class="docutils literal">&#64;&lt;name&#64;&gt;</tt> Chunk. There
are two forms for this:<ul>
<li>Top-down path. <tt class="docutils literal">→ Named (1) / → <span class="pre">Sub-Named</span> (2) / → <span class="pre">Sub-Sub-Named</span> (3)</tt>.</li>
<li>Bottom-up path.  <tt class="docutils literal">→ <span class="pre">Sub-Sub-Named</span> (3) ∈ → <span class="pre">Sub-Named</span> (2) ∈ → Named (1)</tt>.</li>
</ul>
</li>
</ul>
<p>These require four distinct versions of the <tt class="docutils literal">end_code()</tt> macro.
This macro uses the <tt class="docutils literal">transitive_referencedBy</tt> property of a <tt class="docutils literal">Chunk</tt> producing a sequence of <tt class="docutils literal">ref()</tt> values.</p>
<p>(Note the <tt class="docutils literal">→</tt> characters are preface characters for a link.)</p>
<p class="rubric" id="common-base-template-this-is-used-for-all-weaving-23">Common base template -- this is used for ALL weaving (23) =</p>
<pre class="code literal-block">
base_template = dedent(&quot;&quot;&quot;\
    {%- from macros import text, begin_code, code, ref, end_code, file_xref, macro_xref, userid_xref -%}
    {%- if not text is defined %}{%- from defaults import text -%}{%- endif -%}
    {%- if not begin_code is defined %}{%- from defaults import begin_code -%}{%- endif -%}
    {%- if not code is defined %}{%- from defaults import code -%}{%- endif -%}
    {%- if not ref is defined %}{%- from defaults import ref -%}{%- endif -%}
    {%- if not end_code is defined %}{%- from defaults import end_code -%}{%- endif -%}
    {%- if not file_xref is defined %}{%- from defaults import file_xref -%}{%- endif -%}
    {%- if not macro_xref is defined %}{%- from defaults import macro_xref -%}{%- endif -%}
    {%- if not userid_xref is defined %}{%- from defaults import userid_xref -%}{%- endif -%}
    {% for chunk in web.chunks -%}
        {%- if chunk.type_is('OutputChunk') or chunk.type_is('NamedChunk') -%}
            {{begin_code(chunk)}}
            {%- for command in chunk.commands -%}
                {%- if command.typeid.CodeCommand -%}{{code(command)}}
                {%- elif command.typeid.ReferenceCommand -%}{{ref(command)}}
                {%- endif -%}
            {%- endfor -%}
            {{end_code(chunk)}}
        {%- elif chunk.type_is('Chunk') -%}
            {%- for command in chunk.commands -%}
                {%- if command.typeid.TextCommand %}{{text(command)}}
                {%- elif command.typeid.ReferenceCommand %}{{ref(command)}}
                {%- elif command.typeid.FileXrefCommand %}{{file_xref(command)}}
                {%- elif command.typeid.MacroXrefCommand %}{{macro_xref(command)}}
                {%- elif command.typeid.UserIdXrefCommand %}{{userid_xref(command)}}
                {%- endif -%}
            {%- endfor -%}
        {%- endif -%}
    {%- endfor %}
&quot;&quot;&quot;)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Common base template -- this is used for ALL weaving (23)</em>.
Used by     → <a class="reference internal" href="#weaver-subclass-uses-jinja-templates-to-weave-documentation-22">Weaver Subclass -- Uses Jinja templates to weave documentation (22)</a>.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 3020)</p>
<p>Unknown directive type &quot;todo&quot;.</p>
<pre class="literal-block">
..  todo:: Need to more gracefully handle the case where an output chunk has multiple definitions.

    For example,

    ..  parsed-literal::

        &#64;o x.y
        &#64;{
        ... part 1 ...
        &#64;}

        &#64;o x.y
        &#64;{
        ... part 2 ...
        &#64;}

    The above should have the same output as the following (more complex) alternative:

    ..  parsed-literal::

        &#64;o x.y
        &#64;{
        &#64;&lt;part 1&#64;&gt;
        &#64;&lt;part 2&#64;&gt;
        &#64;}

        &#64;d part 1
        &#64;{
        ... part 1 ...
        &#64;}

        &#64;d part 2
        &#64;{
        ... part 2 ...
        &#64;}

    Currently, we casually treat the first instance
    as the &quot;definition&quot;, and don't provide references
    to the additional parts of the definition.

</pre>
</div>
</div>
<div class="section" id="debug-template">
<h4><a class="toc-backref" href="#toc-entry-53">Debug Template</a></h4>
<p class="rubric" id="debug-templates-these-display-debugging-information-24">Debug Templates -- these display debugging information (24) =</p>
<pre class="code literal-block">
def debug_quote_rules(text: str) -&gt; str:
    return repr(text)

debug_weaver_template = dedent(&quot;&quot;&quot;\
    {%- macro text(command) -%}
    text: {{command}}
    {%- endmacro -%}

    {%- macro begin_code(chunk) %}
    begin_code: {{chunk}}
    {%- endmacro -%}

    {%- macro code(command) %}
    code: {{command}}
    {%- endmacro -%}

    {%- macro ref(id) %}
    ref: {{id}}
    {%- endmacro -%}

    {%- macro end_code(chunk) %}
    end_code: {{chunk}}
    {% endmacro -%}

    {%- macro file_xref(command) -%}
    file_xref {{command.files}}
    {%- endmacro -%}

    {%- macro macro_xref(command) -%}
    macro_xref {{command.macros}}
    {%- endmacro -%}

    {%- macro userid_xref(command) -%}
    userid_xref {{command.userids}}
    {%- endmacro -%}
    &quot;&quot;&quot;)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Debug Templates -- these display debugging information (24)</em>.
Used by     → <a class="reference internal" href="#weaver-subclass-uses-jinja-templates-to-weave-documentation-22">Weaver Subclass -- Uses Jinja templates to weave documentation (22)</a>.</div>
</div>
<div class="section" id="rst-template">
<h4><a class="toc-backref" href="#toc-entry-54">RST Template</a></h4>
<p>The RST Templates produce ReStructuredText for the various web commands.
Note that code lines must be indented when using this markup.</p>
<p class="rubric" id="rst-templates-the-default-weave-output-25">RST Templates -- the default weave output (25) =</p>
<pre class="code literal-block">
def rst_quote_rules(text: str) -&gt; str:
    quoted_chars = [
        ('\\', r'\\'), # Must be first.
        ('`', r'\`'),
        ('_', r'\_'),
        ('*', r'\*'),
        ('|', r'\|'),
    ]
    clean = text
    for from_, to_ in quoted_chars:
        clean = clean.replace(from_, to_)
    return clean

rst_weaver_template = dedent(&quot;&quot;&quot;
    {%- macro text(command) -%}
    {{command.text}}
    {%- endmacro -%}

    {%- macro begin_code(chunk) %}
    ..  _`{{chunk.full_name or chunk.name}} ({{chunk.seq}})`:
    ..  rubric:: {{chunk.full_name or chunk.name}} ({{chunk.seq}}) {% if chunk.initial %}={% else %}+={% endif %}
    ..  parsed-literal::
        :class: code

    {% endmacro -%}

    {# For RST, each line must be indented. #}
    {%- macro code(command) %}{% for line in command.text.splitlines() %}    {{line | quote_rules}}
    {% endfor -%}{% endmacro -%}

    {%- macro ref(id) %}    \N{RIGHTWARDS ARROW} `{{id.full_name or id.name}} ({{id.seq}})`_{% endmacro -%}

    {# When using Sphinx, this *could* be rst-class::, pure docutils uses container::#}
    {%- macro end_code(chunk) %}
    ..

    ..  container:: small

        \N{END OF PROOF} *{{chunk.full_name or chunk.name}} ({{chunk.seq}})*.
        {% if chunk.referencedBy %}Used by {{ref(chunk.referencedBy)}}.{% endif %}

    {% endmacro -%}

    {%- macro file_xref(command) -%}
    {% for file in command.files -%}
    :{{file.name}}:
        \N{RIGHTWARDS ARROW} `{{file.name}} ({{file.seq}})`_
    {%- endfor %}
    {%- endmacro -%}

    {%- macro macro_xref(command) -%}
    {% for macro in command.macros -%}
    :{{macro.full_name}}:
        {% for d in macro.def_list -%}\N{RIGHTWARDS ARROW} `{{d.full_name or d.name}} ({{d.seq}})`_{% if loop.last %}{% else %}, {% endif %}{%- endfor %}

    {% endfor %}
    {%- endmacro -%}

    {%- macro userid_xref(command) -%}
    {% for userid in command.userids -%}
    :{{userid.userid}}:
        {% for r in userid.ref_list -%}\N{RIGHTWARDS ARROW} `{{r.full_name or r.name}} ({{r.seq}})`_{% if loop.last %}{% else %}, {% endif %}{%- endfor %}

    {% endfor %}
    {%- endmacro -%}
    &quot;&quot;&quot;)

rst_overrides_template = dedent(&quot;&quot;&quot;\
    &quot;&quot;&quot;)

rst_nosphinx_template = dedent(&quot;&quot;&quot;\
    {%- macro end_code(chunk) %}
    ..

    ..  class:: small

        \N{END OF PROOF} *{{chunk.full_name or chunk.name}} ({{chunk.seq}})*

    {% endmacro -%}
    &quot;&quot;&quot;)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>RST Templates -- the default weave output (25)</em>.
Used by     → <a class="reference internal" href="#weaver-subclass-uses-jinja-templates-to-weave-documentation-22">Weaver Subclass -- Uses Jinja templates to weave documentation (22)</a>.</div>
</div>
<div class="section" id="html-template">
<h4><a class="toc-backref" href="#toc-entry-55">HTML Template</a></h4>
<p>The HTML templates use a relatively simple markup, avoiding any CSS names.
A slightly more flexible approach might be to name specific CSS styles, and provide
generic definitions for those styles. This would make it easier to
tailor HTML output via CSS changes, avoiding any HTML modifications.</p>
<p class="rubric" id="html-templates-emit-html-weave-output-26">HTML Templates -- emit HTML weave output (26) =</p>
<pre class="code literal-block">
def html_quote_rules(text: str) -&gt; str:
    quoted_chars = [
        (&quot;&amp;&quot;, &quot;&amp;amp;&quot;),  # Must be first
        (&quot;&lt;&quot;, &quot;&amp;lt;&quot;),
        (&quot;&gt;&quot;, &quot;&amp;gt;&quot;),
        ('&quot;', &quot;&amp;quot;&quot;),  # Only applies inside tags...
    ]
    clean = text
    for from_, to_ in quoted_chars:
        clean = clean.replace(from_, to_)
    return clean

html_weaver_template = dedent(&quot;&quot;&quot;\
    {%- macro text(command) -%}
    {{command.text}}
    {%- endmacro -%}

    {%- macro begin_code(chunk) %}
    &lt;a name=&quot;pyweb_{{chunk.seq}}&quot;&gt;&lt;/a&gt;
    &lt;!--line number {{chunk.location}}--&gt;
    &lt;p&gt;&lt;em&gt;{{chunk.full_name or chunk.name}} ({{chunk.seq}})&lt;/em&gt; {% if chunk.initial %}={% else %}+={% endif %}&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;
    {%- endmacro -%}

    {%- macro code(command) -%}{{command.text | quote_rules}}{%- endmacro -%}

    {%- macro ref(id) %}&amp;rarr;&lt;a href=&quot;#pyweb_{{id.seq}}&quot;&gt;&lt;em&gt;{{id.full_name or id.name}} ({{id.seq}})&lt;/em&gt;&lt;/a&gt;{% endmacro -%}

    {%- macro end_code(chunk) %}
    &lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;&amp;#8718; &lt;em&gt;{{chunk.full_name or chunk.name}} ({{chunk.seq}})&lt;/em&gt;.
    {% if chunk.referencedBy %}Used by {{ref(chunk.referencedBy)}}.{% endif %}
    &lt;/p&gt;
    {% endmacro -%}

    {%- macro file_xref(command) %}
    &lt;dl&gt;
    {% for file in command.files -%}
      &lt;dt&gt;{{file.name}}&lt;/dt&gt;&lt;dd&gt;{{ref(file)}}&lt;/dd&gt;
    {%- endfor %}
    &lt;/dl&gt;
    {% endmacro -%}

    {%- macro macro_xref(command) %}
    &lt;dl&gt;
    {% for macro in command.macros -%}
      &lt;dt&gt;{{macro.full_name}}&lt;dt&gt;
      &lt;dd&gt;{% for d in macro.def_list -%}{{ref(d)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}&lt;/dd&gt;
    {% endfor %}
    &lt;/dl&gt;
    {% endmacro -%}

    {%- macro userid_xref(command) %}
    &lt;dl&gt;
    {% for userid in command.userids -%}
      &lt;dt&gt;{{userid.userid}}&lt;/dt&gt;
      &lt;dd&gt;{% for r in userid.ref_list -%}{{ref(r)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}&lt;/dd&gt;
    {% endfor %}
    &lt;/dl&gt;
    {% endmacro -%}
    &quot;&quot;&quot;)

html_overrides_template = dedent(&quot;&quot;&quot;\
    &quot;&quot;&quot;)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>HTML Templates -- emit HTML weave output (26)</em>.
Used by     → <a class="reference internal" href="#weaver-subclass-uses-jinja-templates-to-weave-documentation-22">Weaver Subclass -- Uses Jinja templates to weave documentation (22)</a>.</div>
</div>
<div class="section" id="latex-template">
<h4><a class="toc-backref" href="#toc-entry-56">LaTeX Template</a></h4>
<p>The LaTeX templates use a markup focused in the <tt class="docutils literal">verbatim</tt> environment.
Common alternatives include <tt class="docutils literal">listings</tt> and <tt class="docutils literal">minted</tt>.</p>
<p class="rubric" id="latex-templates-emit-latex-weave-output-27">LaTeX Templates -- emit LaTeX weave output (27) =</p>
<pre class="code literal-block">
def latex_quote_rules(text: str) -&gt; str:
    quoted_strings = [
        (&quot;\\end{Verbatim}&quot;, &quot;\\end\\,{Verbatim}&quot;),  # Allow \end{Verbatim} in a Verbatim context
        (&quot;\\{&quot;, &quot;\\\\,{&quot;), # Prevent unexpected commands in Verbatim
        (&quot;$&quot;, &quot;\\$&quot;), # Prevent unexpected math in Verbatim
    ]
    clean = text
    for from_, to_ in quoted_strings:
        clean = clean.replace(from_, to_)
    return clean

latex_weaver_template = dedent(&quot;&quot;&quot;\
    {%- macro text(command) -%}
    {{command.text}}
    {%- endmacro -%}

    {%- macro begin_code(chunk) %}
    \\label{pyweb-{{chunk.seq}}}
    \\begin{flushleft}
    \\textit{Code example {{chunk.full_name or chunk.name}} ({{chunk.seq}})}
    \\begin{Verbatim}[commandchars=\\\\\\{\\},codes={\\catcode`$$=3\\catcode`^=7},frame=single]
    {%- endmacro -%}

    {%- macro code(command) -%}{{command.text | quote_rules}}{%- endmacro -%}

    {%- macro ref(id) %}$$\\rightarrow$$ Code Example {{id.full_name or id.name}} ({{id.seq}}){% endmacro -%}

    {%- macro end_code(chunk) %}
    \\end{Verbatim}
    \\end{flushleft}
    {% endmacro -%}

    {%- macro file_xref(command) %}
    \\begin{itemize}
    {% for file in command.files -%}
      \\item {{file.name}}: {{ref(file)}}
    {%- endfor %}
    \\end{itemize}
    {% endmacro -%}

    {%- macro macro_xref(command) %}
    \\begin{itemize}
    {% for macro in command.macros -%}
      \\item {{macro.full_name}} \\\\
            {% for d in macro.def_list -%}{{ref(d)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
    {% endfor %}
    \\end{itemize}
    {% endmacro -%}

    {%- macro userid_xref(command) %}
    \\begin{itemize}
    {% for userid in command.userids -%}
      \\item {{userid.userid}} \\\\
            {% for r in userid.ref_list -%}{{ref(r)}}{% if loop.last %}{% else %}, {% endif %}{%- endfor %}
    {% endfor %}
    \\end{itemize}
    {% endmacro -%}
    &quot;&quot;&quot;)

tex_overrides_template = dedent(&quot;&quot;&quot;\
    &quot;&quot;&quot;)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>LaTeX Templates -- emit LaTeX weave output (27)</em>.
Used by     → <a class="reference internal" href="#weaver-subclass-uses-jinja-templates-to-weave-documentation-22">Weaver Subclass -- Uses Jinja templates to weave documentation (22)</a>.</div>
</div>
</div>
<div class="section" id="the-tangler-subclasses">
<h3><a class="toc-backref" href="#toc-entry-57">The Tangler Subclasses</a></h3>
<p>Tangling is a variation on emitting that includes all the code in the order defined by the <tt class="docutils literal">&#64;o</tt> file commands.
This is not necessarily the order they're presented in the document.</p>
<p>The whole point of Weaving and Tangling is to write a document in an order that's sensible for people to understand.
The tangled output is for compilers and run-time environments.</p>
<p>Each file is individually tangled, unrelated to the order of the source
WEB document.
The <tt class="docutils literal">emit()</tt> process, therefore, iterates through all of the files defined in the WEB.</p>
<p>There's a complex interplay between <tt class="docutils literal">Tangler</tt> and <tt class="docutils literal">CodeCommand</tt>
to maintain the indentations.</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 3410)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    participant Tangler

    participant ReferenceCommand

    participant Command

    Tangler --&gt; ReferenceCommand : tangle()
    ReferenceCommand --&gt; Tangler : get len(fragment)
    ReferenceCommand --&gt; Tangler : addIndent(i)
    group [for all] commands in the referenced chunk
        ReferenceCommand --&gt; Command : tangle()
    end
    ReferenceCommand --&gt; Tangler : clrIndent()

</pre>
</div>
<p>This approach can preserves the indentation in front of a <tt class="docutils literal">&#64;&lt; reference &#64;&gt;</tt> command.</p>
<p class="rubric" id="tangler-subclass-emits-the-output-files-28">Tangler Subclass -- emits the output files (28) =</p>
<pre class="code literal-block">
class Tangler(Emitter):
    code_indent = 0  #: Initial indent

    def __init__(self, output: Path = Path.cwd()) -&gt; None:
        super().__init__(output)
        self.context: list[int] = []  #: Indentations
        self.fragment = &quot;&quot;  # Nothing written yet.
        # Create context and initial lastIndent values
        self.resetIndent(self.code_indent)
        # Summaries
        self.reference_names: set[str] = set()
        self.linesWritten = 0
        self.totalFiles = 0
        self.totalLines = 0

    def emit(self, web: Web) -&gt; None:
        for file_chunk in web.files:
            self.logger.info(&quot;Tangling %s&quot;, file_chunk.name)
            self.emit_file(web, file_chunk)

    def emit_file(self, web: Web, file_chunk: Chunk) -&gt; None:
        target_path = self.output / (file_chunk.name or &quot;Untitled.out&quot;)
        self.logger.debug(&quot;Writing %s&quot;, target_path)
        self.logger.debug(&quot;Chunk %r&quot;, file_chunk)
        with target_path.open(&quot;w&quot;) as target:
            # An initial command to provide indentations.
            for command in file_chunk.commands:
                command.tangle(self, target)


→ <a class="reference internal" href="#emitter-write-a-block-of-code-with-proper-indents-29">Emitter write a block of code with proper indents (29)</a>


→ <a class="reference internal" href="#emitter-indent-control-set-clear-and-reset-30">Emitter indent control: set, clear and reset (30)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Tangler Subclass -- emits the output files (28)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-19">Base Class Definitions (19)</a>.</div>
<p>The <tt class="docutils literal">codeBlock()</tt> method is used by each block of code tangled into
a document. There are two sources of indentation:</p>
<ul class="simple">
<li>A <tt class="docutils literal">Chunk</tt> can provide an indent setting as an option. This is provided by the <tt class="docutils literal">indent</tt> attribute
of the tangle context. If specified, this is the indentation.</li>
<li>A <tt class="docutils literal">&#64;&lt; name &#64;&gt;</tt> <tt class="docutils literal">ReferenceCommand</tt> may be indented. This will be in a <tt class="docutils literal">Chunk</tt> as the following three commands:<ol class="arabic">
<li>A <tt class="docutils literal">CodeCommand</tt> with only spaces and no trailing <tt class="docutils literal">\n</tt>.
The indent is buffered -- not written -- and the <tt class="docutils literal">fragment</tt> attribute is set.</li>
<li>The <tt class="docutils literal">ReferenceCommand</tt>. This interpolates text from a <tt class="docutils literal">NamedChunk</tt> using the prevailing indent.
The <tt class="docutils literal">tangle()</tt> method uses <tt class="docutils literal">addIndent()</tt> and <tt class="docutils literal">clrIndent()</tt> to mark this. The processing depends
on this tangler's <tt class="docutils literal">fragment</tt> attribute to provide the pending indentation; the <tt class="docutils literal">addIndent()</tt>
must consume the fragment to prevent confusion with subsequent indentations.</li>
<li>A <tt class="docutils literal">CodeCommand</tt> with a trailing <tt class="docutils literal">\n</tt>. (Often it's only the newline.)  If the <tt class="docutils literal">fragment</tt> attribute
is set, there's a pending indentation that hasn't yet been written.
This can happen with there's a <tt class="docutils literal">&#64;&#64;</tt> command at the left end of a line; often a Python decorator.
The fragment is written and the <tt class="docutils literal">fragment</tt> attribute cleared.  No <tt class="docutils literal">addIdent()</tt> will have
been done to consume the fragment.</li>
</ol>
</li>
</ul>
<p>While the WEB language permits multiple <tt class="docutils literal">&#64;&lt;name&#64;&gt; &#64;&lt;name&#64;&gt;</tt> on a single line,
this is odd and potentially confusing. It isn't clear how the second reference
should be indented.</p>
<p>The <tt class="docutils literal">ReferenceCommand</tt> <tt class="docutils literal">tangle()</tt> implementation handles much of this.
The following two rules apply:</p>
<ul class="simple">
<li>A line of text that does not end with a newline, sets a new prevailing indent
for the following command(s).</li>
<li>A line of text ending with a newline resets the prevailing indent.</li>
</ul>
<p>This a stack, maintained by the Tangler.</p>
<p class="rubric" id="emitter-write-a-block-of-code-with-proper-indents-29">Emitter write a block of code with proper indents (29) =</p>
<pre class="code literal-block">
def codeBlock(self, target: TextIO, text: str) -&gt; None:
    &quot;&quot;&quot;Indented write of text in a ``CodeCommand``.
    Counts lines and saves position to indent to when expanding ``&#64;&lt;...&#64;&gt;`` references.

    The ``fragment`` is the prevailing indent used in reference expansion.
    &quot;&quot;&quot;
    for line in text.splitlines(keepends=True):
        self.logger.debug(&quot;codeBlock(%r)&quot;, line)
        indent = self.context[-1]
        if len(line) == 0:
            # Degenerate case of empty CodeText command. Should not occur.
            pass
        elif not line.endswith('\n'):
            # Possible start of indentation prior to a ``&#64;&lt;name&#64;&gt;``
            target.write(indent*' ')
            wrote = target.write(line)
            self.fragment = ' ' * wrote
            # May be used by a ``ReferenceCommand``, if needed.
        elif line.endswith('\n'):
            target.write(indent*' ')
            target.write(line)
            self.linesWritten += 1
        else:
            raise RuntimeError(&quot;Non-exhaustive if statement.&quot;)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Emitter write a block of code with proper indents (29)</em>.
Used by     → <a class="reference internal" href="#tangler-subclass-emits-the-output-files-28">Tangler Subclass -- emits the output files (28)</a>.</div>
<p>The <tt class="docutils literal">addIndent()</tt> increments the indent.
Used by <tt class="docutils literal">&#64;&lt;name&#64;&gt;</tt> to set a prevailing indent.</p>
<p>The <tt class="docutils literal">setIndent()</tt> pushes a fixed indent instead adding an increment.
Used by a <tt class="docutils literal">Chunk</tt> with an <tt class="docutils literal"><span class="pre">-indent</span></tt> option.</p>
<p>The <tt class="docutils literal">clrIndent()</tt> method discards the most recent indent from the context stack.
This is used when finished
tangling a source chunk.  This restores the indent to the prevailing indent.</p>
<p>The <tt class="docutils literal">resetIndent()</tt> method removes all indent context information and resets the indent
to a default.</p>
<p class="rubric" id="emitter-indent-control-set-clear-and-reset-30">Emitter indent control: set, clear and reset (30) =</p>
<pre class="code literal-block">
def addIndent(self, increment: int) -&gt; None:
    self.lastIndent = self.context[-1]+increment
    self.context.append(self.lastIndent)
    self.log_indent.debug(&quot;addIndent %d: %r&quot;, increment, self.context)
    self.fragment = &quot;&quot;

def setIndent(self, indent: int) -&gt; None:
    self.context.append(indent)
    self.lastIndent = self.context[-1]
    self.log_indent.debug(&quot;setIndent %d: %r&quot;, indent, self.context)
    self.fragment = &quot;&quot;

def clrIndent(self) -&gt; None:
    if len(self.context) &gt; 1:
        self.context.pop()
    self.lastIndent = self.context[-1]
    self.log_indent.debug(&quot;clrIndent %r&quot;, self.context)
    self.fragment = &quot;&quot;

def resetIndent(self, indent: int = 0) -&gt; None:
    &quot;&quot;&quot;Resets the indentation context.&quot;&quot;&quot;
    self.lastIndent = indent
    self.context = [self.lastIndent]
    self.log_indent.debug(&quot;resetIndent %d: %r&quot;, indent, self.context)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Emitter indent control: set, clear and reset (30)</em>.
Used by     → <a class="reference internal" href="#tangler-subclass-emits-the-output-files-28">Tangler Subclass -- emits the output files (28)</a>.</div>
<p>An extension to the <tt class="docutils literal">Tangler</tt> class that only updates a file if the content has changed.
This tangles to a temporary file.
If the content is identical, the temporary file is quietly disposed of.
Otherwise, the temporary file is linked to the original name.</p>
<p>Files are compared with the <tt class="docutils literal">filecmp</tt> module.</p>
<p class="rubric" id="imports-31">Imports (31) +=</p>
<pre class="code literal-block">
import filecmp
import tempfile
import os
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Imports (31)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p class="rubric" id="tanglermake-subclass-extends-tangler-to-avoid-touching-files-that-didn-t-change-32">TanglerMake Subclass -- extends Tangler to avoid touching files that didn't change (32) =</p>
<pre class="code literal-block">
class TanglerMake(Tangler):
    def emit_file(self, web: Web, file_chunk: Chunk) -&gt; None:
        target_path = self.output / (file_chunk.name or &quot;Untitled.out&quot;)
        self.logger.debug(&quot;Writing %s via a temp file&quot;, target_path)
        self.logger.debug(&quot;Chunk %r&quot;, file_chunk)

        fd, tempname = tempfile.mkstemp(dir=os.curdir)
        with os.fdopen(fd, &quot;w&quot;) as target:
            for command in file_chunk.commands:
                command.tangle(self, target)

        try:
            same = filecmp.cmp(tempname, target_path)
        except OSError as e:
            same = False  # Doesn't exist. (Could check for errno.ENOENT)

        if same:
            self.logger.info(&quot;Unchanged '%s'&quot;, target_path)
            os.remove(tempname)
        else:
            # Windows requires the original file name be removed first.
            try:
                target_path.unlink()
            except OSError as e:
                pass  # Doesn't exist. (Could check for errno.ENOENT)
            target_path.parent.mkdir(parents=True, exist_ok=True)
            target_path.hardlink_to(tempname)
            os.remove(tempname)
            self.logger.info(&quot;Wrote %d lines to %s&quot;, self.linesWritten, target_path)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>TanglerMake Subclass -- extends Tangler to avoid touching files that didn't change (32)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-19">Base Class Definitions (19)</a>.</div>
</div>
</div>
<div class="section" id="input-parsing">
<h2><a class="toc-backref" href="#toc-entry-58">Input Parsing</a></h2>
<p>There are three tiers to the input parsing:</p>
<ul class="simple">
<li>A base tokenizer.</li>
<li>Additionally, a separate parser is used for options in <tt class="docutils literal">&#64;d</tt> and <tt class="docutils literal">&#64;o</tt> commands.</li>
<li>The overall <tt class="docutils literal">WebReader</tt> class.</li>
</ul>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 3698)</p>
<p>Unknown directive type &quot;uml&quot;.</p>
<pre class="literal-block">
..  uml::

    class WebReader {
        load(path) : Web
        parse_source()
    }

    class Tokenizer &lt;&lt;Iterator&gt;&gt; {
        __next__(self) : str
    }

    WebReader --&gt; Tokenizer
    WebReader --&gt; WebReader : &quot;parent&quot;
    WebReader --&gt; argparse.ArgumentParser

</pre>
</div>
<p>We'll start with the <tt class="docutils literal">WebReader</tt> class definition</p>
<p class="rubric" id="base-class-definitions-33">Base Class Definitions (33) +=</p>
<pre class="code literal-block">
→ <a class="reference internal" href="#tokenizer-class-breaks-input-into-tokens-51">Tokenizer class - breaks input into tokens (51)</a>

→ <a class="reference internal" href="#webreader-class-parses-the-input-file-building-the-web-structure-34">WebReader class - parses the input file, building the Web structure (34)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Base Class Definitions (33)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<div class="section" id="the-webreader-class">
<h3><a class="toc-backref" href="#toc-entry-59">The WebReader Class</a></h3>
<p>There are two forms of the constructor for a <tt class="docutils literal">WebReader</tt>.
The  initial <tt class="docutils literal">WebReader</tt> instance is created with code like the following:</p>
<pre class="literal-block">
p = WebReader()
p.command = options.commandCharacter
</pre>
<p>This will define the command character; usually provided as a command-line parameter to the application.</p>
<p>When processing an include file (with the <tt class="docutils literal">&#64;i</tt> command), a child <tt class="docutils literal">WebReader</tt>
instance is created with code like the following:</p>
<pre class="literal-block">
c = WebReader(parent=parentWebReader)
</pre>
<p>This will inherit the configuration from the parent <tt class="docutils literal">WebReader</tt>.
This will also include a  reference from child to parent so that embedded Python expressions
can view the entire input context.</p>
<p>The <tt class="docutils literal">WebReader</tt> class parses the input file into command blocks.
These are assembled into <tt class="docutils literal">Chunks</tt>, and the <tt class="docutils literal">Chunks</tt> are assembled into the document
<tt class="docutils literal">Web</tt>.  Once this input pass is complete, the resulting <tt class="docutils literal">Web</tt> can be tangled or
woven.</p>
<p>The commands have three general types:</p>
<ul class="simple">
<li>&quot;Structural&quot; commands define the structure of the <tt class="docutils literal">Chunks</tt>.  The  structural commands
are <tt class="docutils literal">&#64;d</tt> and <tt class="docutils literal">&#64;o</tt>, as well as the <tt class="docutils literal">&#64;{</tt>, <tt class="docutils literal">&#64;}</tt>, <tt class="docutils literal">&#64;[</tt>, <tt class="docutils literal">&#64;]</tt> brackets,
and the <tt class="docutils literal">&#64;i</tt> command to include another file.</li>
<li>&quot;Inline&quot; commands are inline within a <tt class="docutils literal">Chunk</tt>: they define internal <tt class="docutils literal">Commands</tt>.
Blocks of text are minor commands, as well as the <tt class="docutils literal">&#64;&lt;</tt><em>name</em><tt class="docutils literal">&#64;&gt;</tt> references.
The <tt class="docutils literal">&#64;&#64;</tt> escape is also
handled here so that all further processing is independent of any parsing.</li>
<li>&quot;Content&quot; commands generate woven content. These include
the various cross-reference commands (<tt class="docutils literal">&#64;f</tt>, <tt class="docutils literal">&#64;m</tt> and <tt class="docutils literal">&#64;u</tt>).</li>
</ul>
<p>There are two class-level <tt class="docutils literal">argparse.ArgumentParser</tt> instances used by this class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">output_option_parser:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">An <tt class="docutils literal">argparse.ArgumentParser</tt> used to parse the <tt class="docutils literal">&#64;o</tt> command's options.</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">definition_option_parser:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">An <tt class="docutils literal">argparse.ArgumentParser</tt> used to parse the <tt class="docutils literal">&#64;d</tt> command's options.</td>
</tr>
</tbody>
</table>
<p>The class has the following attributes:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">parent:</th><td class="field-body">is the outer <tt class="docutils literal">WebReader</tt> when processing a <tt class="docutils literal">&#64;i</tt> command.</td>
</tr>
<tr class="field"><th class="field-name">command:</th><td class="field-body">is the command character; a WebReader will use the parent command
character if the parent is not <tt class="docutils literal">None</tt>. Default is <tt class="docutils literal">&#64;</tt>.</td>
</tr>
<tr class="field"><th class="field-name">permitList:</th><td class="field-body">is the list of commands that are permitted to fail.  This is generally
an empty list or <tt class="docutils literal"><span class="pre">('&#64;i',)</span></tt>.</td>
</tr>
<tr class="field"><th class="field-name">_source:</th><td class="field-body">The open file-like object being used by <tt class="docutils literal">load()</tt>.</td>
</tr>
<tr class="field"><th class="field-name">filePath:</th><td class="field-body">The path being processed; this provides a visible file name.</td>
</tr>
<tr class="field"><th class="field-name">tokenizer:</th><td class="field-body">An instance of <tt class="docutils literal">Tokenizer</tt> used to parse the input. This is built
when <tt class="docutils literal">load()</tt> is called.</td>
</tr>
<tr class="field"><th class="field-name">totalLines:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">totalFiles:</th><td class="field-body"></td>
</tr>
<tr class="field"><th class="field-name">errors:</th><td class="field-body">Summary counts.</td>
</tr>
</tbody>
</table>
<p class="rubric" id="webreader-class-parses-the-input-file-building-the-web-structure-34">WebReader class - parses the input file, building the Web structure (34) =</p>
<pre class="code literal-block">
class WebReader:
    &quot;&quot;&quot;Parse an input file, creating Chunks and Commands.&quot;&quot;&quot;

    # Configuration
    #: The command prefix, default ``&#64;``.
    command: str
    #: Permitted errors, usually &#64;i commands
    permitList: list[str]
    #: Working directory to resolve &#64;i commands
    base_path: Path
    #: The tokenizer used to find commands
    tokenizer: Tokenizer

    # State of the reader
    #: Parent context for &#64;i commands
    parent: &quot;WebReader | None&quot;
    #: Input Path
    filePath: Path
    #: Input file-like object, default is self.filePath.open()
    _source: TextIO
    #: The sequence of Chunk instances being built
    content: list[Chunk]

    def __init__(self, parent: &quot;WebReader | None&quot; = None) -&gt; None:
        self.logger = logging.getLogger(self.__class__.__qualname__)

        self.output_option_parser = argparse.ArgumentParser(add_help=False, exit_on_error=False)
        self.output_option_parser.add_argument(&quot;-start&quot;, dest='start', type=str, default=None)
        self.output_option_parser.add_argument(&quot;-end&quot;, dest='end', type=str, default=&quot;&quot;)
        self.output_option_parser.add_argument(&quot;argument&quot;, type=str, nargs=&quot;*&quot;)

        # TODO: Allow a numeric argument value in ``-indent``
        self.definition_option_parser = argparse.ArgumentParser(add_help=False, exit_on_error=False)
        self.definition_option_parser.add_argument(&quot;-indent&quot;, dest='indent', action='store_true', default=False)
        self.definition_option_parser.add_argument(&quot;-noindent&quot;, dest='noindent', action='store_true', default=False)
        self.definition_option_parser.add_argument(&quot;argument&quot;, type=str, nargs=&quot;*&quot;)

        # Configuration comes from the parent or defaults if there is no parent.
        self.parent = parent
        if self.parent:
            self.command = self.parent.command
            self.permitList = self.parent.permitList
        else: # Defaults until overridden
            self.command = '&#64;'
            self.permitList = []

        # Summary
        self.totalLines = 0
        self.totalFiles = 0
        self.errors = 0


→ <a class="reference internal" href="#webreader-command-literals-49">WebReader command literals (49)</a>

    def __str__(self) -&gt; str:
        return self.__class__.__name__


→ <a class="reference internal" href="#webreader-location-in-the-input-stream-46">WebReader location in the input stream (46)</a>


→ <a class="reference internal" href="#webreader-load-the-web-48">WebReader load the web (48)</a>


→ <a class="reference internal" href="#webreader-handle-a-command-string-35">WebReader handle a command string (35)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>WebReader class - parses the input file, building the Web structure (34)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-33">Base Class Definitions (33)</a>.</div>
<p>The reader maintains a context into which constructs are added.
The <tt class="docutils literal">Web</tt> contains <tt class="docutils literal">Chunk</tt> instances in <tt class="docutils literal">self.web.chunks</tt>.
The current chunk is <tt class="docutils literal"><span class="pre">self.web.chunks[-1]</span></tt>.
Each <tt class="docutils literal">Chunk</tt>, similarly, has a command context in <tt class="docutils literal"><span class="pre">chunk.commands[-1]</span></tt>.</p>
<p>This works because the language is &quot;flat&quot;: there are no nested <tt class="docutils literal">&#64;d</tt> or <tt class="docutils literal">&#64;o</tt>
chunks.</p>
<p>Command recognition is done via a <strong>Chain of Command</strong>-like design.
There are two conditions: the command string is recognized or it is not recognized.
If the command is recognized, <tt class="docutils literal">handleCommand()</tt> will do one of the following:</p>
<ul class="simple">
<li>For &quot;structural&quot; commands, it will attach the current <tt class="docutils literal">Chunk</tt> (<em>self.aChunk</em>) to the
current <tt class="docutils literal">Web</tt> (<em>self.aWeb</em>), and start a new <tt class="docutils literal">Chunk</tt>. This becomes the context
for processing commands. By default an anonymous <tt class="docutils literal">Chunk</tt> used to accumulate text
is available for all of the content outside named chunks.</li>
<li>For &quot;inline&quot; and &quot;content&quot; commands, create a <tt class="docutils literal">Command</tt>, attach it to the current
<tt class="docutils literal">Chunk</tt> (<em>self.aChunk</em>).</li>
</ul>
<p>If the command is not recognized, <tt class="docutils literal">handleCommand()</tt> returns false, and this is a syntax error.</p>
<p>A subclass can override <tt class="docutils literal">handleCommand()</tt> to</p>
<ol class="arabic simple">
<li>Evaluate this superclass version;</li>
<li>If the command is unknown to the superclass,
then the subclass can process it;</li>
<li>If the command is unknown to both classes,
then return <tt class="docutils literal">False</tt>.  Either a subclass will handle it, or the default activity taken
by <tt class="docutils literal">load()</tt> is to treat the command as a syntax error.</li>
</ol>
<p>The <tt class="docutils literal">handleCommand()</tt> implementation is a massive <tt class="docutils literal">match</tt> statement.
It might be a good idea to decompose this into a number of separate methods.
This would make the <tt class="docutils literal">match</tt> statement shorter and easier to understand.</p>
<p class="rubric" id="webreader-handle-a-command-string-35">WebReader handle a command string (35) =</p>
<pre class="code literal-block">
def handleCommand(self, token: str) -&gt; bool:
    self.logger.debug(&quot;Reading %r&quot;, token)
    new_chunk: Chunk | None = None
    match token[:2]:
        case self.cmdo:

→ <a class="reference internal" href="#start-an-outputchunk-adding-it-to-the-web-36">start an OutputChunk, adding it to the web (36)</a>
        case self.cmdd:

→ <a class="reference internal" href="#start-a-namedchunk-or-nameddocumentchunk-adding-it-to-the-web-37">start a NamedChunk or NamedDocumentChunk, adding it to the web (37)</a>
        case self.cmdi:

→ <a class="reference internal" href="#include-another-file-38">include another file (38)</a>
        case self.cmdrcurl | self.cmdrbrak:

→ <a class="reference internal" href="#finish-a-chunk-start-a-new-chunk-adding-it-to-the-web-39">finish a chunk, start a new Chunk adding it to the web (39)</a>
        case self.cmdpipe:

→ <a class="reference internal" href="#assign-user-identifiers-to-the-current-chunk-40">assign user identifiers to the current chunk (40)</a>
        case self.cmdf:
            self.content[-1].commands.append(FileXrefCommand(self.location()))
        case self.cmdm:
            self.content[-1].commands.append(MacroXrefCommand(self.location()))
        case self.cmdu:
            self.content[-1].commands.append(UserIdXrefCommand(self.location()))
        case self.cmdlangl:

→ <a class="reference internal" href="#add-a-reference-command-to-the-current-chunk-41">add a reference command to the current chunk (41)</a>
        case self.cmdlexpr:

→ <a class="reference internal" href="#add-an-expression-command-to-the-current-chunk-43">add an expression command to the current chunk (43)</a>
        case self.cmdcmd:

→ <a class="reference internal" href="#double-at-sign-replacement-append-this-character-to-previous-textcommand-44">double at-sign replacement, append this character to previous TextCommand (44)</a>
        case self.cmdlcurl | self.cmdlbrak:
            # These should have been consumed as part of &#64;o and &#64;d parsing
            self.logger.error(&quot;Extra %r (possibly missing chunk name) near %r&quot;, token, self.location())
            self.errors += 1
        case _:
            return False  # did not recogize the command
    return True  # did recognize the command
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>WebReader handle a command string (35)</em>.
Used by     → <a class="reference internal" href="#webreader-class-parses-the-input-file-building-the-web-structure-34">WebReader class - parses the input file, building the Web structure (34)</a>.</div>
<p>An output chunk has the form <tt class="docutils literal">&#64;o</tt> <em>name</em> <tt class="docutils literal">&#64;{</tt> <em>content</em> <tt class="docutils literal">&#64;}</tt>.
We use the first two tokens to name the <tt class="docutils literal">OutputChunk</tt>.  We expect
the <tt class="docutils literal">&#64;{</tt> separator.  We then attach all subsequent commands
to this chunk while waiting for the final <tt class="docutils literal">&#64;}</tt> token to end the chunk.</p>
<p>We'll use an <tt class="docutils literal">ArgumentParser</tt> to locate the optional parameters.  This will then let
us build an appropriate instance of <tt class="docutils literal">OutputChunk</tt>.</p>
<p>With some small additional changes, we could use <tt class="docutils literal"><span class="pre">OutputChunk(**options)</span></tt>.</p>
<p class="rubric" id="start-an-outputchunk-adding-it-to-the-web-36">start an OutputChunk, adding it to the web (36) =</p>
<pre class="code literal-block">
arg_str = next(self.tokenizer)
self.expect({self.cmdlcurl})
options = self.output_option_parser.parse_args(shlex.split(arg_str))
new_chunk = OutputChunk(
    name=' '.join(options.argument),
    comment_start=options.start if '-start' in options else &quot;# &quot;,
    comment_end=options.end if '-end' in options else &quot;&quot;,
)
self.content.append(new_chunk)
# capture an OutputChunk up to &#64;}
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>start an OutputChunk, adding it to the web (36)</em>.
Used by     → <a class="reference internal" href="#webreader-handle-a-command-string-35">WebReader handle a command string (35)</a>.</div>
<p>A named chunk has the form <tt class="docutils literal">&#64;d</tt> <em>name</em> <tt class="docutils literal">&#64;{</tt> <em>content</em> <tt class="docutils literal">&#64;}</tt> for
code and <tt class="docutils literal">&#64;d</tt> <em>name</em> <tt class="docutils literal">&#64;[</tt> <em>content</em> <tt class="docutils literal">&#64;]</tt> for document source.
We use the first two tokens to name the <tt class="docutils literal">NamedChunk</tt> or <tt class="docutils literal">NamedDocumentChunk</tt>.
We expect either the <tt class="docutils literal">&#64;{</tt> or <tt class="docutils literal">&#64;[</tt> separator, and use the actual
token found to choose which subclass of <tt class="docutils literal">Chunk</tt> to create.
We then attach all subsequent commands
to this chunk while waiting for the final <tt class="docutils literal">&#64;}</tt> or <tt class="docutils literal">&#64;]</tt> token to
end the chunk.</p>
<p>We'll use an <tt class="docutils literal">ArgumentParser</tt> to locate the optional parameter of <tt class="docutils literal"><span class="pre">-noindent</span></tt>.</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 4044)</p>
<p>Unknown directive type &quot;todo&quot;.</p>
<pre class="literal-block">
..  todo:: Extend the ``&#64;d`` argument parser to support ``-indent`` *number*

</pre>
</div>
<p>Then we can use the <tt class="docutils literal">options</tt> value to create an appropriate subclass of <tt class="docutils literal">NamedChunk</tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">`&quot;-indent&quot;</span></tt> is in options, this is the default.
If both are in the options, we should provide a warning.</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 4051)</p>
<p>Unknown directive type &quot;todo&quot;.</p>
<pre class="literal-block">
..  todo:: Add a warning for conflicting options.


</pre>
</div>
<p class="rubric" id="start-a-namedchunk-or-nameddocumentchunk-adding-it-to-the-web-37">start a NamedChunk or NamedDocumentChunk, adding it to the web (37) =</p>
<pre class="code literal-block">
arg_str = next(self.tokenizer)
brack = self.expect({self.cmdlcurl, self.cmdlbrak})
options = self.definition_option_parser.parse_args(shlex.split(arg_str))
name = ' '.join(options.argument)

if brack == self.cmdlbrak:
    new_chunk = NamedDocumentChunk(name)
elif brack == self.cmdlcurl:
    if 'noindent' in options and options.noindent:
        new_chunk = NamedChunk_Noindent(name)
    else:
        new_chunk = NamedChunk(name)
elif brack == None:
    new_chunk = None
    pass  # Error already noted by ``expect()``
else:
    raise RuntimeError(&quot;Design Error&quot;)

if new_chunk:
    self.content.append(new_chunk)
# capture a NamedChunk up to &#64;} or &#64;]
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>start a NamedChunk or NamedDocumentChunk, adding it to the web (37)</em>.
Used by     → <a class="reference internal" href="#webreader-handle-a-command-string-35">WebReader handle a command string (35)</a>.</div>
<p>An import command has the unusual form of <tt class="docutils literal">&#64;i</tt> <em>name</em>, with no trailing
separator.  When we encounter the <tt class="docutils literal">&#64;i</tt> token, the next token will start with the
file name, but may continue with an anonymous chunk.  To avoid confusion,
we require that all <tt class="docutils literal">&#64;i</tt> commands occur at the end of a line,
The break on the <tt class="docutils literal">'\n'</tt> which ends the file name.
This permits file names with embedded spaces. It also permits arguments and options,
if really necessary.</p>
<p>Once we have split the file name away from the rest of the following anonymous chunk,
we push the following token (a <tt class="docutils literal">\n</tt>) back into the token stream, so that it will be the
first token examined at the top of the <tt class="docutils literal">load()</tt> loop.</p>
<p>We create a child <tt class="docutils literal">WebReader</tt> instance to process the included file.  The entire file
is loaded into the current <tt class="docutils literal">Web</tt> instance.  A new, empty <tt class="docutils literal">Chunk</tt> is created at the end
of the file so that processing can resume with an anonymous <tt class="docutils literal">Chunk</tt>.</p>
<p>The reader has a <tt class="docutils literal">permitList</tt> attribute.
This lists any commands where failure is permitted.  Currently, only the <tt class="docutils literal">&#64;i</tt> command
can be set to permit failure; this allows a <tt class="docutils literal">.w</tt> to include
a file that does not yet exist.</p>
<p>The primary use case for this permitted error feature is when weaving test output.
A first use of the <strong>py-web-lp</strong> can be used to tangle the program source files,
ignoring a missing test output file, named in an <tt class="docutils literal">&#64;i</tt> command.
The application can then be run to create the missing test output file.
After this, a second use of the <strong>py-web-lp</strong>
can weave the test output file into a final, complete document.</p>
<p class="rubric" id="include-another-file-38">include another file (38) =</p>
<pre class="code literal-block">
incPath = Path(next(self.tokenizer).strip())
try:
    include = WebReader(parent=self)
    if not incPath.is_absolute():
        incPath = self.base_path / incPath
    self.logger.info(&quot;Including '%s'&quot;, incPath)
    self.content.extend(include.load(incPath))
    self.totalLines += include.tokenizer.lineNumber
    self.totalFiles += include.totalFiles
    if include.errors:
        self.errors += include.errors
        self.logger.error(&quot;Errors in included file '%s', output is incomplete.&quot;, incPath)
except Error as e:
    self.logger.error(&quot;Problems with included file '%s', output is incomplete.&quot;, incPath)
    self.errors += 1
except IOError as e:
    self.logger.error(&quot;Problems finding included file '%s', output is incomplete.&quot;, incPath)
    # Discretionary -- sometimes we want to continue
    if self.cmdi in self.permitList: pass
    else: raise  # Seems heavy-handed, but, the file wasn't found!
# Start a new context for text or commands *after* the ``&#64;i``.
self.content.append(Chunk())
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>include another file (38)</em>.
Used by     → <a class="reference internal" href="#webreader-handle-a-command-string-35">WebReader handle a command string (35)</a>.</div>
<p>When a <tt class="docutils literal">&#64;}</tt> or <tt class="docutils literal">&#64;]</tt> are found, this finishes a named chunk.
The next text is therefore part of an anonymous chunk.</p>
<p>Note that no check is made to assure that the previous <tt class="docutils literal">Chunk</tt> was indeed a named
chunk or output chunk started with <tt class="docutils literal">&#64;{</tt> or <tt class="docutils literal">&#64;[</tt>.
To do this, an attribute would be needed for each <tt class="docutils literal">Chunk</tt> subclass that indicated if a trailing bracket was necessary.
For the base <tt class="docutils literal">Chunk</tt> class, this would be false, but for all other subclasses of
<tt class="docutils literal">Chunk</tt>, this would be true.</p>
<p class="rubric" id="finish-a-chunk-start-a-new-chunk-adding-it-to-the-web-39">finish a chunk, start a new Chunk adding it to the web (39) =</p>
<pre class="code literal-block">
# Start a new context for text or commands *after* this command.
self.content.append(Chunk())
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>finish a chunk, start a new Chunk adding it to the web (39)</em>.
Used by     → <a class="reference internal" href="#webreader-handle-a-command-string-35">WebReader handle a command string (35)</a>.</div>
<p>User identifiers occur after a <tt class="docutils literal">&#64;|</tt> command inside a <tt class="docutils literal">NamedChunk</tt>.</p>
<p>Note that no check is made to assure that the previous <tt class="docutils literal">Chunk</tt> was indeed a named
chunk or output chunk started with <tt class="docutils literal">&#64;{</tt>.
To do this, an attribute would be needed for each <tt class="docutils literal">Chunk</tt> subclass that indicated if user identifiers are permitted.
For the base <tt class="docutils literal">Chunk</tt> class, this would be false, but for the <tt class="docutils literal">NamedChunk</tt> class and
<tt class="docutils literal">OutputChunk</tt> class, this would be true.</p>
<p>User identifiers are name references at the end of a NamedChunk
These are accumulated and expanded by <tt class="docutils literal">&#64;u</tt> reference</p>
<p class="rubric" id="assign-user-identifiers-to-the-current-chunk-40">assign user identifiers to the current chunk (40) =</p>
<pre class="code literal-block">
try:
    names = next(self.tokenizer).strip().split()
    self.content[-1].def_names.extend(names)
except AttributeError:
    # Out of place &#64;| user identifier command
    self.logger.error(&quot;Unexpected references near %r: %r&quot;, self.location(), token)
    self.errors += 1
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>assign user identifiers to the current chunk (40)</em>.
Used by     → <a class="reference internal" href="#webreader-handle-a-command-string-35">WebReader handle a command string (35)</a>.</div>
<p>A reference command has the form <tt class="docutils literal">&#64;&lt;</tt><em>name</em><tt class="docutils literal">&#64;&gt;</tt>.  We accept three
tokens from the input, the middle token is the referenced name.</p>
<p class="rubric" id="add-a-reference-command-to-the-current-chunk-41">add a reference command to the current chunk (41) =</p>
<pre class="code literal-block">
# get the name, introduce into the named Chunk dictionary
name = next(self.tokenizer).strip()
closing = self.expect({self.cmdrangl})
self.content[-1].commands.append(ReferenceCommand(name, self.location()))
self.logger.debug(&quot;Reading %r %r&quot;, name, closing)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>add a reference command to the current chunk (41)</em>.
Used by     → <a class="reference internal" href="#webreader-handle-a-command-string-35">WebReader handle a command string (35)</a>.</div>
<p>An expression command has the form <tt class="docutils literal">&#64;(</tt><em>Python Expression</em><tt class="docutils literal">&#64;)</tt>.
We accept three tokens from the input, the middle token is the expression.</p>
<p>There are two alternative semantics for an embedded expression.</p>
<ul class="simple">
<li><strong>Deferred Execution</strong>.  This requires definition of a new subclass of <tt class="docutils literal">Command</tt>,
<tt class="docutils literal">ExpressionCommand</tt>, and appends it into the current <tt class="docutils literal">Chunk</tt>.  At weave and
tangle time, this expression is evaluated.  The insert might look something like this:
<tt class="docutils literal">aChunk.append(ExpressionCommand(expression, <span class="pre">self.location()))</span></tt>.</li>
<li><strong>Immediate Execution</strong>.  This simply creates a context and evaluates
the Python expression.  The output from the expression becomes a <tt class="docutils literal">TextCommand</tt>, and
is append to the current <tt class="docutils literal">Chunk</tt>.</li>
</ul>
<p>We use the <strong>Immediate Execution</strong> semantics -- the expression is immediately appended
to the current chunk's text.</p>
<p>We provide a few elements of the <tt class="docutils literal">os</tt> module.  We provide <tt class="docutils literal">os.path</tt> library.
The <tt class="docutils literal">os.getcwd()</tt> could be changed to <tt class="docutils literal"><span class="pre">os.path.realpath('.')</span></tt>, but that seems too long-winded.</p>
<p class="rubric" id="imports-42">Imports (42) +=</p>
<pre class="code literal-block">
import builtins
import sys
import platform
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Imports (42)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 4287)</p>
<p>Unknown directive type &quot;todo&quot;.</p>
<pre class="literal-block">
..  todo:: Appending the text should be a method of a ``Chunk`` -- either append text, or append a command.


</pre>
</div>
<p class="rubric" id="add-an-expression-command-to-the-current-chunk-43">add an expression command to the current chunk (43) =</p>
<pre class="code literal-block">
# get the Python expression, create the expression result
expression = next(self.tokenizer)
self.expect({self.cmdrexpr})
try:
    # Build Context
    # **TODO:** Parts of this are static and can be built as part of ``__init__()``.
    dangerous = {
        'breakpoint', 'compile', 'eval', 'exec', 'execfile', 'globals', 'help', 'input',
        'memoryview', 'open', 'print', 'super', '__import__'
    }
    safe = types.SimpleNamespace(**dict(
        (name, obj)
        for name,obj in builtins.__dict__.items()
        if name not in dangerous
    ))
    globals = dict(
        __builtins__=safe,
        os=types.SimpleNamespace(path=os.path, getcwd=os.getcwd, name=os.name),
        time=time,
        datetime=datetime,
        platform=platform,
        theWebReader=self,
        theFile=self.filePath,
        thisApplication=sys.argv[0],
        __version__=__version__,  # Legacy compatibility. Deprecated.
        version=__version__,
        theLocation=str(self.location()),  # The only thing that's dynamic
        )
    # Evaluate
    result = str(eval(expression, globals))
except Exception as exc:
    self.logger.error('Failure to process %r: exception is %r', expression, exc)
    self.errors += 1
    result = f&quot;&#64;({expression!r}: Error {exc!r}&#64;)&quot;
self.content[-1].add_text(result, self.location())
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>add an expression command to the current chunk (43)</em>.
Used by     → <a class="reference internal" href="#webreader-handle-a-command-string-35">WebReader handle a command string (35)</a>.</div>
<p>A double command sequence (<tt class="docutils literal"><span class="pre">'&#64;&#64;'</span></tt>, when the command is an <tt class="docutils literal">'&#64;'</tt>) has the usual meaning of <tt class="docutils literal">'&#64;'</tt> in the input stream.
We do this by appending text to the last command in the current <tt class="docutils literal">Chunk</tt>.
This will append the  character on the end of the most recent <tt class="docutils literal">TextCommand</tt> or <tt class="docutils literal">CodeCommand`</tt>.
If this fails, it will create a new, empty <tt class="docutils literal">TextCommand</tt> or <tt class="docutils literal">CodeCommand</tt>.</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 4346)</p>
<p>Unknown directive type &quot;todo&quot;.</p>
<pre class="literal-block">
..  todo:: Appending a ``'&#64;'`` command character should be a method of a Chunk -- either append text, or append a command.


</pre>
</div>
<p class="rubric" id="double-at-sign-replacement-append-this-character-to-previous-textcommand-44">double at-sign replacement, append this character to previous TextCommand (44) =</p>
<pre class="code literal-block">
self.logger.debug(f&quot;double-command: {self.content[-1]=}&quot;)
self.content[-1].add_text(self.command, self.location())
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>double at-sign replacement, append this character to previous TextCommand (44)</em>.
Used by     → <a class="reference internal" href="#webreader-handle-a-command-string-35">WebReader handle a command string (35)</a>.</div>
<p>The <tt class="docutils literal">expect()</tt> method examines the next token to see if it is the expected item.
Any <tt class="docutils literal">'\n'</tt> characters are absorbed.
If this is not found, a standard type of error message is raised.
This is used by <tt class="docutils literal">handleCommand()</tt>.</p>
<p class="rubric" id="webreader-handle-a-command-string-45">WebReader handle a command string (45) +=</p>
<pre class="code literal-block">
def expect(self, tokens: set[str]) -&gt; str | None:
    &quot;&quot;&quot;Compare next token with expectation, quietly skipping whitespace (i.e., ``\n``).&quot;&quot;&quot;
    try:
        t = next(self.tokenizer)
        while t == '\n':
            t = next(self.tokenizer)
    except StopIteration:
        self.logger.error(&quot;At %r: end of input, %r not found&quot;, self.location(), tokens)
        self.errors += 1
        return None
    if t in tokens:
        return t
    else:
        self.logger.error(&quot;At %r: expected %r, found %r&quot;, self.location(), tokens, t)
        self.errors += 1
        return None
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>WebReader handle a command string (45)</em>.
Used by     → <a class="reference internal" href="#webreader-class-parses-the-input-file-building-the-web-structure-34">WebReader class - parses the input file, building the Web structure (34)</a>.</div>
<p>The <tt class="docutils literal">location()</tt> provides the file name and line number.
This allows error messages as well as tangled or woven output
to correctly reference the original input files.</p>
<p class="rubric" id="webreader-location-in-the-input-stream-46">WebReader location in the input stream (46) =</p>
<pre class="code literal-block">
def location(self) -&gt; tuple[str, int]:
    return (str(self.filePath), self.tokenizer.lineNumber+1)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>WebReader location in the input stream (46)</em>.
Used by     → <a class="reference internal" href="#webreader-class-parses-the-input-file-building-the-web-structure-34">WebReader class - parses the input file, building the Web structure (34)</a>.</div>
<p>The <tt class="docutils literal">load()</tt> method reads the entire input file as a sequence of tokens, split up by the <tt class="docutils literal">Tokenizer</tt>.
Each token that appears to be a command is passed to the <tt class="docutils literal">handleCommand()</tt> method.
If the <tt class="docutils literal">handleCommand()</tt> method returns a True result, the command was recognized and placed in the <tt class="docutils literal">Web</tt>.
If <tt class="docutils literal">handleCommand()</tt> returns a False result, the command was unknown, and we write a warning but treat it as text.</p>
<p>The <tt class="docutils literal">load()</tt> method is used recursively to handle the <tt class="docutils literal">&#64;i</tt> command.
The issue is that it's always loading a single top-level web.</p>
<p class="rubric" id="imports-47">Imports (47) +=</p>
<pre class="code literal-block">
from typing import TextIO, cast
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Imports (47)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p class="rubric" id="webreader-load-the-web-48">WebReader load the web (48) =</p>
<pre class="code literal-block">
def load(self, filepath: Path, source: TextIO | None = None) -&gt; list[Chunk]:
    &quot;&quot;&quot;Returns a flat list of chunks to be made into a Web.
    Also used to expand ``&#64;i`` included files.
    &quot;&quot;&quot;
    self.filePath = filepath
    self.base_path = self.filePath.parent

    if source:
        self._source = source
        self.parse_source()
    else:
        with self.filePath.open() as self._source:
            self.parse_source()
    return self.content

def parse_source(self) -&gt; None:
    &quot;&quot;&quot;Builds a sequence of Chunks.&quot;&quot;&quot;
    self.tokenizer = Tokenizer(self._source, self.command)
    self.totalFiles += 1

    # Initial anonymous chunk.
    self.content = [Chunk()]

    for token in self.tokenizer:
        if len(token) &gt;= 2 and token.startswith(self.command):
            if self.handleCommand(token):
                continue
            else:
                self.logger.error('Unknown &#64;-command in input: %r near %r', token, self.location())
                self.content[-1].add_text(token, self.location())

        elif token:
            # Accumulate a non-empty block of text in the current chunk.
            self.content[-1].add_text(token, self.location())

        else:
            # Whitespace
            pass
    self.logger.debug(&quot;parse_source: [&quot;)
    for c in self.content:
        self.logger.debug(&quot;  %r&quot;, c)
    self.logger.debug(&quot;]&quot;)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>WebReader load the web (48)</em>.
Used by     → <a class="reference internal" href="#webreader-class-parses-the-input-file-building-the-web-structure-34">WebReader class - parses the input file, building the Web structure (34)</a>.</div>
<p>The command character can be changed to permit
some flexibility when working with languages that make extensive use of the <tt class="docutils literal">&#64;</tt> symbol.
The initialization of the <tt class="docutils literal">WebReader</tt> is based on the selected command character.</p>
<p class="rubric" id="webreader-command-literals-49">WebReader command literals (49) =</p>
<pre class="code literal-block">
# Structural (&quot;major&quot;) commands
self.cmdo = self.command+'o'
self.cmdd = self.command+'d'
self.cmdlcurl = self.command+'{'
self.cmdrcurl = self.command+'}'
self.cmdlbrak = self.command+'['
self.cmdrbrak = self.command+']'
self.cmdi = self.command+'i'

# Inline (&quot;minor&quot;) commands
self.cmdlangl = self.command+'&lt;'
self.cmdrangl = self.command+'&gt;'
self.cmdpipe = self.command+'|'
self.cmdlexpr = self.command+'('
self.cmdrexpr = self.command+')'
self.cmdcmd = self.command+self.command

# Content &quot;minor&quot; commands
self.cmdf = self.command+'f'
self.cmdm = self.command+'m'
self.cmdu = self.command+'u'
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>WebReader command literals (49)</em>.
Used by     → <a class="reference internal" href="#webreader-class-parses-the-input-file-building-the-web-structure-34">WebReader class - parses the input file, building the Web structure (34)</a>.</div>
</div>
<div class="section" id="the-tokenizer-class">
<h3><a class="toc-backref" href="#toc-entry-60">The Tokenizer Class</a></h3>
<p>The <tt class="docutils literal">WebReader</tt> requires a tokenizer. The tokenizer breaks the input text into a stream of tokens.
There are two broad classes of tokens:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">r'&#64;.'</span></tt> command tokens, including the structural, inline, and content
commands.</li>
<li><tt class="docutils literal"><span class="pre">r'\n'</span></tt>. Inside text, these matter.
Within structural command tokens, these don't matter.
Except after the filename after an <tt class="docutils literal">&#64;i</tt> command, where one of these end the command.</li>
<li>The remaining text; neither newlines nor commands.</li>
</ul>
<p>The tokenizer works by reading the entire file and splitting on <tt class="docutils literal"><span class="pre">r'&#64;.'</span></tt> patterns.
The <tt class="docutils literal">re.split()</tt> function will separate the input and preserve the actual character sequence on which the input was split.
This breaks the input into blocks of text separated by the <tt class="docutils literal"><span class="pre">r'&#64;.'</span></tt> characters.</p>
<p>For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; pat.split( &quot;&#64;{hi mom&#64;}&quot;)
['', '&#64;{', 'hi mom', '&#64;}', '']
</pre>
<p>This tokenizer splits the input using <tt class="docutils literal"><span class="pre">r'&#64;.|\n'</span></tt>.
The idea is that  we locate commands, newlines and the interstitial text as three classes of tokens.
We can then assemble each <tt class="docutils literal">Command</tt> instance from a short sequence of tokens.
The core <tt class="docutils literal">TextCommand</tt> and <tt class="docutils literal">CodeCommand</tt> will be a line of text ending with the <tt class="docutils literal">\n</tt>.</p>
<p>The tokenizer counts newline characters for us, so that error messages can include a line number.
Also, we can tangle extract comments into a file to reveal source line numbers.</p>
<p>Since the tokenizer is a proper iterator, we can use <tt class="docutils literal">tokens = iter(Tokenizer(source))</tt> and <tt class="docutils literal">next(tokens)</tt> to step through the sequence of tokens until we raise a <tt class="docutils literal">StopIteration</tt>
exception.</p>
<p class="rubric" id="imports-50">Imports (50) +=</p>
<pre class="code literal-block">
import re
from collections.abc import Iterator, Iterable
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Imports (50)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p class="rubric" id="tokenizer-class-breaks-input-into-tokens-51">Tokenizer class - breaks input into tokens (51) =</p>
<pre class="code literal-block">
class Tokenizer(Iterator[str]):
    def __init__(self, stream: TextIO, command_char: str='&#64;') -&gt; None:
        self.command = command_char
        self.parsePat = re.compile(f'({self.command}.|\\n)')
        self.token_iter = (t for t in self.parsePat.split(stream.read()) if len(t) != 0)
        self.lineNumber = 0

    def __next__(self) -&gt; str:
        token = next(self.token_iter)
        self.lineNumber += token.count('\n')
        return token

    def __iter__(self) -&gt; Iterator[str]:
        return self
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Tokenizer class - breaks input into tokens (51)</em>.
Used by     → <a class="reference internal" href="#base-class-definitions-33">Base Class Definitions (33)</a>.</div>
</div>
</div>
<div class="section" id="other-application-components">
<h2><a class="toc-backref" href="#toc-entry-61">Other Application Components</a></h2>
<p>There are a number of other components:</p>
<ul class="simple">
<li><a class="reference internal" href="#error-class">Error class</a> Defines a uniform exception for this module.</li>
<li><a class="reference internal" href="#action-class-hierarchy">Action Class Hierarchy</a> defines the actions the application can perform.
This includes loading the WEB file, weaving, tangling, and doing combinations of actions.</li>
<li><a class="reference internal" href="#the-application-class">The Application Class</a> is a high-level definition of the <strong>py-web-lp</strong> application as a whole.</li>
<li><a class="reference internal" href="#logging-setup">Logging setup</a> defines a handy context manager to configure and shut down logging.</li>
<li><a class="reference internal" href="#the-main-function">The Main Function</a> is a top-level function to create an instance of <tt class="docutils literal">Application</tt>,
and execute it with either supplied arguments or (by default) the actual command-line
arguments. This makes it easy to import and reuse <tt class="docutils literal">main()</tt> in other applications.</li>
</ul>
<div class="section" id="error-class">
<h3><a class="toc-backref" href="#toc-entry-62">Error class</a></h3>
<p>An <tt class="docutils literal">Error</tt> is raised whenever processing cannot continue.
Since it is a subclass of <tt class="docutils literal">Exception</tt>, it takes an arbitrary number of arguments.
The first should be the basic message text.
Subsequent arguments provide additional details.
We will try to be sure that all of our internal exceptions reference a specific chunk, if possible.
This means either including the chunk as an argument, or catching the  exception and appending the current chunk to the exception's arguments.</p>
<p>The Python <tt class="docutils literal">raise</tt> statement takes an instance of <tt class="docutils literal">Error</tt> and passes it to the enclosing <tt class="docutils literal">try/except</tt> statement for processing.</p>
<p>The typical creation is as follows:</p>
<pre class="literal-block">
raise Error(f&quot;no full name for {chunk.name!r}&quot;, chunk)
</pre>
<p>A typical exception-handling suite might look like this:</p>
<pre class="literal-block">
try:
    <em>...something that may raise an Error or Exception...</em>
except Error as e:
    print(e.args) # this is a pyWeb internal Error
except Exception as w:
    print(w.args) # this is some other Python Exception
</pre>
<p>The <tt class="docutils literal">Error</tt> class is a subclass of <tt class="docutils literal">Exception</tt> used to differentiate
application-specific exceptions from other Python exceptions.
It does no additional processing, but merely creates a distinct class to facilitate writing <tt class="docutils literal">except</tt> statements.</p>
<p class="rubric" id="error-class-defines-the-errors-raised-52">Error class defines the errors raised (52) =</p>
<pre class="code literal-block">
class Error(Exception): pass
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Error class defines the errors raised (52)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
</div>
<div class="section" id="action-class-hierarchy">
<h3><a class="toc-backref" href="#toc-entry-63">Action Class Hierarchy</a></h3>
<p>This application performs three major actions: loading the document web, weaving and tangling.
Generally, the use case is to perform a load, weave and tangle.
However, a less common use case is to first load and tangle output files, run a regression test and then load and weave a result that includes the test output file.</p>
<p>The <tt class="docutils literal"><span class="pre">-x</span></tt> option excludes one of the two output actions.
The <tt class="docutils literal"><span class="pre">-xw</span></tt>  excludes the weave pass, doing only the tangle action.
The <tt class="docutils literal"><span class="pre">-xt</span></tt> excludes the tangle pass, doing the weave action.</p>
<p>This two pass action might be embedded in the following type of Python program.</p>
<pre class="literal-block">
import pyweb, os, runpy, sys, pathlib, contextlib
log = pathlib.Path(&quot;source.log&quot;)
Tangler().emit(web)
with log.open(&quot;w&quot;) as target:
    with contextlib.redirect_stdout(target):
        # run the app, capturing the output
        runpy.run_path('source.py')
        # Alternatives include using pytest or doctest
Weaver().emit(web, &quot;something.rst&quot;)
</pre>
<p>The first step runs <strong>py-web-lp</strong> , excluding the final weaving pass.
The second step runs the tangled program, <tt class="docutils literal">source.py</tt>, and produces test results in
some log file, <tt class="docutils literal">source.log</tt>.
The third step runs <strong>py-web-lp</strong>  excluding the tangle pass.
This produces a final document that includes the <tt class="docutils literal">source.log</tt>  test results.</p>
<p>To accomplish this, we provide a class hierarchy that defines the various actions of the <strong>py-web-lp</strong>  application.
This class hierarchy defines an extensible set of fundamental actions.
This gives us the flexibility to create a simple sequence of actions and execute any combination of these.
It eliminates the need for a  forest of <tt class="docutils literal">if</tt>-statements to determine precisely what will be done.</p>
<p>Each action has the potential to update the state of the overall application.
A partner with this command hierarchy is the <tt class="docutils literal">Application</tt> class
that defines the application options, inputs and results.</p>
<p class="rubric" id="action-class-hierarchy-used-to-describe-actions-of-the-application-53">Action class hierarchy used to describe actions of the application (53) =</p>
<pre class="code literal-block">
→ <a class="reference internal" href="#action-superclass-has-common-features-of-all-actions-54">Action superclass has common features of all actions (54)</a>
→ <a class="reference internal" href="#actionsequence-subclass-that-holds-a-sequence-of-other-actions-57">ActionSequence subclass that holds a sequence of other actions (57)</a>
→ <a class="reference internal" href="#weaveaction-subclass-initiates-the-weave-action-60">WeaveAction subclass initiates the weave action (60)</a>
→ <a class="reference internal" href="#tangleaction-subclass-initiates-the-tangle-action-63">TangleAction subclass initiates the tangle action (63)</a>
→ <a class="reference internal" href="#loadaction-subclass-loads-the-document-web-66">LoadAction subclass loads the document web (66)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Action class hierarchy used to describe actions of the application (53)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>The <tt class="docutils literal">Action</tt> class embodies the basic operations of <strong>py-web-lp</strong> .
The intent of this hierarchy is to both provide an easily expanded method of
adding new actions, but an easily specified list of actions for a particular
run of <strong>py-web-lp</strong> .</p>
<p>The overall process of the application is defined by an instance of <tt class="docutils literal">Action</tt>.
This instance may be the <tt class="docutils literal">WeaveAction</tt> instance, the <tt class="docutils literal">TangleAction</tt> instance
or a <tt class="docutils literal">ActionSequence</tt> instance.</p>
<p>The instance is constructed during parsing of the input parameters.
Then the  <tt class="docutils literal">Action</tt> class <tt class="docutils literal">perform()</tt> method is called to actually perform the action.
There are three standard <tt class="docutils literal">Action</tt> instances available: an instance
that is a macro and does both tangling and weaving, an instance that excludes tangling, and an instance that excludes weaving.
These correspond to the command-line options.</p>
<pre class="literal-block">
anOp = SomeAction(&quot;name&quot;)
anOp(<em>argparse.Namespace</em>)
</pre>
<p>The <tt class="docutils literal">Action</tt> is the superclass for all actions.
An <tt class="docutils literal">Action</tt> has a number of common attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">name:</th><td class="field-body">A name for this action.</td>
</tr>
<tr class="field"><th class="field-name">options:</th><td class="field-body">The <tt class="docutils literal">argparse.Namespace</tt> object.
A LoadAction will update this with the <tt class="docutils literal">Web</tt> object that was loaded.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>!start:</dt>
<dd>The time at which the action started.</dd>
</dl>
<p class="rubric" id="action-superclass-has-common-features-of-all-actions-54">Action superclass has common features of all actions (54) =</p>
<pre class="code literal-block">
class Action:
    &quot;&quot;&quot;An action performed by pyWeb.&quot;&quot;&quot;
    start: float
    options: argparse.Namespace

    def __init__(self, name: str) -&gt; None:
        self.name = name
        self.logger = logging.getLogger(self.__class__.__qualname__)

    def __str__(self) -&gt; str:
        return f&quot;{self.name!s} [{self.options.web!s}]&quot;


→ <a class="reference internal" href="#action-call-method-actually-does-the-real-work-55">Action call method actually does the real work (55)</a>


→ <a class="reference internal" href="#action-final-summary-of-what-was-done-56">Action final summary of what was done (56)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Action superclass has common features of all actions (54)</em>.
Used by     → <a class="reference internal" href="#action-class-hierarchy-used-to-describe-actions-of-the-application-53">Action class hierarchy used to describe actions of the application (53)</a>.</div>
<p>The <tt class="docutils literal">__call__()</tt> method does the real work of the action.
For the superclass, it merely logs a message.  This is overridden
by a subclass.</p>
<p class="rubric" id="action-call-method-actually-does-the-real-work-55">Action call method actually does the real work (55) =</p>
<pre class="code literal-block">
def __call__(self, options: argparse.Namespace) -&gt; None:
    self.logger.info(&quot;Starting %s&quot;, self.name)
    self.options = options
    self.start = time.process_time()
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Action call method actually does the real work (55)</em>.
Used by     → <a class="reference internal" href="#action-superclass-has-common-features-of-all-actions-54">Action superclass has common features of all actions (54)</a>.</div>
<p>The <tt class="docutils literal">summary()</tt> method returns some basic processing statistics for this action.</p>
<p class="rubric" id="action-final-summary-of-what-was-done-56">Action final summary of what was done (56) =</p>
<pre class="code literal-block">
def duration(self) -&gt; float:
    &quot;&quot;&quot;Return duration of the action.&quot;&quot;&quot;
    return (self.start and time.process_time()-self.start) or 0

def summary(self) -&gt; str:
    return f&quot;{self.name!s} in {self.duration():0.3f} sec.&quot;
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Action final summary of what was done (56)</em>.
Used by     → <a class="reference internal" href="#action-superclass-has-common-features-of-all-actions-54">Action superclass has common features of all actions (54)</a>.</div>
</div>
<div class="section" id="actionsequence-class">
<h3><a class="toc-backref" href="#toc-entry-64">ActionSequence Class</a></h3>
<p>A <tt class="docutils literal">ActionSequence</tt> defines a composite action; it is a sequence of other actions.
When the macro is performed, it delegates to the  sub-actions.</p>
<p>The instance is created during parsing of input parameters.
An instance of this class is one of the three standard actions available;
it generally is the default, &quot;do everything&quot;  action.</p>
<p>This class overrides the <tt class="docutils literal">perform()</tt> method of the superclass.
It also adds an <tt class="docutils literal">append()</tt> method that is used to construct the sequence of actions.</p>
<p class="rubric" id="actionsequence-subclass-that-holds-a-sequence-of-other-actions-57">ActionSequence subclass that holds a sequence of other actions (57) =</p>
<pre class="code literal-block">
class ActionSequence(Action):
    &quot;&quot;&quot;An action composed of a sequence of other actions.&quot;&quot;&quot;
    def __init__(self, name: str, opSequence: list[Action] | None = None) -&gt; None:
        super().__init__(name)
        if opSequence: self.opSequence = opSequence
        else: self.opSequence = []

    def __str__(self) -&gt; str:
        return &quot;; &quot;.join([str(x) for x in self.opSequence])


→ <a class="reference internal" href="#actionsequence-call-method-delegates-the-sequence-of-ations-58">ActionSequence call method delegates the sequence of ations (58)</a>


→ <a class="reference internal" href="#actionsequence-summary-summarizes-each-step-59">ActionSequence summary summarizes each step (59)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>ActionSequence subclass that holds a sequence of other actions (57)</em>.
Used by     → <a class="reference internal" href="#action-class-hierarchy-used-to-describe-actions-of-the-application-53">Action class hierarchy used to describe actions of the application (53)</a>.</div>
<p>Since the macro <tt class="docutils literal">__call__()</tt> method delegates to other Actions,
it is possible to short-cut argument processing by using the Python
<tt class="docutils literal">*args</tt> construct to accept all arguments and pass them to each
sub-action.</p>
<p class="rubric" id="actionsequence-call-method-delegates-the-sequence-of-ations-58">ActionSequence call method delegates the sequence of ations (58) =</p>
<pre class="code literal-block">
def __call__(self, options: argparse.Namespace) -&gt; None:
    super().__call__(options)
    for o in self.opSequence:
        o(self.options)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>ActionSequence call method delegates the sequence of ations (58)</em>.
Used by     → <a class="reference internal" href="#actionsequence-subclass-that-holds-a-sequence-of-other-actions-57">ActionSequence subclass that holds a sequence of other actions (57)</a>.</div>
<p>The <tt class="docutils literal">summary()</tt> method returns some basic processing
statistics for each step of this action.</p>
<p class="rubric" id="actionsequence-summary-summarizes-each-step-59">ActionSequence summary summarizes each step (59) =</p>
<pre class="code literal-block">
def summary(self) -&gt; str:
    return &quot;, &quot;.join([o.summary() for o in self.opSequence])
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>ActionSequence summary summarizes each step (59)</em>.
Used by     → <a class="reference internal" href="#actionsequence-subclass-that-holds-a-sequence-of-other-actions-57">ActionSequence subclass that holds a sequence of other actions (57)</a>.</div>
</div>
<div class="section" id="weaveaction-class">
<h3><a class="toc-backref" href="#toc-entry-65">WeaveAction Class</a></h3>
<p>The <tt class="docutils literal">WeaveAction</tt> defines the action of weaving.
This action logs a message, and invokes the <tt class="docutils literal">weave()</tt> method of the <tt class="docutils literal">Web</tt> instance.
This method also includes the basic decision on which weaver to use.
If a <tt class="docutils literal">Weaver</tt> was specified on the command line, this instance is used.
Otherwise, the first few characters are examined and a weaver is selected.</p>
<p>This class overrides the <tt class="docutils literal">__call__()</tt> method of the superclass.</p>
<p>If the options include <tt class="docutils literal">theWeaver</tt>, that <tt class="docutils literal">Weaver</tt> instance will be used.
Otherwise, the <tt class="docutils literal">web.language()</tt> method function is used to guess what weaver to use.</p>
<p class="rubric" id="weaveaction-subclass-initiates-the-weave-action-60">WeaveAction subclass initiates the weave action (60) =</p>
<pre class="code literal-block">
class WeaveAction(Action):
    &quot;&quot;&quot;Weave the final document.&quot;&quot;&quot;
    def __init__(self) -&gt; None:
        super().__init__(&quot;Weave&quot;)

    def __str__(self) -&gt; str:
        return f&quot;{self.name!s} [{self.options.web!s}, {self.options.theWeaver!s}]&quot;


→ <a class="reference internal" href="#weaveaction-call-method-to-pick-the-language-61">WeaveAction call method to pick the language (61)</a>


→ <a class="reference internal" href="#weaveaction-summary-of-language-choice-62">WeaveAction summary of language choice (62)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>WeaveAction subclass initiates the weave action (60)</em>.
Used by     → <a class="reference internal" href="#action-class-hierarchy-used-to-describe-actions-of-the-application-53">Action class hierarchy used to describe actions of the application (53)</a>.</div>
<p>The language is picked just prior to weaving.
It is either (1) the language specified on the command line, or, (2) if no language was specified, a language is selected based on the first few characters of the input.</p>
<p>Weaving can only raise an exception when there is a reference to a chunk that
is never defined.</p>
<p class="rubric" id="weaveaction-call-method-to-pick-the-language-61">WeaveAction call method to pick the language (61) =</p>
<pre class="code literal-block">
def __call__(self, options: argparse.Namespace) -&gt; None:
    super().__call__(options)
    if not self.options.weaver:
        # Examine first few chars of first chunk of web to determine language
        self.options.weaver = self.options.web.language()
        self.logger.info(&quot;Using %s&quot;, self.options.theWeaver)
    self.options.theWeaver.output = self.options.output
    try:
        self.options.theWeaver.set_markup(self.options.weaver)
        self.options.theWeaver.emit(self.options.web)
        self.logger.info(&quot;Finished Normally&quot;)
    except Error as e:
        self.logger.error(&quot;Problems weaving document from %r (weave file is faulty).&quot;, self.options.web.web_path)
        #raise
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>WeaveAction call method to pick the language (61)</em>.
Used by     → <a class="reference internal" href="#weaveaction-subclass-initiates-the-weave-action-60">WeaveAction subclass initiates the weave action (60)</a>.</div>
<p>The <tt class="docutils literal">summary()</tt> method returns some basic processing
statistics for the weave action.</p>
<p class="rubric" id="weaveaction-summary-of-language-choice-62">WeaveAction summary of language choice (62) =</p>
<pre class="code literal-block">
def summary(self) -&gt; str:
    if self.options.theWeaver and self.options.theWeaver.linesWritten &gt; 0:
        return (
            f&quot;{self.name!s} {self.options.theWeaver.linesWritten:d} lines in {self.duration():0.3f} sec.&quot;
        )
    return f&quot;did not {self.name!s}&quot;
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>WeaveAction summary of language choice (62)</em>.
Used by     → <a class="reference internal" href="#weaveaction-subclass-initiates-the-weave-action-60">WeaveAction subclass initiates the weave action (60)</a>.</div>
</div>
<div class="section" id="tangleaction-class">
<h3><a class="toc-backref" href="#toc-entry-66">TangleAction Class</a></h3>
<p>The <tt class="docutils literal">TangleAction</tt> defines the action of tangling.
This operation logs a message, and invokes the <tt class="docutils literal">weave()</tt> method of the <tt class="docutils literal">Web</tt> instance.
This method also includes the basic decision on which weaver to use.
If a <tt class="docutils literal">Weaver</tt> was specified on the command line, this instance is used.  Otherwise, the first few characters are examined and a weaver is selected.</p>
<p>This class overrides the <tt class="docutils literal">__call__()</tt> method of the superclass.</p>
<p>The options <strong>must</strong> include <tt class="docutils literal">theTangler</tt>, with the <tt class="docutils literal">Tangler</tt> instance to be used.</p>
<p class="rubric" id="tangleaction-subclass-initiates-the-tangle-action-63">TangleAction subclass initiates the tangle action (63) =</p>
<pre class="code literal-block">
class TangleAction(Action):
    &quot;&quot;&quot;Tangle source files.&quot;&quot;&quot;
    def __init__(self) -&gt; None:
        super().__init__(&quot;Tangle&quot;)


→ <a class="reference internal" href="#tangleaction-call-method-does-tangling-of-the-output-files-64">TangleAction call method does tangling of the output files (64)</a>


→ <a class="reference internal" href="#tangleaction-summary-method-provides-total-lines-tangled-65">TangleAction summary method provides total lines tangled (65)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>TangleAction subclass initiates the tangle action (63)</em>.
Used by     → <a class="reference internal" href="#action-class-hierarchy-used-to-describe-actions-of-the-application-53">Action class hierarchy used to describe actions of the application (53)</a>.</div>
<p>Tangling can only raise an exception when a cross reference request (<tt class="docutils literal">&#64;f</tt>, <tt class="docutils literal">&#64;m</tt> or <tt class="docutils literal">&#64;u</tt>) occurs in a program code chunk.
Program code chunks are defined  with any of <tt class="docutils literal">&#64;d</tt> or <tt class="docutils literal">&#64;o</tt>  and use <tt class="docutils literal">&#64;{</tt> <tt class="docutils literal">&#64;}</tt> brackets.</p>
<p class="rubric" id="tangleaction-call-method-does-tangling-of-the-output-files-64">TangleAction call method does tangling of the output files (64) =</p>
<pre class="code literal-block">
def __call__(self, options: argparse.Namespace) -&gt; None:
    super().__call__(options)
    self.options.theTangler.include_line_numbers = self.options.tangler_line_numbers
    self.options.theTangler.output = self.options.output
    try:
        self.options.theTangler.emit(self.options.web)
    except Error as e:
        self.logger.error(&quot;Problems tangling outputs from %r (tangle files are faulty).&quot;, self.options.web.web_path)
        #raise
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>TangleAction call method does tangling of the output files (64)</em>.
Used by     → <a class="reference internal" href="#tangleaction-subclass-initiates-the-tangle-action-63">TangleAction subclass initiates the tangle action (63)</a>.</div>
<p>The <tt class="docutils literal">summary()</tt> method returns some basic processing
statistics for the tangle action.</p>
<p class="rubric" id="tangleaction-summary-method-provides-total-lines-tangled-65">TangleAction summary method provides total lines tangled (65) =</p>
<pre class="code literal-block">
def summary(self) -&gt; str:
    if self.options.theTangler and self.options.theTangler.linesWritten &gt; 0:
        return (
            f&quot;{self.name!s} {self.options.theTangler.totalLines:d} lines in {self.duration():0.3f} sec.&quot;
        )
    return f&quot;did not {self.name!r}&quot;
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>TangleAction summary method provides total lines tangled (65)</em>.
Used by     → <a class="reference internal" href="#tangleaction-subclass-initiates-the-tangle-action-63">TangleAction subclass initiates the tangle action (63)</a>.</div>
</div>
<div class="section" id="loadaction-class">
<h3><a class="toc-backref" href="#toc-entry-67">LoadAction Class</a></h3>
<p>The <tt class="docutils literal">LoadAction</tt> defines the action of loading the web structure.
This action uses the application's <tt class="docutils literal">webReader</tt> to actually do the load.</p>
<p>An instance is created during parsing of the input parameters.
An instance of this class is part of any of the weave, tangle and &quot;do everything&quot; action.</p>
<p>This class overrides the <tt class="docutils literal">__call__()</tt> method of the superclass.</p>
<p>The options <strong>must</strong> include <tt class="docutils literal">webReader</tt>, with the <tt class="docutils literal">WebReader</tt> instance to be used.</p>
<p class="rubric" id="loadaction-subclass-loads-the-document-web-66">LoadAction subclass loads the document web (66) =</p>
<pre class="code literal-block">
class LoadAction(Action):
    &quot;&quot;&quot;Load the source web.&quot;&quot;&quot;
    def __init__(self) -&gt; None:
        super().__init__(&quot;Load&quot;)

    def __str__(self) -&gt; str:
        return f&quot;Load [{self.webReader!s}, {self.options.web!s}]&quot;


→ <a class="reference internal" href="#loadaction-call-method-loads-the-input-files-67">LoadAction call method loads the input files (67)</a>


→ <a class="reference internal" href="#loadaction-summary-provides-lines-read-68">LoadAction summary provides lines read (68)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>LoadAction subclass loads the document web (66)</em>.
Used by     → <a class="reference internal" href="#action-class-hierarchy-used-to-describe-actions-of-the-application-53">Action class hierarchy used to describe actions of the application (53)</a>.</div>
<p>Trying to load the web involves two steps, either of which can raise
exceptions due to incorrect inputs.</p>
<ol class="arabic simple">
<li>The <tt class="docutils literal">WebReader</tt> class <tt class="docutils literal">load()</tt> method can raise exceptions for a number of
syntax errors as well as OS errors.<ul>
<li>Missing closing brackets (<tt class="docutils literal">&#64;}</tt>, <tt class="docutils literal">&#64;]</tt> or <tt class="docutils literal">&#64;&gt;</tt>).</li>
<li>Missing opening bracket (<tt class="docutils literal">&#64;{</tt> or <tt class="docutils literal">&#64;[</tt>) after a chunk name (<tt class="docutils literal">&#64;d</tt> or <tt class="docutils literal">&#64;o</tt>).</li>
<li>Extra brackets (<tt class="docutils literal">&#64;{</tt>, <tt class="docutils literal">&#64;[</tt>, <tt class="docutils literal">&#64;}</tt>, <tt class="docutils literal">&#64;]</tt>).</li>
<li>Extra <tt class="docutils literal">&#64;|</tt>.</li>
<li>The input file does not exist or is not readable.</li>
</ul>
</li>
<li>The <tt class="docutils literal">Web</tt> class <tt class="docutils literal">createUsedBy()</tt> method can raise an exception when a
chunk reference cannot be resolved to a named chunk.</li>
</ol>
<p class="rubric" id="loadaction-call-method-loads-the-input-files-67">LoadAction call method loads the input files (67) =</p>
<pre class="code literal-block">
def __call__(self, options: argparse.Namespace) -&gt; None:
    super().__call__(options)
    self.webReader = self.options.webReader
    self.webReader.command = self.options.command
    self.webReader.permitList = self.options.permitList
    self.logger.debug(&quot;Reader Class %s&quot;, self.webReader.__class__.__name__)

    error = f&quot;Problems with source file {self.options.source_path!r}, no output produced.&quot;
    try:
        chunks = self.webReader.load(self.options.source_path)
        if self.webReader.errors != 0:
            raise Error(&quot;Syntax Errors in the Web&quot;)
        self.logger.debug(&quot;Read %d Chunks&quot;, len(chunks))
        self.options.web = Web(chunks)
        self.options.web.web_path = self.options.source_path
        self.logger.debug(&quot;Web contains %3d chunks&quot;, len(self.options.web.chunks))
        self.logger.debug(&quot;Web defines  %3d files&quot;, len(self.options.web.files))
        self.logger.debug(&quot;Web defines  %3d macros&quot;, len(self.options.web.macros))
        self.logger.debug(&quot;Web defines  %3d names&quot;, len(self.options.web.userids))
    except Error as e:
        self.logger.error(error)
        raise  # Could not be parsed or built.
    except IOError as e:
        self.logger.error(error)
        raise
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>LoadAction call method loads the input files (67)</em>.
Used by     → <a class="reference internal" href="#loadaction-subclass-loads-the-document-web-66">LoadAction subclass loads the document web (66)</a>.</div>
<p>The <tt class="docutils literal">summary()</tt> method returns some basic processing
statistics for the load action.</p>
<p class="rubric" id="loadaction-summary-provides-lines-read-68">LoadAction summary provides lines read (68) =</p>
<pre class="code literal-block">
def summary(self) -&gt; str:
    return (
        f&quot;{self.name!s} {self.webReader.totalLines:d} lines from {self.webReader.totalFiles:d} files in {self.duration():0.3f} sec.&quot;
    )
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>LoadAction summary provides lines read (68)</em>.
Used by     → <a class="reference internal" href="#loadaction-subclass-loads-the-document-web-66">LoadAction subclass loads the document web (66)</a>.</div>
</div>
<div class="section" id="the-application-class">
<h3><a class="toc-backref" href="#toc-entry-68">The Application Class</a></h3>
<p>The <tt class="docutils literal">Application</tt> class is provided so that the <tt class="docutils literal">Action</tt> instances have an overall application to update.
This allows the <tt class="docutils literal">WeaveAction</tt> to  provide the selected <tt class="docutils literal">Weaver</tt> instance to the application.
It also provides a central location for the various options and alternatives that might be accepted from the command line.</p>
<p>The constructor creates a default <tt class="docutils literal">argparse.Namespace</tt> with values
suitable for weaving and tangling.</p>
<p>The <tt class="docutils literal">parseArgs()</tt> method uses the <tt class="docutils literal">sys.argv</tt> sequence to  parse the command line arguments and update the options.
This allows a program to pre-process the arguments, passing other arguments to this module.</p>
<p>The <tt class="docutils literal">process()</tt> method processes a list of files.
This is either the list of files passed as an argument, or it is the list of files
parsed by the <tt class="docutils literal">parseArgs()</tt> method.</p>
<p>The <tt class="docutils literal">parseArgs()</tt> and process() functions are separated so that
another application can <tt class="docutils literal">import pyweb</tt>, bypass command-line parsing, yet still perform
the basic actionss simply and consistently.
For example:</p>
<pre class="literal-block">
import pyweb, argparse

p = argparse.ArgumentParser()
<em>argument definition</em>
config = p.parse_args()

a = pyweb.Application()
<em>Configure the Application based on options</em>
a.process(config)
</pre>
<p>The <tt class="docutils literal">main()</tt> function creates an <tt class="docutils literal">Application</tt> instance and
calls the <tt class="docutils literal">parseArgs()</tt> and <tt class="docutils literal">process()</tt> methods to provide the
expected default behavior for this module when it is used as the main program.</p>
<p>The configuration can be either a <tt class="docutils literal">types.SimpleNamespace</tt> or an
<tt class="docutils literal">argparse.Namespace</tt> instance.</p>
<p class="rubric" id="imports-69">Imports (69) +=</p>
<pre class="code literal-block">
import argparse
import shlex
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Imports (69)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p class="rubric" id="application-class-for-overall-cli-operation-70">Application Class for overall CLI operation (70) =</p>
<pre class="code literal-block">
class Application:
    def __init__(self, base_config: dict[str, Any] | None = None) -&gt; None:
        self.logger = logging.getLogger(self.__class__.__qualname__)

→ <a class="reference internal" href="#application-default-options-71">Application default options (71)</a>


→ <a class="reference internal" href="#application-parse-command-line-72">Application parse command line (72)</a>


→ <a class="reference internal" href="#application-class-process-all-files-73">Application class process all files (73)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Application Class for overall CLI operation (70)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>The first part of parsing the command line is
setting default values that apply when parameters are omitted.
The default values are set as follows:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">defaults:</th><td class="field-body">A default configuration.</td>
</tr>
<tr class="field"><th class="field-name">webReader:</th><td class="field-body">is the <tt class="docutils literal">WebReader</tt> instance created for the current
input file.</td>
</tr>
<tr class="field"><th class="field-name">doWeave:</th><td class="field-body">instance of <tt class="docutils literal">Action</tt>
that does weaving only.</td>
</tr>
<tr class="field"><th class="field-name">doTangle:</th><td class="field-body">instance of <tt class="docutils literal">Action</tt>
that does tangling only.</td>
</tr>
<tr class="field"><th class="field-name">theAction:</th><td class="field-body">is an instance of <tt class="docutils literal">Action</tt> that describes
the default overall action: load, tangle and weave.  This is the default unless
overridden by an option.</td>
</tr>
</tbody>
</table>
<p>Here are the configuration values. These are attributes
of the <tt class="docutils literal">argparse.namespace</tt> default as well as the updated
namespace returned by <tt class="docutils literal">parseArgs()</tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">verbosity:</th><td class="field-body">Either <tt class="docutils literal">logging.INFO</tt>, <tt class="docutils literal">logging.WARN</tt> or <tt class="docutils literal">logging.DEBUG</tt></td>
</tr>
<tr class="field"><th class="field-name">command:</th><td class="field-body">is set to <tt class="docutils literal">&#64;</tt> as the  default command introducer.</td>
</tr>
<tr class="field"><th class="field-name">permit:</th><td class="field-body">The raw list of permitted command characters, perhaps <tt class="docutils literal">'i'</tt>.</td>
</tr>
<tr class="field"><th class="field-name">permitList:</th><td class="field-body">provides a list of commands that are permitted
to fail.  Typically this is empty, or contains <tt class="docutils literal">&#64;i</tt> to allow the include
command to fail.</td>
</tr>
<tr class="field"><th class="field-name">files:</th><td class="field-body">is the final list of argument files from the command line;
these will be processed unless overridden in the call to <tt class="docutils literal">process()</tt>.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>!skip:</dt>
<dd>a list of steps to skip: perhaps <tt class="docutils literal">'w'</tt> or <tt class="docutils literal">'t'</tt> to skip weaving or tangling.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">weaver:</th><td class="field-body">the short name of the weaver.</td>
</tr>
<tr class="field"><th class="field-name">theTangler:</th><td class="field-body">is set to a <tt class="docutils literal">TanglerMake</tt> instance
to create the output files.</td>
</tr>
<tr class="field"><th class="field-name">theWeaver:</th><td class="field-body">is set to an instance of a subclass of <tt class="docutils literal">Weaver</tt> based on <tt class="docutils literal">weaver</tt></td>
</tr>
</tbody>
</table>
<p class="rubric" id="application-default-options-71">Application default options (71) =</p>
<pre class="code literal-block">
self.defaults = argparse.Namespace(
    verbosity=logging.INFO,
    command='&#64;',
    weaver='rst',
    skip='',  # Don't skip any steps
    permit='',  # Don't tolerate missing includes
    reference='s',  # Simple references
    tangler_line_numbers=False,
    output=Path.cwd() / &quot;docs&quot;,  # Weaving output
    target=Path.cwd(),  # Tangler root directory
    )

# Primitive Actions
self.loadOp = LoadAction()
self.weaveOp = WeaveAction()
self.tangleOp = TangleAction()

# Composite Actions
self.doWeave = ActionSequence(&quot;load and weave&quot;, [self.loadOp, self.weaveOp])
self.doTangle = ActionSequence(&quot;load and tangle&quot;, [self.loadOp, self.tangleOp])
self.theAction = ActionSequence(&quot;load, tangle and weave&quot;, [self.loadOp, self.tangleOp, self.weaveOp])
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Application default options (71)</em>.
Used by     → <a class="reference internal" href="#application-class-for-overall-cli-operation-70">Application Class for overall CLI operation (70)</a>.</div>
<p>The algorithm for parsing the command line parameters uses the built in <tt class="docutils literal">argparse</tt> module.
We have to build a parser, define the options, and the parse the command-line arguments, updating the default namespace.</p>
<p>We further expand on the arguments. This transforms simple strings into object
instances.</p>
<p class="rubric" id="application-parse-command-line-72">Application parse command line (72) =</p>
<pre class="code literal-block">
def parseArgs(self, argv: list[str]) -&gt; argparse.Namespace:
    p = argparse.ArgumentParser()
    p.add_argument(&quot;-v&quot;, &quot;--verbose&quot;, dest=&quot;verbosity&quot;, action=&quot;store_const&quot;, const=logging.INFO)
    p.add_argument(&quot;-s&quot;, &quot;--silent&quot;, dest=&quot;verbosity&quot;, action=&quot;store_const&quot;, const=logging.WARN)
    p.add_argument(&quot;-d&quot;, &quot;--debug&quot;, dest=&quot;verbosity&quot;, action=&quot;store_const&quot;, const=logging.DEBUG)
    p.add_argument(&quot;-c&quot;, &quot;--command&quot;, dest=&quot;command&quot;, action=&quot;store&quot;)
    p.add_argument(&quot;-w&quot;, &quot;--weaver&quot;, dest=&quot;weaver&quot;, action=&quot;store&quot;)
    p.add_argument(&quot;-x&quot;, &quot;--except&quot;, dest=&quot;skip&quot;, action=&quot;store&quot;, choices=('w', 't'))
    p.add_argument(&quot;-p&quot;, &quot;--permit&quot;, dest=&quot;permit&quot;, action=&quot;store&quot;)
    p.add_argument(&quot;-n&quot;, &quot;--linenumbers&quot;, dest=&quot;tangler_line_numbers&quot;, action=&quot;store_true&quot;)
    p.add_argument(&quot;-o&quot;, &quot;--output&quot;, dest=&quot;output&quot;, action=&quot;store&quot;, type=Path, help=&quot;Weaver output&quot;)
    p.add_argument(&quot;-t&quot;, &quot;--target&quot;, dest=&quot;target&quot;, action=&quot;store&quot;, type=Path, help=&quot;Tangler output&quot;)
    p.add_argument(&quot;-V&quot;, &quot;--Version&quot;, action='version', version=f&quot;py-web-lp pyweb.py {__version__}&quot;)
    p.add_argument(&quot;files&quot;, nargs='+', type=Path)
    config = p.parse_args(argv, namespace=self.defaults)
    self.expand(config)
    return config

def expand(self, config: argparse.Namespace) -&gt; argparse.Namespace:
    &quot;&quot;&quot;Translate the argument values from simple text to useful objects.
    Weaver. Tangler. WebReader.

    Note the binding of working directories:

    -   Weaver writes to ``Path.cwd() / &quot;docs&quot;``. The ``-o`` option resets this.
        ``-o .`` is previous version behavior.

    -   Tangler writes to ``Path.cwd()``. Previously, the ``-o`` option reset this.
        Now, there's a ``-t --target`` option for a directory.
    &quot;&quot;&quot;
    # Weaver &amp; Tangler
    config.theWeaver = Weaver(config.output)
    config.theTangler = TanglerMake(config.target)

    # Permitted errors, usual case is ``-pi`` to permit ``&#64;i`` include errors
    if config.permit:
        config.permitList = [f'{config.command!s}{c!s}' for c in config.permit]
    else:
        config.permitList = []

    # Create the configured WebReader
    config.webReader = WebReader()

    return config
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Application parse command line (72)</em>.
Used by     → <a class="reference internal" href="#application-class-for-overall-cli-operation-70">Application Class for overall CLI operation (70)</a>.</div>
<p>The <tt class="docutils literal">process()</tt> function uses the current <tt class="docutils literal">Application</tt> settings
to process each file as follows:</p>
<ol class="arabic simple">
<li>Create a new <tt class="docutils literal">WebReader</tt> for the <tt class="docutils literal">Application</tt>, providing
the parameters required to process the input file.</li>
<li>Create a <tt class="docutils literal">Web</tt> instance, <em>w</em>,
and set the Web's <em>sourceFileName</em> from the WebReader's <em>filePath</em>.</li>
<li>Perform the given command, typically a <tt class="docutils literal">ActionSequence</tt>,
which does some combination of load, tangle the output files and
weave the final document in the target language; if
necessary, examine the <tt class="docutils literal">Web</tt> to determine the documentation language.</li>
<li>Print a performance summary line that shows lines processed per second.</li>
</ol>
<p>In the event of failure in any of the major processing steps, a summary message is produced to clarify the state of the output files, and the exception is reraised.
The re-raising is done so that all exceptions are handled by the outermost main program.</p>
<p class="rubric" id="application-class-process-all-files-73">Application class process all files (73) =</p>
<pre class="code literal-block">
def process(self, config: argparse.Namespace) -&gt; None:
    root = logging.getLogger()
    root.setLevel(config.verbosity)
    self.logger.debug(&quot;Setting root log level to %r&quot;, logging.getLevelName(root.getEffectiveLevel()))

    if config.command:
        self.logger.debug(&quot;Command character %r&quot;, config.command)

    if config.skip:
        if config.skip.lower().startswith('w'):  # not weaving == tangling
            self.theAction = self.doTangle
        elif config.skip.lower().startswith('t'):  # not tangling == weaving
            self.theAction = self.doWeave
        else:
            raise Exception(f&quot;Unknown -x option {config.skip!r}&quot;)

    for f in config.files:
        self.logger.info(&quot;%s %s %r&quot;, self.theAction.name, __version__, f)
        config.source_path = f
        self.theAction(config)
        self.logger.info(self.theAction.summary())
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Application class process all files (73)</em>.
Used by     → <a class="reference internal" href="#application-class-for-overall-cli-operation-70">Application Class for overall CLI operation (70)</a>.</div>
</div>
<div class="section" id="logging-setup">
<h3><a class="toc-backref" href="#toc-entry-69">Logging Setup</a></h3>
<p>We'll create a logging context manager.
This allows us to wrap the <tt class="docutils literal">main()</tt> function in an explicit <tt class="docutils literal">with</tt> statement that assures that logging is configured and cleaned up politely.</p>
<p class="rubric" id="imports-74">Imports (74) +=</p>
<pre class="code literal-block">
import logging
import logging.config
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Imports (74)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>This has two configuration approaches.
If a positional argument is given, that dictionary is used for <tt class="docutils literal">logging.config.dictConfig</tt>.
Otherwise, keyword arguments are provided to <tt class="docutils literal">logging.basicConfig</tt>.</p>
<p>A subclass might properly load a dictionary encoded in TOML or YAML and use that with <tt class="docutils literal">logging.config.dictConfig</tt>.</p>
<p class="rubric" id="logging-setup-75">Logging Setup (75) =</p>
<pre class="code literal-block">
class Logger:
    def __init__(self, dict_config: dict[str, Any] | None = None, **kw_config: Any) -&gt; None:
        self.dict_config = dict_config
        self.kw_config = kw_config

    def __enter__(self) -&gt; &quot;Logger&quot;:
        if self.dict_config:
            logging.config.dictConfig(self.dict_config)
        else:
            logging.basicConfig(**self.kw_config)
        return self

    def __exit__(self, *args: Any) -&gt; Literal[False]:
        logging.shutdown()
        return False
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Logging Setup (75)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>Here's a sample logging setup.
This creates a simple console handler and a formatter that matches the <tt class="docutils literal">basicConfig</tt> formatter.</p>
<p>This configuration dictionary defines the root logger plus some overrides for class loggers that might be used to gather additional information.</p>
<p class="rubric" id="logging-setup-76">Logging Setup (76) +=</p>
<pre class="code literal-block">
default_logging_config = {
    'version': 1,
    'disable_existing_loggers': False, # Allow pre-existing loggers to work.
    'style': '{',
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'stream': 'ext://sys.stderr',
            'formatter': 'basic',
        },
    },
    'formatters': {
        'basic': {
            'format': &quot;{levelname}:{name}:{message}&quot;,
            'style': &quot;{&quot;,
        }
    },

    'root': {'handlers': ['console'], 'level': logging.INFO,},

    # For specific debugging support...
    'loggers': {
        'Weaver': {'level': logging.INFO},
        'WebReader': {'level': logging.INFO},
        'Tangler': {'level': logging.INFO},
        'TanglerMake': {'level': logging.INFO},
        'indent.TanglerMake': {'level': logging.INFO},
        'Web': {'level': logging.INFO},
        # Unit test requires this...
        'ReferenceCommand': {'level': logging.INFO},
    },
}
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Logging Setup (76)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>The above is wired into the application as a default.
Exposing this via a configuration file is better.</p>
<p class="rubric" id="pyweb-toml-77">pyweb.toml (77) =</p>
<pre class="code literal-block">
[pyweb]
# PyWeb options go here.

[logging]
version = 1
disable_existing_loggers = false

[logging.root]
handlers = [ &quot;console&quot;,]
level = &quot;INFO&quot;

[logging.handlers.console]
class = &quot;logging.StreamHandler&quot;
stream = &quot;ext://sys.stderr&quot;
formatter = &quot;basic&quot;

[logging.formatters.basic]
format = &quot;{levelname}:{name}:{message}&quot;
style = &quot;{&quot;

[logging.loggers.Weaver]
level = &quot;INFO&quot;

[logging.loggers.WebReader]
level = &quot;INFO&quot;

[logging.loggers.Tangler]
level = &quot;INFO&quot;

[logging.loggers.TanglerMake]
level = &quot;INFO&quot;

[logging.loggers.indent.TanglerMake]
level = &quot;INFO&quot;

[logging.loggers.ReferenceCommand]
# Unit test requires this...
level = &quot;INFO&quot;
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>pyweb.toml (77)</em>.</div>
<p>We can load this with something like the following:</p>
<pre class="literal-block">
config_path = Path(&quot;pyweb.toml&quot;)
with config_path.open('rb') as config_file:
    config = toml.load(config_file)
log_config = config.get('logging', {'version': 1, level=logging.INFO})
</pre>
<p>This makes it slightly easier to add and change debuging alternatives.
Rather then use the <tt class="docutils literal"><span class="pre">-v</span></tt> and <tt class="docutils literal"><span class="pre">-d</span></tt> options, the <tt class="docutils literal">pyweb.toml</tt>
provides a complete logging config.</p>
<p>Also, we might want a decorator to define loggers more consistently for each class definition.</p>
</div>
<div class="section" id="the-main-function">
<h3><a class="toc-backref" href="#toc-entry-70">The Main Function</a></h3>
<p>The top-level interface is the <tt class="docutils literal">main()</tt> function.
This function creates an <tt class="docutils literal">Application</tt> instance.</p>
<p>The <tt class="docutils literal">Application</tt> object parses the command-line arguments.
Then the <tt class="docutils literal">Application</tt> object does the requested processing.
This two-step process allows for some dependency injection to customize argument processing.</p>
<p>We might also want to parse a logging configuration file, as well
as a weaver template configuration file.</p>
<p class="rubric" id="interface-functions-78">Interface Functions (78) =</p>
<pre class="code literal-block">
def main(argv: list[str] = sys.argv[1:], base_config: dict[str, Any] | None=None) -&gt; None:
    a = Application(base_config)
    config = a.parseArgs(argv)
    a.process(config)
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Interface Functions (78)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
</div>
</div>
<div class="section" id="pyweb-module-file">
<h2><a class="toc-backref" href="#toc-entry-71"><strong>pyWeb</strong> Module File</a></h2>
<p>The <strong>pyWeb</strong> application file is shown below:</p>
<p class="rubric" id="pyweb-py-79">pyweb.py (79) =</p>
<pre class="code literal-block">
→ <a class="reference internal" href="#overheads-81">Overheads (81)</a>
→ <a class="reference internal" href="#imports-2">Imports (2)</a>
→ <a class="reference internal" href="#error-class-defines-the-errors-raised-52">Error class defines the errors raised (52)</a>
→ <a class="reference internal" href="#base-class-definitions-1">Base Class Definitions (1)</a>
→ <a class="reference internal" href="#action-class-hierarchy-used-to-describe-actions-of-the-application-53">Action class hierarchy used to describe actions of the application (53)</a>
→ <a class="reference internal" href="#application-class-for-overall-cli-operation-70">Application Class for overall CLI operation (70)</a>
→ <a class="reference internal" href="#logging-setup-75">Logging Setup (75)</a>
→ <a class="reference internal" href="#interface-functions-78">Interface Functions (78)</a>

if __name__ == &quot;__main__&quot;:
    config_paths = Path(&quot;pyweb.toml&quot;), Path.home()/&quot;pyweb.toml&quot;
    base_config: dict[str, Any] = {}
    for cp in config_paths:
        if cp.exists():
            with cp.open('rb') as config_file:
                base_config = toml.load(config_file)
            break
    log_config = base_config.get('logging', default_logging_config)
    with Logger(log_config):
        main(base_config=base_config.get('pyweb', {}))
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>pyweb.py (79)</em>.</div>
<p>The <a class="reference internal" href="#overheads">Overheads</a> are described below, they include things like:</p>
<ul class="simple">
<li>shell escape</li>
<li>doc string</li>
<li><tt class="docutils literal">__version__</tt> setting</li>
</ul>
<p><a class="reference internal" href="#python-library-imports">Python Library Imports</a> are actually scattered in various places in this description.</p>
<p>The more important elements are described in separate sections:</p>
<ul class="simple">
<li>Base Class Definitions</li>
<li>Application Class and Main Functions</li>
<li>Interface Functions</li>
</ul>
<div class="section" id="python-library-imports">
<h3><a class="toc-backref" href="#toc-entry-72">Python Library Imports</a></h3>
<p>Numerous Python library modules are used by this application.</p>
<p>A few are listed here because they're used widely. Others are listed
closer to where they're referenced.</p>
<ul class="simple">
<li>The <tt class="docutils literal">os</tt> module provide os-specific file and path manipulations; it is used
to transform the input file name into the output file name as well as track down file modification
times.</li>
<li>The <tt class="docutils literal">time</tt> module provides a handy current-time string; this is used
to by the HTML Weaver to write a closing timestamp on generated HTML files,
as well as log messages.</li>
<li>The <tt class="docutils literal">datetime</tt> module is used to format times, phasing out use of <tt class="docutils literal">time</tt>.</li>
<li>The <tt class="docutils literal">types</tt> module is used to get at <tt class="docutils literal">SimpleNamespace</tt> for configuration.</li>
</ul>
<p class="rubric" id="imports-80">Imports (80) +=</p>
<pre class="code literal-block">
import os
import time
import datetime
import sys
import tomllib as toml
import types
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Imports (80)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>Note that <tt class="docutils literal">os.path</tt>, <tt class="docutils literal">time</tt>, <tt class="docutils literal">datetime</tt> and <tt class="docutils literal">platform`</tt>
are provided in the expression context.</p>
</div>
<div class="section" id="overheads">
<h3><a class="toc-backref" href="#toc-entry-73">Overheads</a></h3>
<p>The shell escape is provided so that the user can define this
file as executable, and launch it directly from their shell.
The shell reads the first line of a file; when it finds the <tt class="docutils literal"><span class="pre">'#!'</span></tt> shell
escape, the remainder of the line is taken as the path to the binary program
that should be run.  The shell runs this binary, providing the
file as standard input.</p>
<p class="rubric" id="overheads-81">Overheads (81) =</p>
<pre class="code literal-block">
#!/usr/bin/env python
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Overheads (81)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>A Python <tt class="docutils literal">__doc__</tt> string provides a standard vehicle for documenting
the module or the application program.  The usual style is to provide
a one-sentence summary on the first line.  This is followed by more
detailed usage information.</p>
<p class="rubric" id="overheads-82">Overheads (82) +=</p>
<pre class="code literal-block">
&quot;&quot;&quot;py-web-lp Literate Programming.

Yet another simple literate programming tool derived from **nuweb**,
implemented entirely in Python.
With a suitable configuration, this weaves documents with any markup language,
and tangles source files for any programming language.
&quot;&quot;&quot;
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Overheads (82)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>The keyword cruft is a standard way of placing version control information into
a Python module so it is preserved.  See PEP (Python Enhancement Proposal) #8 for information
on recommended styles.</p>
<p>We also sneak in a &quot;DO NOT EDIT&quot; warning that belongs in all generated application
source files.</p>
<p class="rubric" id="overheads-83">Overheads (83) +=</p>
<pre class="code literal-block">
__version__ = &quot;&quot;&quot;3.3&quot;&quot;&quot;

### DO NOT EDIT THIS FILE!
### It was created by src/pyweb.py, __version__='3.3'.
### From source web/impl.w modified Sat Oct 19 09:03:26 2024.
### In working directory '/Users/slott/Documents/Projects/py-web-tool'.
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>Overheads (83)</em>.
Used by     → <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>.</div>
<p>This can be extended by doing something like the following.</p>
<ol class="arabic simple">
<li>Subclass <tt class="docutils literal">Weaver</tt> create a subclass with different templates.</li>
<li>Update the <tt class="docutils literal">pyweb.weavers</tt> dictionary.</li>
<li>Call <tt class="docutils literal">pyweb.main()</tt> to run the existing
main program with extra classes available to it.</li>
</ol>
<pre class="literal-block">
import pyweb
class MyWeaver(HTML):
   <em>Any template changes</em>

pyweb.weavers['myweaver']= MyWeaver()
pyweb.main()
</pre>
<p>This will create a variant on <strong>py-web-lp</strong> that will handle a different
weaver via the command-line option <tt class="docutils literal"><span class="pre">-w</span> myweaver</tt>.</p>
<!-- py-web-tool/src/test.w -->
</div>
</div>
</div>
<div class="section" id="unit-tests">
<h1><a class="toc-backref" href="#toc-entry-74">Unit Tests</a></h1>
<p>The <tt class="docutils literal">tests</tt> directory includes <tt class="docutils literal">pyweb_test.w</tt>, which will create a
complete test suite.</p>
<p>This source will weaves a <tt class="docutils literal">pyweb_test.html</tt> file. See <a class="reference external" href="tests/pyweb_test.html">tests/pyweb_test.html</a>.</p>
<p>This source will tangle several test modules:  <tt class="docutils literal">test.py</tt>, <tt class="docutils literal">test_tangler.py</tt>, <tt class="docutils literal">test_weaver.py</tt>,
<tt class="docutils literal">test_loader.py</tt>, <tt class="docutils literal">test_unit.py</tt>, and <tt class="docutils literal">test_scripts.py</tt>.</p>
<p>Use <strong>pytest</strong> to discover and run all 80+ test cases.</p>
<p>Here's a script that works out well for running this without disturbing the development
environment. The <tt class="docutils literal">PYTHONPATH</tt> setting is essential to support importing <tt class="docutils literal">pyweb</tt>.</p>
<pre class="literal-block">
python pyweb.py -o tests tests/pyweb_test.w
PYTHONPATH=$(PWD) pytest
</pre>
<p>Note that the last line sets an environment variable and runs
the <tt class="docutils literal">pytest</tt> tool on a single line.</p>
<!-- py-web-tool/src/scripts.w -->
</div>
<div class="section" id="handy-scripts-and-other-files">
<h1><a class="toc-backref" href="#toc-entry-75">Handy Scripts and Other Files</a></h1>
<p>Two aditional scripts, <tt class="docutils literal">tangle.py</tt> and <tt class="docutils literal">weave.py</tt>, are provided as examples
which can be customized and extended.</p>
<div class="section" id="tangle-py-script">
<h2><a class="toc-backref" href="#toc-entry-76"><tt class="docutils literal">tangle.py</tt> Script</a></h2>
<p>This script shows a simple version of Tangling.  This has a permitted
error for '&#64;i' commands to allow an include file (for example test results)
to be omitted from the tangle operation.</p>
<p>Note the general flow of this top-level script.</p>
<ol class="arabic simple">
<li>Create the logging context.</li>
<li>Create the options. This hard-coded object is a stand-in for
parsing command-line options.</li>
<li>Create the web object.</li>
<li>For each action (<tt class="docutils literal">LoadAction</tt> and <tt class="docutils literal">TangleAction</tt> in this example)
Set the web, set the options, execute the callable action, and write
a summary.</li>
</ol>
<p class="rubric" id="tangle-py-84">tangle.py (84) =</p>
<pre class="code literal-block">
#!/usr/bin/env python3
&quot;&quot;&quot;Sample tangle.py script.&quot;&quot;&quot;
import argparse
import logging
from pathlib import Path
import pyweb

def main(source: Path) -&gt; None:
    with pyweb.Logger(pyweb.default_logging_config):
        logger = logging.getLogger(__file__)

        options = argparse.Namespace(
            source_path=source,
            output=source.parent,
            verbosity=logging.INFO,
            command='&#64;',
            permitList=['&#64;i'],
            tangler_line_numbers=False,
            webReader=pyweb.WebReader(),
            theTangler=pyweb.TanglerMake(),
        )

        for action in pyweb.LoadAction(), pyweb.TangleAction():
            action(options)
            logger.info(action.summary())

if __name__ == &quot;__main__&quot;:
    main(Path(&quot;examples/test_rst.w&quot;))
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>tangle.py (84)</em>.</div>
</div>
<div class="section" id="weave-py-script">
<h2><a class="toc-backref" href="#toc-entry-77"><tt class="docutils literal">weave.py</tt> Script</a></h2>
<p>This script shows a simple version of Weaving.  This shows how
to define a customized set of templates for a different markup language.</p>
<p>A customized weaver generally has three parts.</p>
<p class="rubric" id="weave-py-85">weave.py (85) =</p>
<pre class="code literal-block">
→ <a class="reference internal" href="#weave-py-overheads-for-correct-operation-of-a-script-86">weave.py overheads for correct operation of a script (86)</a>

→ <a class="reference internal" href="#weave-py-custom-weaver-definition-to-customize-the-weaver-being-used-87">weave.py custom weaver definition to customize the Weaver being used (87)</a>

→ <a class="reference internal" href="#weaver-py-processing-load-and-weave-the-document-88">weaver.py processing: load and weave the document (88)</a>
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>weave.py (85)</em>.</div>
<p class="rubric" id="weave-py-overheads-for-correct-operation-of-a-script-86">weave.py overheads for correct operation of a script (86) =</p>
<pre class="code literal-block">
#!/usr/bin/env python3
&quot;&quot;&quot;Sample weave.py script.&quot;&quot;&quot;
import argparse
import logging
import string
from pathlib import Path
from textwrap import dedent

import pyweb
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>weave.py overheads for correct operation of a script (86)</em>.
Used by     → <a class="reference internal" href="#weave-py-85">weave.py (85)</a>.</div>
<p>To override templates, a class
needs to provide a text definition of
the Jinja <tt class="docutils literal">{% macro %}</tt> definitions.
This is used to update the superclass
<tt class="docutils literal">template_map</tt>.</p>
<p>Something like the following sets the macros in use.</p>
<pre class="literal-block">
self.template_map['html_macros'] = my_templates
</pre>
<p>Any macro <strong>not</strong> defined gets a default implementation.</p>
<p class="rubric" id="weave-py-custom-weaver-definition-to-customize-the-weaver-being-used-87">weave.py custom weaver definition to customize the Weaver being used (87) =</p>
<pre class="code literal-block">
class MyHTML(pyweb.Weaver):
    bootstrap_html = dedent(&quot;&quot;&quot;
    {%- macro begin_code(chunk) %}
    &lt;div class=&quot;card&quot;&gt;
      &lt;div class=&quot;card-header&quot;&gt;
        &lt;a type=&quot;button&quot; class=&quot;btn btn-primary&quot; name=&quot;pyweb_{{chunk.seq}}&quot;&gt;&lt;/a&gt;
        &lt;!--line number {{chunk.location}}--&gt;
        &lt;p class=&quot;small&quot;&gt;&lt;em&gt;{{chunk.full_name or chunk.name}} ({{chunk.seq}})&lt;/em&gt; {% if chunk.initial %}={% else %}+={% endif %}&lt;/p&gt;
       &lt;/div&gt;
      &lt;div class=&quot;card-body&quot;&gt;
        &lt;pre&gt;&lt;code&gt;
    {%- endmacro -%}

    {%- macro end_code(chunk) %}
        &lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
    &lt;div class=&quot;card-footer&quot;&gt;
      &lt;p&gt;&amp;#8718; &lt;em&gt;{{chunk.full_name or chunk.name}} ({{chunk.seq}})&lt;/em&gt;.
      &lt;/p&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    {% endmacro -%}
    &quot;&quot;&quot;)

    def __init__(self, output: Path = Path.cwd()) -&gt; None:
        super().__init__(output)
        self.template_map = pyweb.Weaver.template_map | {&quot;html_macros&quot;: self.bootstrap_html}
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>weave.py custom weaver definition to customize the Weaver being used (87)</em>.
Used by     → <a class="reference internal" href="#weave-py-85">weave.py (85)</a>.</div>
<p class="rubric" id="weaver-py-processing-load-and-weave-the-document-88">weaver.py processing: load and weave the document (88) =</p>
<pre class="code literal-block">
def main(source: Path) -&gt; None:
    with pyweb.Logger(pyweb.default_logging_config):
        logger = logging.getLogger(__file__)

        options = argparse.Namespace(
            source_path=source,
            output=source.parent,
            verbosity=logging.INFO,
            weaver=&quot;html&quot;,
            command='&#64;',
            permitList=[],
            tangler_line_numbers=False,
            webReader=pyweb.WebReader(),

            theWeaver=MyHTML(),  # Customize with a specific Weaver subclass
        )

        for action in pyweb.LoadAction(), pyweb.WeaveAction():
            action(options)
            logger.info(action.summary())

if __name__ == &quot;__main__&quot;:
    main(Path(&quot;examples/test_rst.w&quot;))
</pre>
<!--  -->
<div class="small docutils container">
∎ <em>weaver.py processing: load and weave the document (88)</em>.
Used by     → <a class="reference internal" href="#weave-py-85">weave.py (85)</a>.</div>
<!-- py-web-tool/src/todo.w -->
</div>
</div>
<div class="section" id="to-do">
<span id="todo"></span><h1><a class="toc-backref" href="#toc-entry-78">To Do</a></h1>
<div class="section" id="restructuring">
<h2><a class="toc-backref" href="#toc-entry-79">Restructuring</a></h2>
<p>Change the directory tree to be more &quot;conventional&quot;.</p>
<ul class="simple">
<li><tt class="docutils literal">docs</tt> Has the woven documentation.</li>
<li><tt class="docutils literal">src</tt> Has the Python application.</li>
<li><tt class="docutils literal">web</tt> Has the included <tt class="docutils literal">.w</tt> files.</li>
<li><tt class="docutils literal">tests</tt> still has the test modules.</li>
</ul>
<p>The <tt class="docutils literal">pyweb</tt> command uses the following approach:</p>
<ol class="arabic simple">
<li>A parent <tt class="docutils literal">.w</tt> file is in the top-level project folder.
This will be the current working directory when tangling or weaving.
A <tt class="docutils literal">pyweb.w</tt> and <tt class="docutils literal">pyweb_test.w</tt> are in the project directory.
This directory also has <tt class="docutils literal">pyproject.toml</tt>, <tt class="docutils literal">README.rst</tt>, etc.</li>
<li>A parent <tt class="docutils literal">.w</tt> file generally uses <tt class="docutils literal">&#64;i web/this.w</tt> to include sections into the overall web.
Any included <tt class="docutils literal">.w</tt> files should come from a <tt class="docutils literal">web</tt> directory, not the top-level directory.</li>
<li>Each <tt class="docutils literal">&#64;o</tt> uses <tt class="docutils literal">&#64;o src/whatever.py</tt> or <tt class="docutils literal">&#64;o tests/test_whatever.py</tt> as part of the filename. No command-line options are required for non-Python tangling.</li>
<li>Weaving has a default directory of <tt class="docutils literal">docs</tt>, possibly overridden by the <tt class="docutils literal"><span class="pre">-o</span></tt> command-line option.</li>
</ol>
<p>This disentangles the current muddle of files found in the <tt class="docutils literal">src</tt> directory.
It also allows tools like <tt class="docutils literal">uv</tt> to work.</p>
</div>
<div class="section" id="additional-features-1">
<h2><a class="toc-backref" href="#toc-entry-80">Additional Features</a></h2>
<p>For writing books, we need two features.</p>
<ol class="arabic">
<li><p class="first">Select one of several alternative <tt class="docutils literal">begin_code()</tt> templates for a named block display.
This could be as sumple as <tt class="docutils literal">&#64;d <span class="pre">-style</span> console</tt> or <tt class="docutils literal">&#64;d <span class="pre">-style</span> code</tt>.</p>
<p>The use case is a book chapter with distinct formatting for REPL examples and code examples.
It may be as small as CSS classes for RST or HTML.
It may be a more elaborate set of differences in LaTeX.</p>
</li>
<li><p class="first">Implement <tt class="docutils literal">&#64;o</tt> command with a <tt class="docutils literal"><span class="pre">-noweave</span></tt> option.
Tangling will create files.
Weaving will ignore this file, producing <strong>no</strong> output.</p>
<p>The use case is a book chapter with numerous examples in the text, but the resulting <tt class="docutils literal">*.py</tt> or <tt class="docutils literal">*.txt</tt> file isn't shown in all of it's glorious detail.
This file is tangled, so the code examples can be tested, but this file is not described anywhere.
See <a class="reference external" href="https://github.com/slott56/py-web-tool/wiki/Tangle-only-Output">https://github.com/slott56/py-web-tool/wiki/Tangle-only-Output</a>.</p>
</li>
</ol>
</div>
<div class="section" id="other-extensions">
<h2><a class="toc-backref" href="#toc-entry-81">Other Extensions</a></h2>
<ol class="arabic simple">
<li>Change the comment start and comment end options
to use Jinja template fragments instead of simple text.
There needs to be an <tt class="docutils literal"><span class="pre">-add</span> '# <span class="pre">{{chunk.position}}'</span></tt>
which overrides the default of <tt class="docutils literal">''</tt> and injects
this into each Tangled chunk. Indented appropriately.</li>
</ol>
<ol class="arabic">
<li><p class="first">Implement all four alternative references in the <tt class="docutils literal">end_code()</tt> macro.</p>
<ul class="simple">
<li>Nothing.</li>
<li>The immediate reference.</li>
<li>The two variants on full paths:<ul>
<li>top-down <tt class="docutils literal">→ Named (1) / → <span class="pre">Sub-Named</span> (2) / → <span class="pre">Sub-Sub-Named</span> (3)</tt></li>
<li>bottom-up <tt class="docutils literal">→ <span class="pre">Sub-Sub-Named</span> (3) ∈ → <span class="pre">Sub-Named</span> (2) ∈ → Named (1)</tt></li>
</ul>
</li>
</ul>
</li>
<li><p class="first">Add commands to define templates in the <tt class="docutils literal">.w</tt> file.</p>
<p>The current templates are defaults.
Additional <tt class="docutils literal">&#64;t</tt> commands define the wrappers applied to <tt class="docutils literal">&#64;d</tt> and <tt class="docutils literal">&#64;o</tt> commands.
The character replacement rules need to be defined as part of the template.
Each template has 3 parts:</p>
<ul class="simple">
<li>Pre-code</li>
<li>Replacement Rules</li>
<li>Post-code</li>
</ul>
<p>This -- in effect -- is a <tt class="docutils literal">macro(chunk, rule)</tt> operation in Jinja.
The macro writes the beginning, applies the rewrite rule to each piece of text, and writes the ending for the code block.</p>
</li>
<li><p class="first">Update the <tt class="docutils literal"><span class="pre">-indent</span></tt> option on <tt class="docutils literal">&#64;d</tt> chunks to accept a numeric argument with the
specific indentation value. This becomes a kind of &quot;noindent&quot; with a given
value. The <tt class="docutils literal"><span class="pre">-noindent</span></tt> would then be the same as <tt class="docutils literal"><span class="pre">-indent</span> 0</tt>.
Currently, <cite>-indent</cite> and <cite>-noindent</cite> are true/false flags.</p>
</li>
</ol>
</div>
<div class="section" id="some-additional-ideas">
<h2><a class="toc-backref" href="#toc-entry-82">Some additional ideas</a></h2>
<ol class="arabic simple">
<li>We might want to decompose the <tt class="docutils literal">impl.w</tt> file: it's huge.
The four major sections -- base model, output, input parsing, other components -- make sense.
However, since the output is a <em>single</em> <tt class="docutils literal">.rst</tt> file, it doesn't change much to do this.</li>
<li>Rename the module from <tt class="docutils literal">pyweb</tt> to <tt class="docutils literal">pylpweb</tt> to avoid name squatting issues.
Rename the project from <tt class="docutils literal"><span class="pre">py-web-lp</span></tt> to <tt class="docutils literal"><span class="pre">py-lpweb</span></tt>.</li>
<li>Offer a basic XHTML template that uses <tt class="docutils literal">CDATA</tt> sections instead of quoting.
Does require the standard quoting for the <tt class="docutils literal">CDATA</tt> end tag.</li>
<li>Note that the overall <tt class="docutils literal">Web</tt> is a bit like a <tt class="docutils literal">NamedChunk</tt> that contains <tt class="docutils literal">Chunks</tt>.
This similarity could be factored out.
While this will create a more proper <strong>Composition</strong> pattern implementation, it
leads to the question of why nest <tt class="docutils literal">&#64;d</tt> or <tt class="docutils literal">&#64;o</tt> chunks in the first place?</li>
</ol>
</div>
<div class="section" id="from-the-code">
<h2><a class="toc-backref" href="#toc-entry-83">From the code</a></h2>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">docs/pyweb.rst</tt>, line 6479)</p>
<p>Unknown directive type &quot;todolist&quot;.</p>
<pre class="literal-block">
..  todolist::


</pre>
</div>
<!-- py-web-tool/src/done.w -->
</div>
</div>
<div class="section" id="change-log">
<h1><a class="toc-backref" href="#toc-entry-84">Change Log</a></h1>
<p>Changes for 3.2</p>
<ul class="simple">
<li>Rename to <tt class="docutils literal"><span class="pre">py-web-lp</span></tt> to limit collisions in PyPI.</li>
<li>Replaced <tt class="docutils literal">toml</tt> with <tt class="docutils literal">tomli</tt> or built-in <tt class="docutils literal">tomllib</tt>.</li>
<li>Fiddle with <tt class="docutils literal">pyproject.toml</tt> and <tt class="docutils literal">tox.ini</tt> to eliminate <tt class="docutils literal">setup.py</tt>.</li>
<li>Replaced home-brewed <tt class="docutils literal">OptionParser</tt> with <tt class="docutils literal">argparse.ArgumentParser</tt>.
Now the options for <tt class="docutils literal">&#64;d</tt> and <tt class="docutils literal">&#64;o</tt> can be <em>much</em> more flexible.</li>
<li>Added the transitive path of references as a Chunk property.
Removes <tt class="docutils literal">SimpleReference</tt> and <tt class="docutils literal">TransitiveReference</tt> classes,
and the associated &quot;reference_style&quot; attribute of a <tt class="docutils literal">Weaver</tt>.
To show transitive references, a revised <tt class="docutils literal">code_end</tt> template is required.</li>
<li>Added a TOML-based configuration file with a <tt class="docutils literal">[logging]</tt> section.</li>
<li>Incorporated Sphinx and PlantUML into the documentation.
Support continues for <tt class="docutils literal">`rst2html.py</tt>. It's used for test documentaion.
See <a class="reference external" href="https://github.com/slott56/py-web-tool/wiki/PlantUML-support-for-RST-%5BCompleted%5D">https://github.com/slott56/py-web-tool/wiki/PlantUML-support-for-RST-%5BCompleted%5D</a></li>
<li>Replaced weaving process with Jinja templates.
See <a class="reference external" href="https://github.com/slott56/py-web-tool/wiki/Jinja-Template-for-Weaving-%5BCompleted%5D">https://github.com/slott56/py-web-tool/wiki/Jinja-Template-for-Weaving-%5BCompleted%5D</a></li>
<li>Dramatic redesign to Class, Chunk, and Command class hierarchies.</li>
<li>Dramatic redesign to Emitters to switch to using Jinja templates.
By stepping away from the <tt class="docutils literal">string.Template</tt>,
we can incorporate list-processing <tt class="docutils literal">{% for <span class="pre">%}...{%</span> endfor %}</tt> construct that
pushes some processing into the template.</li>
<li>Removed <tt class="docutils literal">'\N{LOZENGE}'</tt> (borrowed from Interscript) and use the <tt class="docutils literal">'\N{END OF PROOF}'</tt> symbol instead.</li>
<li>Created a better <tt class="docutils literal">weave.py</tt> example that shows how to incorporate bootstrap CSS into HTML overrides.
This also requires designing a more easily extended <tt class="docutils literal">Weaver</tt> class.</li>
</ul>
<p>Changes for 3.1</p>
<ul class="simple">
<li>Change to Python 3.10 as the supported version.</li>
<li>Add type hints, f-strings, <tt class="docutils literal">pathlib</tt>, <tt class="docutils literal">abc.ABC</tt>.</li>
<li>Replace some complex <tt class="docutils literal">elif</tt> blocks with <tt class="docutils literal">match</tt> statements.</li>
<li>Use <strong>pytest</strong> as a test runner.</li>
<li>Add a <tt class="docutils literal">Makefile</tt>, <tt class="docutils literal">pyproject.toml</tt>, <tt class="docutils literal">requirements.txt</tt> and <tt class="docutils literal"><span class="pre">requirements-dev.txt</span></tt>.</li>
<li>Implement <tt class="docutils literal"><span class="pre">-o</span> dir</tt> option to write output to a directory of choice, simplifying <strong>tox</strong> setup.</li>
<li>Add <tt class="docutils literal">bootstrap</tt> directory with a snapshot of a previous working release to simplify development.</li>
<li>Add Test cases for <tt class="docutils literal">weave.py</tt> and <tt class="docutils literal">tangle.py</tt></li>
<li>Replace hand-build mock classes with <tt class="docutils literal">unittest.mock.Mock</tt> objects</li>
<li>Separate the projec into <tt class="docutils literal">src</tt>, <tt class="docutils literal">tests</tt>, <tt class="docutils literal">examples</tt>. Cleanup <tt class="docutils literal">Makefile</tt>, <tt class="docutils literal">pyproject.toml</tt>, etc.</li>
<li>Silence the ERROR-level logging during testing.</li>
<li>Clean up the examples</li>
</ul>
<p>Changes for 3.0</p>
<ul class="simple">
<li>Move to GitHub</li>
</ul>
<p>Changes for 2.3.2.</p>
<ul class="simple">
<li>Fix all <tt class="docutils literal">{:s}</tt> format strings to be <tt class="docutils literal">{!s}</tt>.</li>
</ul>
<p>Changes for 2.3.1.</p>
<ul class="simple">
<li>Cleanup some stray comment errors.</li>
<li>Revise the documentation structure and organization.</li>
<li>Tweak the error messages.</li>
</ul>
<p>Changes for 2.3.</p>
<ul class="simple">
<li>Changed to Python 3.3 -- Fixed <tt class="docutils literal">except</tt>, <tt class="docutils literal">raise</tt> and <tt class="docutils literal">%</tt>.</li>
<li>Removed <tt class="docutils literal">doWrite()</tt> and simplified <tt class="docutils literal">doOpen()</tt> and <tt class="docutils literal">doClose()</tt>.</li>
<li>Cleaned up RST output to be much nicer.</li>
<li>Change the baseline <tt class="docutils literal">pyweb.w</tt> file to be RST instead of HTML.
docutils required to produce HTML from the woven output.</li>
<li>Removed the unconstrained <tt class="docutils literal">eval()</tt> function. Provided a slim set of globals.
<tt class="docutils literal">os</tt> is really just <tt class="docutils literal">os.path</tt>.
Any <tt class="docutils literal">os.getcwd()</tt> can be changed to <tt class="docutils literal"><span class="pre">os.path.realpath('.')</span></tt>.
<tt class="docutils literal">time</tt> was removed and replaced with <tt class="docutils literal">datetime</tt>.
Any <tt class="docutils literal">time.asctime()</tt> must be <tt class="docutils literal"><span class="pre">datetime.datetime.now().ctime()</span></tt>.</li>
<li>Resolved a small dispute between <tt class="docutils literal">weaveReferenceTo()</tt> (wrong) and <tt class="docutils literal">tangle()</tt> (right).
for NamedChunks. The issue was one of failure to understand the differences
between weaving -- where indentation is localized -- and tangling -- where indentation
must be tracked globally. Root cause was a huge problem in <tt class="docutils literal">codeBlock()</tt> which didn't
really weave properly at all.</li>
<li>Fix the tokenizer and parsing. Stop using a complex tokenizer and use a simpler
iterator over the tokens with <tt class="docutils literal">StopIteration</tt> exception handling.</li>
<li>Replace <tt class="docutils literal">optparse</tt> with <tt class="docutils literal">argparse</tt>.</li>
<li>Get rid of the global <tt class="docutils literal">logger</tt> variable.</li>
<li>Remove the filename as part of <tt class="docutils literal">Web()</tt> initial creation.
A basename comes from the initial <tt class="docutils literal">.w</tt> file loaded by the <tt class="docutils literal">WebReader</tt>.</li>
<li>Fix the Action class hierarchy so that composite actions are simpler.</li>
<li>Change references to return <tt class="docutils literal">Chunk</tt> objects, not <tt class="docutils literal">(name,sequence)</tt> pairs.</li>
<li>Make the ref list separator in <tt class="docutils literal">Weaver reference <span class="pre">summary...</span></tt> a proper template
feature, not a hidden punctuation mark in the code.</li>
<li>Configure <tt class="docutils literal">Web.reference_style</tt> properly so that simple or transitive references
can be included as a command-line option. The default is Simple.
Add the <tt class="docutils literal"><span class="pre">-r</span></tt> option so that <tt class="docutils literal"><span class="pre">-rt</span></tt> includes transitive references.</li>
<li>Reduce the &quot;hard-coded&quot; punctuation. For example, the <tt class="docutils literal">&quot;, &quot;</tt> in
<tt class="docutils literal">&#64;d Web <span class="pre">weave...</span></tt> <tt class="docutils literal">weaveChunk()</tt>.  This was moved into a template.</li>
<li>Add an <tt class="docutils literal">__enter__()</tt> and <tt class="docutils literal">__exit__()</tt> to make an <tt class="docutils literal">Emitter</tt>
into a proper Context Manager that can be used with a <tt class="docutils literal">with</tt> statement.</li>
<li>Add the <tt class="docutils literal"><span class="pre">-n</span></tt> option to include tangler line numbers if the <tt class="docutils literal">&#64;o</tt> includes
the comment characters.</li>
<li>Cleanup the <tt class="docutils literal">TanglerMake</tt> unit tests to remove the <tt class="docutils literal">sleep()</tt>
used to assure that the timestamps really are different.</li>
<li>Cleanup the syntax for adding a comment template to <tt class="docutils literal">&#64;o</tt>. Use <tt class="docutils literal"><span class="pre">-start</span></tt> and <tt class="docutils literal"><span class="pre">-end</span></tt>
before the filename.</li>
<li>Cleanup the syntax for noindent named chunks. Use <tt class="docutils literal"><span class="pre">-noindent</span></tt> before the chunk name.
This creates a distinct <tt class="docutils literal">NamedChunk_Noindent</tt> instance that handles indentation
differently from other <tt class="docutils literal">Chunk</tt> subclasses.</li>
<li>Cleanup the <tt class="docutils literal">TangleAction</tt> summary.</li>
<li>Clean up the error messages. Raising an exception seems
heavy-handed and confusing.  Count errors instead.</li>
</ul>
<p>Changes since version 1.4</p>
<ul class="simple">
<li>Removed home-brewed logger.</li>
<li>Replaced <tt class="docutils literal">getopt</tt> with <tt class="docutils literal">optparse</tt>.</li>
<li>Replaced LaTeX markup.</li>
<li>Corrected significant problems in cross-reference resolution.</li>
<li>Replaced all HTML and LaTeX-specific features with a much simpler template
engine which applies a template to a Chunk.  The Templates are separate
configuration items.  The big issue with templates are conditional processing
and the use of loops to handle multiple references in a transitive closure.
While it's nice to depend on Jinja2, it's also nice to be totally stand-alone.
Sigh.  Choices include the no-logic <tt class="docutils literal">string.Template</tt> in the standard library
or the <tt class="docutils literal">Templite+</tt> Recipe 576663.</li>
<li>Looked at SCons API.  Renamed &quot;Operation&quot; to &quot;Action&quot;; renamed &quot;perform&quot; to &quot;__call__&quot;.
Consider having &quot;__call__&quot; which does logging, then call &quot;execute&quot;.</li>
<li>Eliminated the EmitterFactory; replace this with simple injection of
the proper template configuration.</li>
<li>Removed the <tt class="docutils literal">&#64;O</tt> command; it was essentially a variant template for LaTeX.</li>
<li>Disentangled indentation and quoting in the codeBlock.
Indentation rules vary between Tangling and Weaving.
Quoting is unique to a woven codeBlock.  Fix <tt class="docutils literal">referenceTo()</tt>  to write
indented without code quoting.</li>
<li>Offer a basic RST template.
Note that colorizing may be easier to handle with an RST template.
The weaving markup template degenerates
to <tt class="docutils literal">..&nbsp;&nbsp; <span class="pre">parsed-literal::</span></tt> and indent.  By doing this,
the RST output from <em>pyWeb</em> can be run through DocUtils <tt class="docutils literal">rst2html.py</tt>
or perhaps <em>Sphix</em> to create final HTML. The hard part is the indent.</li>
<li>Tweaked (but didn't fix) ReferenceCommand tangle and all setIndent/clrIndent operations.
Only a ReferenceCommand actually cares about indentation.  And that indentation
is totally based on the &quot;context&quot; plus the text in the Command immediate in front
of the ReferenceCommand.</li>
</ul>
</div>
<div class="section" id="indices">
<h1><a class="toc-backref" href="#toc-entry-85">Indices</a></h1>
<div class="section" id="files">
<h2><a class="toc-backref" href="#toc-entry-86">Files</a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">pyweb.toml:</th><td class="field-body">→ <a class="reference internal" href="#pyweb-toml-77">pyweb.toml (77)</a>:pyweb.py:
→ <a class="reference internal" href="#pyweb-py-79">pyweb.py (79)</a>:tangle.py:
→ <a class="reference internal" href="#tangle-py-84">tangle.py (84)</a>:weave.py:
→ <a class="reference internal" href="#weave-py-85">weave.py (85)</a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="macros">
<h2><a class="toc-backref" href="#toc-entry-87">Macros</a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Action call method actually does the real work:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#action-call-method-actually-does-the-real-work-55">Action call method actually does the real work (55)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Action class hierarchy used to describe actions of the application:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#action-class-hierarchy-used-to-describe-actions-of-the-application-53">Action class hierarchy used to describe actions of the application (53)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Action final summary of what was done:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#action-final-summary-of-what-was-done-56">Action final summary of what was done (56)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Action superclass has common features of all actions:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#action-superclass-has-common-features-of-all-actions-54">Action superclass has common features of all actions (54)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">ActionSequence call method delegates the sequence of ations:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#actionsequence-call-method-delegates-the-sequence-of-ations-58">ActionSequence call method delegates the sequence of ations (58)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">ActionSequence subclass that holds a sequence of other actions:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#actionsequence-subclass-that-holds-a-sequence-of-other-actions-57">ActionSequence subclass that holds a sequence of other actions (57)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">ActionSequence summary summarizes each step:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#actionsequence-summary-summarizes-each-step-59">ActionSequence summary summarizes each step (59)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Application Class for overall CLI operation:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#application-class-for-overall-cli-operation-70">Application Class for overall CLI operation (70)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Application class process all files:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#application-class-process-all-files-73">Application class process all files (73)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Application default options:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#application-default-options-71">Application default options (71)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Application parse command line:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#application-parse-command-line-72">Application parse command line (72)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Base Class Definitions:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#base-class-definitions-1">Base Class Definitions (1)</a>, → <a class="reference internal" href="#base-class-definitions-19">Base Class Definitions (19)</a>, → <a class="reference internal" href="#base-class-definitions-33">Base Class Definitions (33)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Chunk class hierarchy -- used to describe individual chunks:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#chunk-class-hierarchy-used-to-describe-individual-chunks-8">Chunk class hierarchy -- used to describe individual chunks (8)</a>, → <a class="reference internal" href="#chunk-class-hierarchy-used-to-describe-individual-chunks-9">Chunk class hierarchy -- used to describe individual chunks (9)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Command class hierarchy -- used to describe individual commands in a chunk:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#command-class-hierarchy-used-to-describe-individual-commands-in-a-chunk-10">Command class hierarchy -- used to describe individual commands in a chunk (10)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Common base template -- this is used for ALL weaving:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#common-base-template-this-is-used-for-all-weaving-23">Common base template -- this is used for ALL weaving (23)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Debug Templates -- these display debugging information:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#debug-templates-these-display-debugging-information-24">Debug Templates -- these display debugging information (24)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Emitter Superclass:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#emitter-superclass-21">Emitter Superclass (21)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Emitter indent control:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">set, clear and reset:
→ <a class="reference internal" href="#emitter-indent-control-set-clear-and-reset-30">Emitter indent control: set, clear and reset (30)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Emitter write a block of code with proper indents:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#emitter-write-a-block-of-code-with-proper-indents-29">Emitter write a block of code with proper indents (29)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Error class defines the errors raised:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#error-class-defines-the-errors-raised-52">Error class defines the errors raised (52)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">HTML Templates -- emit HTML weave output:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#html-templates-emit-html-weave-output-26">HTML Templates -- emit HTML weave output (26)</a></td>
</tr>
<tr class="field"><th class="field-name">Imports:</th><td class="field-body">→ <a class="reference internal" href="#imports-2">Imports (2)</a>, → <a class="reference internal" href="#imports-11">Imports (11)</a>, → <a class="reference internal" href="#imports-20">Imports (20)</a>, → <a class="reference internal" href="#imports-31">Imports (31)</a>, → <a class="reference internal" href="#imports-42">Imports (42)</a>, → <a class="reference internal" href="#imports-47">Imports (47)</a>, → <a class="reference internal" href="#imports-50">Imports (50)</a>, → <a class="reference internal" href="#imports-69">Imports (69)</a>, → <a class="reference internal" href="#imports-74">Imports (74)</a>, → <a class="reference internal" href="#imports-80">Imports (80)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Interface Functions:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#interface-functions-78">Interface Functions (78)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">LaTeX Templates -- emit LaTeX weave output:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#latex-templates-emit-latex-weave-output-27">LaTeX Templates -- emit LaTeX weave output (27)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">LoadAction call method loads the input files:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#loadaction-call-method-loads-the-input-files-67">LoadAction call method loads the input files (67)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">LoadAction subclass loads the document web:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#loadaction-subclass-loads-the-document-web-66">LoadAction subclass loads the document web (66)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">LoadAction summary provides lines read:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#loadaction-summary-provides-lines-read-68">LoadAction summary provides lines read (68)</a></td>
</tr>
<tr class="field"><th class="field-name">Logging Setup:</th><td class="field-body">→ <a class="reference internal" href="#logging-setup-75">Logging Setup (75)</a>, → <a class="reference internal" href="#logging-setup-76">Logging Setup (76)</a></td>
</tr>
<tr class="field"><th class="field-name">Overheads:</th><td class="field-body">→ <a class="reference internal" href="#overheads-81">Overheads (81)</a>, → <a class="reference internal" href="#overheads-82">Overheads (82)</a>, → <a class="reference internal" href="#overheads-83">Overheads (83)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">RST Templates -- the default weave output:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#rst-templates-the-default-weave-output-25">RST Templates -- the default weave output (25)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">TangleAction call method does tangling of the output files:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#tangleaction-call-method-does-tangling-of-the-output-files-64">TangleAction call method does tangling of the output files (64)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">TangleAction subclass initiates the tangle action:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#tangleaction-subclass-initiates-the-tangle-action-63">TangleAction subclass initiates the tangle action (63)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">TangleAction summary method provides total lines tangled:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#tangleaction-summary-method-provides-total-lines-tangled-65">TangleAction summary method provides total lines tangled (65)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Tangler Subclass -- emits the output files:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#tangler-subclass-emits-the-output-files-28">Tangler Subclass -- emits the output files (28)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">TanglerMake Subclass -- extends Tangler to avoid touching files that didn't change:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#tanglermake-subclass-extends-tangler-to-avoid-touching-files-that-didn-t-change-32">TanglerMake Subclass -- extends Tangler to avoid touching files that didn't change (32)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">The CodeCommand Class:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#the-codecommand-class-16">The CodeCommand Class (16)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">The Command Abstract Base Class:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#the-command-abstract-base-class-13">The Command Abstract Base Class (13)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">The HasText Type Hint -- used instead of another abstract class:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#the-hastext-type-hint-used-instead-of-another-abstract-class-14">The HasText Type Hint -- used instead of another abstract class (14)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">The ReferenceCommand Class:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#the-referencecommand-class-17">The ReferenceCommand Class (17)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">The TextCommand Class:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#the-textcommand-class-15">The TextCommand Class (15)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">The TypeId Class -- to help the template engine:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#the-typeid-class-to-help-the-template-engine-12">The TypeId Class -- to help the template engine (12)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">The XrefCommand Subclasses -- files, macros, and user names:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#the-xrefcommand-subclasses-files-macros-and-user-names-18">The XrefCommand Subclasses -- files, macros, and user names (18)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Tokenizer class - breaks input into tokens:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#tokenizer-class-breaks-input-into-tokens-51">Tokenizer class - breaks input into tokens (51)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">WeaveAction call method to pick the language:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#weaveaction-call-method-to-pick-the-language-61">WeaveAction call method to pick the language (61)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">WeaveAction subclass initiates the weave action:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#weaveaction-subclass-initiates-the-weave-action-60">WeaveAction subclass initiates the weave action (60)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">WeaveAction summary of language choice:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#weaveaction-summary-of-language-choice-62">WeaveAction summary of language choice (62)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Weaver Subclass -- Uses Jinja templates to weave documentation:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#weaver-subclass-uses-jinja-templates-to-weave-documentation-22">Weaver Subclass -- Uses Jinja templates to weave documentation (22)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Web class -- describes the overall &quot;web&quot; of chunks:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#web-class-describes-the-overall-web-of-chunks-3">Web class -- describes the overall &quot;web&quot; of chunks (3)</a>, → <a class="reference internal" href="#web-class-describes-the-overall-web-of-chunks-4">Web class -- describes the overall &quot;web&quot; of chunks (4)</a>, → <a class="reference internal" href="#web-class-describes-the-overall-web-of-chunks-5">Web class -- describes the overall &quot;web&quot; of chunks (5)</a>, → <a class="reference internal" href="#web-class-describes-the-overall-web-of-chunks-6">Web class -- describes the overall &quot;web&quot; of chunks (6)</a>, → <a class="reference internal" href="#web-class-describes-the-overall-web-of-chunks-7">Web class -- describes the overall &quot;web&quot; of chunks (7)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">WebReader class - parses the input file, building the Web structure:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#webreader-class-parses-the-input-file-building-the-web-structure-34">WebReader class - parses the input file, building the Web structure (34)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">WebReader command literals:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#webreader-command-literals-49">WebReader command literals (49)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">WebReader handle a command string:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#webreader-handle-a-command-string-35">WebReader handle a command string (35)</a>, → <a class="reference internal" href="#webreader-handle-a-command-string-45">WebReader handle a command string (45)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">WebReader load the web:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#webreader-load-the-web-48">WebReader load the web (48)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">WebReader location in the input stream:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#webreader-location-in-the-input-stream-46">WebReader location in the input stream (46)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">add a reference command to the current chunk:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#add-a-reference-command-to-the-current-chunk-41">add a reference command to the current chunk (41)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">add an expression command to the current chunk:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#add-an-expression-command-to-the-current-chunk-43">add an expression command to the current chunk (43)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">assign user identifiers to the current chunk:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#assign-user-identifiers-to-the-current-chunk-40">assign user identifiers to the current chunk (40)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">double at-sign replacement, append this character to previous TextCommand:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#double-at-sign-replacement-append-this-character-to-previous-textcommand-44">double at-sign replacement, append this character to previous TextCommand (44)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">finish a chunk, start a new Chunk adding it to the web:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#finish-a-chunk-start-a-new-chunk-adding-it-to-the-web-39">finish a chunk, start a new Chunk adding it to the web (39)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">include another file:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#include-another-file-38">include another file (38)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">start a NamedChunk or NamedDocumentChunk, adding it to the web:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#start-a-namedchunk-or-nameddocumentchunk-adding-it-to-the-web-37">start a NamedChunk or NamedDocumentChunk, adding it to the web (37)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">start an OutputChunk, adding it to the web:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#start-an-outputchunk-adding-it-to-the-web-36">start an OutputChunk, adding it to the web (36)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">weave.py custom weaver definition to customize the Weaver being used:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#weave-py-custom-weaver-definition-to-customize-the-weaver-being-used-87">weave.py custom weaver definition to customize the Weaver being used (87)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">weave.py overheads for correct operation of a script:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#weave-py-overheads-for-correct-operation-of-a-script-86">weave.py overheads for correct operation of a script (86)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">weaver.py processing:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">load and weave the document:
→ <a class="reference internal" href="#weaver-py-processing-load-and-weave-the-document-88">weaver.py processing: load and weave the document (88)</a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="user-identifiers">
<h2><a class="toc-backref" href="#toc-entry-88">User Identifiers</a></h2>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Action:</th><td class="field-body">→ <a class="reference internal" href="#action-superclass-has-common-features-of-all-actions-54">Action superclass has common features of all actions (54)</a></td>
</tr>
<tr class="field"><th class="field-name">ActionSequence:</th><td class="field-body">→ <a class="reference internal" href="#actionsequence-subclass-that-holds-a-sequence-of-other-actions-57">ActionSequence subclass that holds a sequence of other actions (57)</a></td>
</tr>
<tr class="field"><th class="field-name">Application:</th><td class="field-body">→ <a class="reference internal" href="#application-class-for-overall-cli-operation-70">Application Class for overall CLI operation (70)</a></td>
</tr>
<tr class="field"><th class="field-name">Chunk:</th><td class="field-body">→ <a class="reference internal" href="#chunk-class-hierarchy-used-to-describe-individual-chunks-9">Chunk class hierarchy -- used to describe individual chunks (9)</a></td>
</tr>
<tr class="field"><th class="field-name">Error:</th><td class="field-body">→ <a class="reference internal" href="#error-class-defines-the-errors-raised-52">Error class defines the errors raised (52)</a></td>
</tr>
<tr class="field"><th class="field-name">LoadAction:</th><td class="field-body">→ <a class="reference internal" href="#loadaction-subclass-loads-the-document-web-66">LoadAction subclass loads the document web (66)</a></td>
</tr>
<tr class="field"><th class="field-name">NamedChunk:</th><td class="field-body">→ <a class="reference internal" href="#chunk-class-hierarchy-used-to-describe-individual-chunks-9">Chunk class hierarchy -- used to describe individual chunks (9)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">NamedChunk_Noindent:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#chunk-class-hierarchy-used-to-describe-individual-chunks-9">Chunk class hierarchy -- used to describe individual chunks (9)</a></td>
</tr>
<tr class="field"><th class="field-name" colspan="2">NamedDocumentChunk:</th></tr>
<tr class="field"><td>&nbsp;</td><td class="field-body">→ <a class="reference internal" href="#chunk-class-hierarchy-used-to-describe-individual-chunks-9">Chunk class hierarchy -- used to describe individual chunks (9)</a></td>
</tr>
<tr class="field"><th class="field-name">OutputChunk:</th><td class="field-body">→ <a class="reference internal" href="#chunk-class-hierarchy-used-to-describe-individual-chunks-9">Chunk class hierarchy -- used to describe individual chunks (9)</a></td>
</tr>
<tr class="field"><th class="field-name">TangleAction:</th><td class="field-body">→ <a class="reference internal" href="#tangleaction-subclass-initiates-the-tangle-action-63">TangleAction subclass initiates the tangle action (63)</a></td>
</tr>
<tr class="field"><th class="field-name">Tokenizer:</th><td class="field-body">→ <a class="reference internal" href="#tokenizer-class-breaks-input-into-tokens-51">Tokenizer class - breaks input into tokens (51)</a></td>
</tr>
<tr class="field"><th class="field-name">TypeId:</th><td class="field-body">→ <a class="reference internal" href="#the-typeid-class-to-help-the-template-engine-12">The TypeId Class -- to help the template engine (12)</a></td>
</tr>
<tr class="field"><th class="field-name">TypeIdMeta:</th><td class="field-body">→ <a class="reference internal" href="#the-typeid-class-to-help-the-template-engine-12">The TypeId Class -- to help the template engine (12)</a></td>
</tr>
<tr class="field"><th class="field-name">WeaveAction:</th><td class="field-body">→ <a class="reference internal" href="#weaveaction-subclass-initiates-the-weave-action-60">WeaveAction subclass initiates the weave action (60)</a></td>
</tr>
<tr class="field"><th class="field-name">Web:</th><td class="field-body">→ <a class="reference internal" href="#web-class-describes-the-overall-web-of-chunks-3">Web class -- describes the overall &quot;web&quot; of chunks (3)</a>, → <a class="reference internal" href="#web-class-describes-the-overall-web-of-chunks-7">Web class -- describes the overall &quot;web&quot; of chunks (7)</a></td>
</tr>
<tr class="field"><th class="field-name">WebReader:</th><td class="field-body">→ <a class="reference internal" href="#webreader-class-parses-the-input-file-building-the-web-structure-34">WebReader class - parses the input file, building the Web structure (34)</a></td>
</tr>
<tr class="field"><th class="field-name">__version__:</th><td class="field-body">→ <a class="reference internal" href="#overheads-83">Overheads (83)</a></td>
</tr>
<tr class="field"><th class="field-name">addIndent:</th><td class="field-body">→ <a class="reference internal" href="#emitter-indent-control-set-clear-and-reset-30">Emitter indent control: set, clear and reset (30)</a></td>
</tr>
<tr class="field"><th class="field-name">argparse:</th><td class="field-body">→ <a class="reference internal" href="#imports-69">Imports (69)</a></td>
</tr>
<tr class="field"><th class="field-name">builtins:</th><td class="field-body">→ <a class="reference internal" href="#imports-42">Imports (42)</a></td>
</tr>
<tr class="field"><th class="field-name">clrIndent:</th><td class="field-body">→ <a class="reference internal" href="#emitter-indent-control-set-clear-and-reset-30">Emitter indent control: set, clear and reset (30)</a></td>
</tr>
<tr class="field"><th class="field-name">codeBlock:</th><td class="field-body">→ <a class="reference internal" href="#emitter-write-a-block-of-code-with-proper-indents-29">Emitter write a block of code with proper indents (29)</a></td>
</tr>
<tr class="field"><th class="field-name">datetime:</th><td class="field-body">→ <a class="reference internal" href="#imports-80">Imports (80)</a></td>
</tr>
<tr class="field"><th class="field-name">duration:</th><td class="field-body">→ <a class="reference internal" href="#action-final-summary-of-what-was-done-56">Action final summary of what was done (56)</a></td>
</tr>
<tr class="field"><th class="field-name">expand:</th><td class="field-body">→ <a class="reference internal" href="#application-parse-command-line-72">Application parse command line (72)</a></td>
</tr>
<tr class="field"><th class="field-name">expect:</th><td class="field-body">→ <a class="reference internal" href="#webreader-handle-a-command-string-45">WebReader handle a command string (45)</a></td>
</tr>
<tr class="field"><th class="field-name">handleCommand:</th><td class="field-body">→ <a class="reference internal" href="#webreader-handle-a-command-string-35">WebReader handle a command string (35)</a></td>
</tr>
<tr class="field"><th class="field-name">load:</th><td class="field-body">→ <a class="reference internal" href="#webreader-load-the-web-48">WebReader load the web (48)</a></td>
</tr>
<tr class="field"><th class="field-name">location:</th><td class="field-body">→ <a class="reference internal" href="#webreader-location-in-the-input-stream-46">WebReader location in the input stream (46)</a></td>
</tr>
<tr class="field"><th class="field-name">logging:</th><td class="field-body">→ <a class="reference internal" href="#imports-74">Imports (74)</a></td>
</tr>
<tr class="field"><th class="field-name">logging.config:</th><td class="field-body">→ <a class="reference internal" href="#imports-74">Imports (74)</a></td>
</tr>
<tr class="field"><th class="field-name">os:</th><td class="field-body">→ <a class="reference internal" href="#imports-80">Imports (80)</a></td>
</tr>
<tr class="field"><th class="field-name">parse:</th><td class="field-body">→ <a class="reference internal" href="#webreader-load-the-web-48">WebReader load the web (48)</a></td>
</tr>
<tr class="field"><th class="field-name">parseArgs:</th><td class="field-body">→ <a class="reference internal" href="#application-parse-command-line-72">Application parse command line (72)</a></td>
</tr>
<tr class="field"><th class="field-name">perform:</th><td class="field-body">→ <a class="reference internal" href="#action-call-method-actually-does-the-real-work-55">Action call method actually does the real work (55)</a>, → <a class="reference internal" href="#actionsequence-call-method-delegates-the-sequence-of-ations-58">ActionSequence call method delegates the sequence of ations (58)</a>, → <a class="reference internal" href="#weaveaction-call-method-to-pick-the-language-61">WeaveAction call method to pick the language (61)</a>, → <a class="reference internal" href="#tangleaction-call-method-does-tangling-of-the-output-files-64">TangleAction call method does tangling of the output files (64)</a>, → <a class="reference internal" href="#loadaction-call-method-loads-the-input-files-67">LoadAction call method loads the input files (67)</a></td>
</tr>
<tr class="field"><th class="field-name">platform:</th><td class="field-body">→ <a class="reference internal" href="#imports-42">Imports (42)</a></td>
</tr>
<tr class="field"><th class="field-name">process:</th><td class="field-body">→ <a class="reference internal" href="#application-class-process-all-files-73">Application class process all files (73)</a></td>
</tr>
<tr class="field"><th class="field-name">re:</th><td class="field-body">→ <a class="reference internal" href="#imports-50">Imports (50)</a></td>
</tr>
<tr class="field"><th class="field-name">resetIndent:</th><td class="field-body">→ <a class="reference internal" href="#emitter-indent-control-set-clear-and-reset-30">Emitter indent control: set, clear and reset (30)</a></td>
</tr>
<tr class="field"><th class="field-name">setIndent:</th><td class="field-body">→ <a class="reference internal" href="#emitter-indent-control-set-clear-and-reset-30">Emitter indent control: set, clear and reset (30)</a></td>
</tr>
<tr class="field"><th class="field-name">shlex:</th><td class="field-body">→ <a class="reference internal" href="#imports-69">Imports (69)</a></td>
</tr>
<tr class="field"><th class="field-name">summary:</th><td class="field-body">→ <a class="reference internal" href="#action-final-summary-of-what-was-done-56">Action final summary of what was done (56)</a>, → <a class="reference internal" href="#actionsequence-summary-summarizes-each-step-59">ActionSequence summary summarizes each step (59)</a>, → <a class="reference internal" href="#weaveaction-summary-of-language-choice-62">WeaveAction summary of language choice (62)</a>, → <a class="reference internal" href="#tangleaction-summary-method-provides-total-lines-tangled-65">TangleAction summary method provides total lines tangled (65)</a>, → <a class="reference internal" href="#loadaction-summary-provides-lines-read-68">LoadAction summary provides lines read (68)</a></td>
</tr>
<tr class="field"><th class="field-name">sys:</th><td class="field-body">→ <a class="reference internal" href="#imports-42">Imports (42)</a>, → <a class="reference internal" href="#imports-80">Imports (80)</a></td>
</tr>
<tr class="field"><th class="field-name">time:</th><td class="field-body">→ <a class="reference internal" href="#imports-80">Imports (80)</a></td>
</tr>
<tr class="field"><th class="field-name">tomllib:</th><td class="field-body">→ <a class="reference internal" href="#imports-80">Imports (80)</a></td>
</tr>
<tr class="field"><th class="field-name">types:</th><td class="field-body">→ <a class="reference internal" href="#imports-80">Imports (80)</a></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<blockquote class="small">
Created by src/pyweb.py at Sat Oct 19 10:03:42 2024.</blockquote>
<p class="small">Source pyweb.w modified Sat Oct 19 09:44:45 2024.</p>
<blockquote class="small">
<p>pyweb.__version__ '3.3'.</p>
<p>Working directory '/Users/slott/Documents/Projects/py-web-tool'.</p>
</blockquote>
</div>
</div>
</div>
</body>
</html>
