#!/usr/bin/env python
"""py-web-tool Literate Programming.

Yet another simple literate programming tool derived from **nuweb**, 
implemented entirely in Python.
With a suitable configuration, this weaves documents with any markup language,
and tangles source files for any programming language.
"""
__version__ = """3.1"""

### DO NOT EDIT THIS FILE!
### It was created by /Users/slott/Documents/Projects/py-web-tool/bootstrap/pyweb.py, __version__='3.0'.
### From source pyweb.w modified Mon Jun 13 08:52:05 2022.
### In working directory '/Users/slott/Documents/Projects/py-web-tool/src'.

from pathlib import Path
import abc

import string
from textwrap import dedent, indent, shorten

import tempfile
import filecmp

from typing import Pattern, Match, Optional, Any, Literal
import weakref


import builtins
import sys
import platform

from typing import TextIO

import re
from collections.abc import Iterator, Iterable


import shlex


import os
import time
import datetime
import types

import argparse


import logging
import logging.config





class Error(Exception): pass




class Command(abc.ABC):
    """A Command is the lowest level of granularity in the input stream."""
    chunk : "Chunk"
    text : str
    def __init__(self, fromLine: int = 0) -> None:
        self.lineNumber = fromLine+1 # tokenizer is zero-based
        self.logger = logging.getLogger(self.__class__.__qualname__)
        
    def __str__(self) -> str:
        return f"at {self.lineNumber!r}"
        
    def __eq__(self, other: Any) -> bool:
        match other:
            case Command():
                return self.lineNumber == other.lineNumber and self.text == other.text
            case _:
                return NotImplemented
                
        
    def startswith(self, prefix: str) -> bool:
        return False
    def searchForRE(self, rePat: Pattern[str]) -> Match[str] | None:
        return None
    def indent(self) -> int:
        return 0
    

        
    def ref(self, aWeb: "Web") -> str | None:
        return None
        
    @abc.abstractmethod
    def weave(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        ...
        
    @abc.abstractmethod
    def tangle(self, aWeb: "Web", aTangler: "Tangler") -> None:
        ...
    





class TextCommand(Command):
    """A piece of document source text."""
    def __init__(self, text: str, fromLine: int = 0) -> None:
        super().__init__(fromLine)
        self.text = text
    def __str__(self) -> str:
        return f"at {self.lineNumber!r}: {self.text[:32]!r}..."
    def startswith(self, prefix: str) -> bool:
        return self.text.startswith(prefix)
    def searchForRE(self, rePat: Pattern[str]) -> Match[str] | None:
        return rePat.search(self.text)
    def indent(self) -> int:
        if self.text.endswith('\n'):
            return 0
        try:
            last_line = self.text.splitlines()[-1]
            return len(last_line)
        except IndexError:
            return 0
    def weave(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        aWeaver.write(self.text)
    def tangle(self, aWeb: "Web", aTangler: "Tangler") -> None:
        aTangler.write(self.text)




class CodeCommand(TextCommand):
    """A piece of program source code."""
    def weave(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        aWeaver.codeBlock(aWeaver.quote(self.text))
    def tangle(self, aWeb: "Web", aTangler: "Tangler") -> None:
        aTangler.codeBlock(self.text)




class XrefCommand(Command):
    """Any of the Xref-goes-here commands in the input."""
    def __str__(self) -> str:
        return f"at {self.lineNumber!r}: cross reference"
        
    def formatXref(self, xref: dict[str, list[int]], aWeaver: "Weaver") -> None:
        aWeaver.xrefHead()
        for n in sorted(xref):
            aWeaver.xrefLine(n, xref[n])
        aWeaver.xrefFoot()
        
    def tangle(self, aWeb: "Web", aTangler: "Tangler") -> None:
        raise Error('Illegal tangling of a cross reference command.')




class FileXrefCommand(XrefCommand):
    """A FileXref command."""
    def weave(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Weave a File Xref from @o commands."""
        self.formatXref(aWeb.fileXref(), aWeaver)




class MacroXrefCommand(XrefCommand):
    """A MacroXref command."""
    def weave(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Weave the Macro Xref from @d commands."""
        self.formatXref(aWeb.chunkXref(), aWeaver)




class UserIdXrefCommand(XrefCommand):
    """A UserIdXref command."""
    def weave(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Weave a user identifier Xref from @d commands."""
        ux = aWeb.userNamesXref()
        if len(ux) != 0:
            aWeaver.xrefHead()
            for u in sorted(ux):
                defn, refList = ux[u]
                aWeaver.xrefDefLine(u, defn, refList)
            aWeaver.xrefFoot()
        else:
            aWeaver.xrefEmpty()




class ReferenceCommand(Command):
    """A reference to a named chunk, via @<name@>."""
    def __init__(self, refTo: str, fromLine: int = 0) -> None:
        super().__init__(fromLine)
        self.refTo = refTo
        self.fullname = None
        self.sequenceList = None
        self.chunkList: list[Chunk] = []
        
    def __str__(self) -> str:
        return "at {self.lineNumber!r}: reference to chunk {self.refTo!r}"
        
        
    def resolve(self, aWeb: "Web") -> None:
        """Expand our chunk name and list of parts"""
        self.fullName = aWeb.fullNameFor(self.refTo)
        self.chunkList = aWeb.getchunk(self.refTo)
    

        
    def ref(self, aWeb: "Web") -> str:
        """Find and return the full name for this reference."""
        self.resolve(aWeb)
        return self.fullName
    

        
    def weave(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Create the nicely formatted reference to a chunk of code."""
        self.resolve(aWeb)
        aWeb.weaveChunk(self.fullName, aWeaver)
    

        
    def tangle(self, aWeb: "Web", aTangler: "Tangler") -> None:
        """Create source code."""
        self.resolve(aWeb)
        
        self.logger.debug("Indent %r + %r", aTangler.context, self.chunk.previous_command.indent())    
        self.chunk.reference_indent(aWeb, aTangler, self.chunk.previous_command.indent())
        
        self.logger.debug("Tangling %r with chunks %r", self.fullName, self.chunkList)
        if len(self.chunkList) != 0:
            for p in self.chunkList:
                p.tangle(aWeb, aTangler)
        else:
            raise Error(f"Attempt to tangle an undefined Chunk, {self.fullName!s}.")
    
        self.chunk.reference_dedent(aWeb, aTangler)
    







class Chunk:
    """Anonymous piece of input file: will be output through the weaver only."""
    web: weakref.ReferenceType["Web"]
    previous_command: "Command"
    initial: bool
    filePath: Path
    
    def __init__(self) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)
        self.commands: list["Command"] = []  # The list of children of this chunk
        self.user_id_list: list[str] = []
        self.name: str = ""
        self.fullName: str = ""
        self.seq: int = 0
        self.referencedBy: list[Chunk] = []  # Chunks which reference this chunk.  Ideally just one.
        self.references_list: list[str] = []  # Names that this chunk references
        self.refCount = 0
        
    def __str__(self) -> str:
        return "\n".join(map(str, self.commands))
    def __repr__(self) -> str:
        return f"{self.__class__.__name__!s}({self.name!r})"
    def __eq__(self, other: Any) -> bool:
        match other:
            case Chunk():
                return self.name == other.name and self.commands == other.commands
            case _:
                return NotImplemented
        
        
    def append(self, command: Command) -> None:
        """Add another Command to this chunk."""
        self.commands.append(command)
        command.chunk = self
    

        
    def appendText(self, text: str, lineNumber: int = 0) -> None:
        """Append a string to the most recent TextCommand."""
        match self.commands:
            case [*Command, TextCommand()]:
                self.commands[-1].text += text
            case _:
                self.commands.append(self.makeContent(text, lineNumber))
    

        
    def webAdd(self, web: "Web") -> None:
        """Add self to a Web as anonymous chunk."""
        web.add(self)
    

    
        
    def genReferences(self, aWeb: "Web") -> Iterator[str]:
        """Generate references from this Chunk."""
        try:
            for t in self.commands:
                ref = t.ref(aWeb)
                if ref is not None:
                    yield ref
        except Error as e:
            raise
    

        
    def makeContent(self, text: str, lineNumber: int = 0) -> Command:
        return TextCommand(text, lineNumber)
    

        
    def startswith(self, prefix: str) -> bool:
        """Examine the first command's starting text."""
        return len(self.commands) >= 1 and self.commands[0].startswith(prefix)
    
    def searchForRE(self, rePat: Pattern[str]) -> Optional["Chunk"]:
        """Visit each command, applying the pattern."""
        for c in self.commands:
            if c.searchForRE(rePat):
                return self
        return None
    
    @property
    def lineNumber(self) -> int | None:
        """Return the first command's line number or None."""
        return self.commands[0].lineNumber if len(self.commands) >= 1 else None
    
    def setUserIDRefs(self, text: str) -> None:
        """Used by NamedChunk subclass."""
        pass
        
    def getUserIDRefs(self) -> list[str]:
        """Used by NamedChunk subclass."""
        return []
    

        
    def references(self, theWeaver: "Weaver") -> list[tuple[str, int]]:
        """Extract name, sequence from Chunks into a list."""
        return [ 
            (c.name, c.seq) 
            for c in theWeaver.reference_style.chunkReferencedBy(self) 
        ]

    
        
    def weave(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Create the nicely formatted document from an anonymous chunk."""
        aWeaver.docBegin(self)
        for cmd in self.commands:
            cmd.weave(aWeb, aWeaver)
        aWeaver.docEnd(self)
    def weaveReferenceTo(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Create a reference to this chunk -- except for anonymous chunks."""
        raise Exception( "Cannot reference an anonymous chunk.""")
    def weaveShortReferenceTo(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Create a short reference to this chunk -- except for anonymous chunks."""
        raise Exception( "Cannot reference an anonymous chunk.""")
    

        
    def tangle(self, aWeb: "Web", aTangler: "Tangler") -> None:
        """Create source code -- except anonymous chunks should not be tangled"""
        raise Error('Cannot tangle an anonymous chunk', self)
    

        
    def reference_indent(self, aWeb: "Web", aTangler: "Tangler", amount: int) -> None:
        aTangler.addIndent(amount)  # Or possibly set indent to local zero.
        
    def reference_dedent(self, aWeb: "Web", aTangler: "Tangler") -> None:
        aTangler.clrIndent()





class NamedChunk(Chunk):
    """Named piece of input file: will be output as both tangler and weaver."""
    def __init__(self, name: str) -> None:
        super().__init__()
        self.name = name
        self.user_id_list = []
        self.refCount = 0
        
    def __str__(self) -> str:
        return f"{self.name!r}: {self!s}"
        
    def makeContent(self, text: str, lineNumber: int = 0) -> Command:
        return CodeCommand(text, lineNumber)
        
        
    def setUserIDRefs(self, text: str) -> None:
        """Save user ID's associated with this chunk."""
        self.user_id_list = text.split()
    def getUserIDRefs(self) -> list[str]:
        return self.user_id_list
    

        
    def webAdd(self, web: "Web") -> None:
        """Add self to a Web as named chunk, update xrefs."""
        web.addNamed(self)
    

        
    def weave(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Create the nicely formatted document from a chunk of code."""
        self.fullName = aWeb.fullNameFor(self.name)
        aWeaver.addIndent()
        aWeaver.codeBegin(self)
        for cmd in self.commands:
            cmd.weave(aWeb, aWeaver)
        aWeaver.clrIndent( )
        aWeaver.codeEnd(self)
    def weaveReferenceTo(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Create a reference to this chunk."""
        self.fullName = aWeb.fullNameFor(self.name)
        txt = aWeaver.referenceTo(self.fullName, self.seq)
        aWeaver.codeBlock(txt)
    def weaveShortReferenceTo(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Create a shortened reference to this chunk."""
        txt = aWeaver.referenceTo(None, self.seq)
        aWeaver.codeBlock(txt)
    

        
    def tangle(self, aWeb: "Web", aTangler: "Tangler") -> None:
        """Create source code.
        Use aWeb to resolve @<namedChunk@>.
        Format as correctly indented source text
        """
        self.previous_command = TextCommand("", self.commands[0].lineNumber)
        aTangler.codeBegin(self)
        for t in self.commands:
            try:
                t.tangle(aWeb, aTangler)
            except Error as e:
                raise
            self.previous_command = t
        aTangler.codeEnd(self)
    



class NamedChunk_Noindent(NamedChunk):
    """Named piece of input file: will be output as both tangler and weaver."""
    def reference_indent(self, aWeb: "Web", aTangler: "Tangler", amount: int) -> None:
        aTangler.setIndent(0)
    
    def reference_dedent(self, aWeb: "Web", aTangler: "Tangler") -> None:
        aTangler.clrIndent()



class OutputChunk(NamedChunk):
    """Named piece of input file, defines an output tangle."""
    def __init__(self, name: str, comment_start: str = "", comment_end: str = "") -> None:
        super().__init__(name)
        self.comment_start = comment_start
        self.comment_end = comment_end
        
    def webAdd(self, web: "Web") -> None:
        """Add self to a Web as output chunk, update xrefs."""
        web.addOutput(self)
    

        
    def weave(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Create the nicely formatted document from a chunk of code."""
        self.fullName = aWeb.fullNameFor(self.name)
        aWeaver.fileBegin(self)
        for cmd in self.commands:
            cmd.weave(aWeb, aWeaver)
        aWeaver.fileEnd(self)
    

        
    def tangle(self, aWeb: "Web", aTangler: "Tangler") -> None:
        aTangler.comment_start = self.comment_start
        aTangler.comment_end = self.comment_end
        super().tangle(aWeb, aTangler)





class NamedDocumentChunk(NamedChunk):
    """Named piece of input file with document source, defines an output tangle."""
    
    def makeContent(self, text: str, lineNumber: int = 0) -> Command:
        return TextCommand(text, lineNumber)
        
        
    def weave(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """Ignore this when producing the document."""
        pass
    def weaveReferenceTo(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """On a reference to this chunk, expand the body in place."""
        for cmd in self.commands:
            cmd.weave(aWeb, aWeaver)
    def weaveShortReferenceTo(self, aWeb: "Web", aWeaver: "Weaver") -> None:
        """On a reference to this chunk, expand the body in place."""
        self.weaveReferenceTo(aWeb, aWeaver)
    

        
    def tangle(self, aWeb: "Web", aTangler: "Tangler") -> None:
        """Raise an exception on an attempt to tangle."""
        raise Error("Cannot tangle a chunk defined with @[.""")
    






class Web:
    """The overall Web of chunks."""
    def __init__(self, file_path: Path | None = None) -> None:
        self.web_path = file_path
        self.chunkSeq: list[Chunk] = [] 
        self.output: dict[str, list[Chunk]] = {} # Map filename to Chunk
        self.named: dict[str, list[Chunk]] = {} # Map chunkname to Chunk
        self.sequence = 0
        self.errors = 0
        self.logger = logging.getLogger(self.__class__.__qualname__)
        
    def __str__(self) -> str:
        return f"Web {self.web_path!r}"

        
    
    def addDefName(self, name: str) -> str | None:
        """Reference to or definition of a chunk name."""
        nm = self.fullNameFor(name)
        if nm is None: return None
        if nm[-3:] == '...':
            self.logger.debug("Abbreviated reference %r", name)
            return None # first occurance is a forward reference using an abbreviation
        if nm not in self.named:
            self.named[nm] = []
            self.logger.debug("Adding empty chunk %r", name)
        return nm
    
    
    
    def add(self, chunk: Chunk) -> None:
        """Add an anonymous chunk."""
        self.chunkSeq.append(chunk)
        chunk.web = weakref.ref(self)
    
    
    
    def addNamed(self, chunk: Chunk) -> None:
        """Add a named chunk to a sequence with a given name."""
        self.chunkSeq.append(chunk)
        chunk.web = weakref.ref(self)
        nm = self.addDefName(chunk.name)
        if nm:
            # We found the full name for this chunk
            self.sequence += 1
            chunk.seq = self.sequence
            chunk.fullName = nm
            self.named[nm].append(chunk)
            chunk.initial = len(self.named[nm]) == 1
            self.logger.debug("Extending chunk %r from %r", nm, chunk.name)
        else:
            problem = f"No full name for {chunk.name!r}"
            self.logger.error(problem)
            self.errors += 1
            raise Error(problem)
    
    
    
    def addOutput(self, chunk: Chunk) -> None:
        """Add an output chunk to a sequence with a given name."""
        self.chunkSeq.append(chunk)
        chunk.web = weakref.ref(self)
        if chunk.name not in self.output:
            self.output[chunk.name] = []
            self.logger.debug("Adding chunk %r", chunk.name)
        self.sequence += 1
        chunk.seq = self.sequence
        chunk.fullName = chunk.name
        self.output[chunk.name].append(chunk)
        chunk.initial = len(self.output[chunk.name]) == 1
    
    

        
    def fullNameFor(self, name: str) -> str:
        """Resolve "..." names into the full name."""
        if name in self.named: 
            return name
        elif name.endswith('...'):
            best = [n 
                for n in self.named
                if n.startswith(name[:-3])
            ]
            match best:
                case []:
                    return name
                case [singleton]:
                    return singleton
                case _:
                    problem = f"Ambiguous abbreviation {name!r}, matches {sorted(best)!r}"
                    self.logger.error(problem)
                    raise Error(problem)
        else:
            return name
    
    
    def getchunk(self, name: str) -> list[Chunk]:
        """Locate a named sequence of chunks."""
        nm = self.fullNameFor(name)
        if nm in self.named:
            return self.named[nm]
        raise Error(f"Cannot resolve {name!r} in {self.named.keys()!r}")
    

        
    def createUsedBy(self) -> None:
        """Update every piece of a Chunk to show how the chunk is referenced.
        Each piece can then report where it's used in the web.
        """
        for aChunk in self.chunkSeq:
            #usage = (self.fullNameFor(aChunk.name), aChunk.seq)
            for aRefName in aChunk.genReferences(self):
                for c in self.getchunk(aRefName):
                    c.referencedBy.append(aChunk)
                    c.refCount += 1
                    
                
        for nm in self.no_reference():
            self.logger.warning("No reference to %r", nm)
        for nm in self.multi_reference():
            self.logger.warning("Multiple references to %r", nm)
        for nm in self.no_definition():
            self.logger.error("No definition for %r", nm)
            raise Error("Debug")
            self.errors += 1
    
    
    
    def no_reference(self) -> list[str]:
        return [nm for nm, cl in self.named.items() if len(cl)>0 and cl[0].refCount == 0]
    def multi_reference(self) -> list[str]:
        return [nm for nm, cl in self.named.items() if len(cl)>0 and cl[0].refCount > 1]
    def no_definition(self) -> list[str]:
        return [nm for nm, cl in self.named.items() if len(cl) == 0] 
    
    
    def fileXref(self) -> dict[str, list[int]]:
        fx = {}
        for f, cList in self.output.items():
            fx[f] = [c.seq for c in cList]
        return fx
    def chunkXref(self) -> dict[str, list[int]]:
        mx = {}
        for n, cList in self.named.items():
            mx[n] = [c.seq for c in cList]
        return mx
    
    
    def userNamesXref(self) -> dict[str, tuple[int, list[int]]]:
        ux: dict[str, tuple[int, list[int]]] = {}
        self._gatherUserId(self.named, ux)
        self._gatherUserId(self.output, ux)
        self._updateUserId(self.named, ux)
        self._updateUserId(self.output, ux)
        return ux
        
    def _gatherUserId(self, chunkMap: dict[str, list[Chunk]], ux: dict[str, tuple[int, list[int]]]) -> None:
                
        for n,cList in chunkMap.items():
            for c in cList:
                for id in c.getUserIDRefs():
                    ux[id] = (c.seq, [])
    
        
    def _updateUserId(self, chunkMap: dict[str, list[Chunk]], ux: dict[str, tuple[int, list[int]]]) -> None:
                
        # examine source for occurrences of all names in ux.keys()
        for id in ux.keys():
            self.logger.debug("References to %r", id)
            idpat = re.compile(f'\\W{id}\\W')
            for n,cList in chunkMap.items():
                for c in cList:
                    if c.seq != ux[id][0] and c.searchForRE(idpat):
                        ux[id][1].append(c.seq)
    
    

        
    def language(self, preferredWeaverClass: type["Weaver"] | None = None) -> "Weaver":
        """Construct a weaver appropriate to the document's language"""
        if preferredWeaverClass:
            return preferredWeaverClass()
        self.logger.debug("Picking a weaver based on first chunk %r", str(self.chunkSeq[0])[:4])
        if self.chunkSeq[0].startswith('<'): 
            return HTML()
        if self.chunkSeq[0].startswith('%') or self.chunkSeq[0].startswith('\\'):  
            return LaTeX()
        return RST()
    

        
    def tangle(self, aTangler: "Tangler") -> None:
        for f, c in self.output.items():
            with aTangler.open(Path(f)):
                for p in c:
                    p.tangle(self, aTangler)
    

        
    def weave(self, aWeaver: "Weaver") -> None:
        self.logger.debug("Weaving file from '%s'", self.web_path)
        if not self.web_path:
            raise Error("No filename supplied for weaving.")
        with aWeaver.open(self.web_path):
            for c in self.chunkSeq:
                c.weave(self, aWeaver)
                
    def weaveChunk(self, name: str, aWeaver: "Weaver") -> None:
        self.logger.debug("Weaving chunk %r", name)
        chunkList = self.getchunk(name)
        if not chunkList:
            raise Error(f"No Definition for {name!r}")
        chunkList[0].weaveReferenceTo(self, aWeaver)
        for p in chunkList[1:]:
            aWeaver.write(aWeaver.referenceSep())
            p.weaveShortReferenceTo(self, aWeaver)
    





class Tokenizer(Iterator[str]):
    def __init__(self, stream: TextIO, command_char: str='@') -> None:
        self.command = command_char
        self.parsePat = re.compile(f'({self.command}.|\\n)')
        self.token_iter = (t for t in self.parsePat.split(stream.read()) if len(t) != 0)
        self.lineNumber = 0
        
    def __next__(self) -> str:
        token = next(self.token_iter)
        self.lineNumber += token.count('\n')
        return token
        
    def __iter__(self) -> Iterator[str]:
        return self




class ParseError(Exception): pass

class OptionDef:
    def __init__(self, name: str, **kw: Any) -> None:
        self.name = name
        self.__dict__.update(kw)

class OptionParser:
    def __init__(self, *arg_defs: Any) -> None:
        self.args = dict((arg.name, arg) for arg in arg_defs)
        self.trailers = [k for k in self.args.keys() if not k.startswith('-')]
        
    def parse(self, text: str) -> dict[str, list[str]]:
        try:
            word_iter = iter(shlex.split(text))
        except ValueError as e:
            raise Error(f"Error parsing options in {text!r}")
        options = dict(self._group(word_iter))
        return options
        
    def _group(self, word_iter: Iterator[str]) -> Iterator[tuple[str, list[str]]]:
        option: str | None
        value: list[str]
        final: list[str]
        option, value, final = None, [], []
        for word in word_iter:
            if word == '--':
                if option:
                    yield option, value
                try:
                    final = [next(word_iter)] 
                except StopIteration:
                    final = []  # Special case of '--' at the end.
                break
            elif word.startswith('-'):
                if word in self.args:
                    if option: 
                        yield option, value
                    option, value = word, []
                else:
                    raise ParseError(f"Unknown option {word!r}")
            else:
                if option:
                    if self.args[option].nargs == len(value):
                        yield option, value
                        final = [word]
                        break
                    else:                
                        value.append(word)
                else:
                    final = [word]
                    break
        # In principle, we step through the trailers based on nargs counts.
        for word in word_iter:
            final.append(word)
        yield self.trailers[0], final



class WebReader:
    """Parse an input file, creating Chunks and Commands."""

    output_option_parser = OptionParser(
        OptionDef("-start", nargs=1, default=None),
        OptionDef("-end", nargs=1, default=""),
        OptionDef("argument", nargs='*'),
    )

    definition_option_parser = OptionParser(
        OptionDef("-indent", nargs=0),
        OptionDef("-noindent", nargs=0),
        OptionDef("argument", nargs='*'),
    )
    
    # Configuration
    command: str
    permitList: list[str]
    base_path : Path
    
    # State of the reader
    _source: TextIO
    filePath: Path
    theWeb: "Web"
    tokenizer: Tokenizer
    aChunk: Chunk

    def __init__(self, parent: Optional["WebReader"] = None) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)

        # Configuration of this reader.
        self.parent = parent
        if self.parent: 
            self.command = self.parent.command
            self.permitList = self.parent.permitList
        else: # Defaults until overridden
            self.command = '@'
            self.permitList = []
                    
        # Summary
        self.totalLines = 0
        self.totalFiles = 0
        self.errors = 0 
        
                
        # Structural ("major") commands
        self.cmdo = self.command+'o'
        self.cmdd = self.command+'d'
        self.cmdlcurl = self.command+'{'
        self.cmdrcurl = self.command+'}'
        self.cmdlbrak = self.command+'['
        self.cmdrbrak = self.command+']'
        self.cmdi = self.command+'i'
        
        # Inline ("minor") commands
        self.cmdlangl = self.command+'<'
        self.cmdrangl = self.command+'>'
        self.cmdpipe = self.command+'|'
        self.cmdlexpr = self.command+'('
        self.cmdrexpr = self.command+')'
        self.cmdcmd = self.command+self.command
        
        # Content "minor" commands
        self.cmdf = self.command+'f'
        self.cmdm = self.command+'m'
        self.cmdu = self.command+'u'

        
    def __str__(self) -> str:
        return self.__class__.__name__
        
        
    def location(self) -> tuple[str, int]:
        return (str(self.filePath), self.tokenizer.lineNumber+1)
    

    
        
    def load(self, web: "Web", filepath: Path, source: TextIO | None = None) -> "WebReader":
        self.theWeb = web
        self.filePath = filepath
        self.base_path = self.filePath.parent
    
        # Only set the a web's filename once using the first file.
        # **TODO:** this should be a setter property of the web.
        if self.theWeb.web_path is None:
            self.theWeb.web_path = self.filePath
        
        if source:
            self._source = source
            self.parse_source()
        else:
            with self.filePath.open() as self._source:
                self.parse_source()
        return self
    
    def parse_source(self) -> None:
        self.tokenizer = Tokenizer(self._source, self.command)
        self.totalFiles += 1
    
        self.aChunk = Chunk() # Initial anonymous chunk of text.
        self.aChunk.webAdd(self.theWeb)
    
        for token in self.tokenizer:
            if len(token) >= 2 and token.startswith(self.command):
                if self.handleCommand(token):
                    continue
                else:
                    self.logger.error('Unknown @-command in input: %r', token)
                    self.aChunk.appendText(token, self.tokenizer.lineNumber)
            elif token:
                # Accumulate a non-empty block of text in the current chunk.
                self.aChunk.appendText(token, self.tokenizer.lineNumber)
            else:
                # Whitespace
                pass
            if self.errors != 0:
                self.logger.error('Problem near %r', self.tokenizer.lineNumber)
                raise Error(f"DEBUG: {self.location()}")
    

    
        
    def handleCommand(self, token: str) -> bool:
        self.logger.debug("Reading %r", token)
        
        match token[:2]:
            case self.cmdo:
                                
                args = next(self.tokenizer)
                self.expect((self.cmdlcurl,))
                options = self.output_option_parser.parse(args)
                self.aChunk = OutputChunk(
                    name=' '.join(options['argument']),
                    comment_start=''.join(options.get('start', "# ")),
                    comment_end=''.join(options.get('end', "")),
                )
                self.aChunk.filePath = self.filePath 
                self.aChunk.webAdd(self.theWeb)
                # capture an OutputChunk up to @}
    
            case self.cmdd:
                                
                args = next(self.tokenizer)
                brack = self.expect((self.cmdlcurl,self.cmdlbrak))
                options = self.output_option_parser.parse(args)
                name = ' '.join(options['argument'])
                
                if brack == self.cmdlbrak:
                    self.aChunk = NamedDocumentChunk(name)
                elif brack == self.cmdlcurl:
                    if '-noindent' in options:
                        self.aChunk = NamedChunk_Noindent(name)
                    else:
                        self.aChunk = NamedChunk(name)
                elif brack == None:
                    pass # Error noted by expect()
                else:
                    raise Error("Design Error")
                
                self.aChunk.filePath = self.filePath 
                self.aChunk.webAdd(self.theWeb)
                # capture a NamedChunk up to @} or @]
    
            case self.cmdi:
                                
                incPath = Path(next(self.tokenizer).strip())
                try:
                    include = WebReader(parent=self)
                    if not incPath.is_absolute():
                        incPath = self.base_path / incPath
                    self.logger.info("Including '%s'", incPath)
                    include.load(self.theWeb, incPath)
                    self.totalLines += include.tokenizer.lineNumber
                    self.totalFiles += include.totalFiles
                    if include.errors:
                        self.errors += include.errors
                        self.logger.error("Errors in included file '%s', output is incomplete.", incPath)
                except Error as e:
                    self.logger.exception("Problems with included file '%s', output is incomplete.", incPath)
                    self.errors += 1
                except IOError as e:
                    self.logger.error("Problems finding included file '%s', output is incomplete.", incPath)
                    # Discretionary -- sometimes we want to continue
                    if self.cmdi in self.permitList: pass
                    else: raise  # Seems heavy-handed, but, the file wasn't found!
                self.aChunk = Chunk()
                self.aChunk.webAdd(self.theWeb)
    
            case self.cmdrcurl | self.cmdrbrak:
                                
                self.aChunk = Chunk()
                self.aChunk.webAdd(self.theWeb)
    
            case self.cmdpipe:
                                
                try:
                    self.aChunk.setUserIDRefs(next(self.tokenizer).strip())
                except AttributeError:
                    # Out of place @| user identifier command
                    self.logger.error("Unexpected references near %r: %r", self.location(), token)
                    raise Error("debug")
                    self.errors += 1
    
            case self.cmdf:
                self.aChunk.append(FileXrefCommand(self.tokenizer.lineNumber))
            case self.cmdm:
                self.aChunk.append(MacroXrefCommand(self.tokenizer.lineNumber))
            case self.cmdu:
                self.aChunk.append(UserIdXrefCommand(self.tokenizer.lineNumber))
            case self.cmdlangl:
                                
                # get the name, introduce into the named Chunk dictionary
                expand = next(self.tokenizer).strip()
                closing = self.expect((self.cmdrangl,))
                self.theWeb.addDefName(expand)
                self.aChunk.append(ReferenceCommand(expand, self.tokenizer.lineNumber))
                self.aChunk.appendText("", self.tokenizer.lineNumber) # to collect following text
                self.logger.debug("Reading %r %r", expand, closing)
    
            case self.cmdlexpr:
                                
                # get the Python expression, create the expression result
                expression = next(self.tokenizer)
                self.expect((self.cmdrexpr,))
                try:
                    # Build Context
                    # **TODO:** Parts of this are static.
                    dangerous = {
                        'breakpoint', 'compile', 'eval', 'exec', 'execfile', 'globals', 'help', 'input', 
                        'memoryview', 'open', 'print', 'super', '__import__'
                    }
                    safe = types.SimpleNamespace(**dict(
                        (name, obj) 
                        for name,obj in builtins.__dict__.items() 
                        if name not in dangerous
                    ))
                    globals = dict(
                        __builtins__=safe, 
                        os=types.SimpleNamespace(path=os.path, getcwd=os.getcwd, name=os.name),
                        time=time,
                        datetime=datetime,
                        platform=platform,
                        theLocation=str(self.location()),
                        theWebReader=self,
                        theFile=self.theWeb.web_path,
                        thisApplication=sys.argv[0],
                        __version__=__version__,  # Legacy compatibility. Deprecated.
                        version=__version__,
                        )
                    # Evaluate
                    result = str(eval(expression, globals))
                except Exception as exc:
                    self.logger.error('Failure to process %r: result is %r', expression, exc)
                    raise Error("debug")
                    self.errors += 1
                    result = f"@({expression!r}: Error {exc!r}@)"
                self.aChunk.appendText(result, self.tokenizer.lineNumber)
    
            case self.cmdcmd:
                                
                self.aChunk.appendText(self.command, self.tokenizer.lineNumber)
    
            case self.cmdlcurl | self.cmdlbrak:
                # These should have been consumed as part of @o and @d parsing
                self.logger.error("Extra %r (possibly missing chunk name) near %r", token, self.location())
                raise Error("debug")
                self.errors += 1
            case _:
                self.logger.error("Extra %r near %r", token, self.location())
                return False  # did not recogize the command
        return True  # did recognize the command
    
    
    def expect(self, tokens: Iterable[str]) -> str | None:
        try:
            t = next(self.tokenizer)
            while t == '\n':
                t = next(self.tokenizer)
        except StopIteration:
            self.logger.error("At %r: end of input, %r not found", self.location(), tokens)
            raise Error("debug")
            self.errors += 1
            return None
        if t not in tokens:
            self.logger.error("At %r: expected %r, found %r", self.location(), tokens, t)
            raise Error("debug")
            self.errors += 1
            return None
        return t
    





class Emitter:
    """Emit an output file; handling indentation context."""
    
    code_indent = 0 #: Used by a Tangler
    filePath : Path  #: Path within the base directory (on the name is used)
    output : Path  #: Base directory to write
    theFile: TextIO  #: Open file being written
    
    def __init__(self) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)
        self.log_indent = logging.getLogger("indent." + self.__class__.__qualname__)
        # Working State
        self.lastIndent = 0
        self.fragment = False
        self.context: list[int] = []
        self.readdIndent(self.code_indent)  # Create context and initial lastIndent values
        # Summary
        self.linesWritten = 0
        self.totalFiles = 0
        self.totalLines = 0

    def __str__(self) -> str:
        return self.__class__.__name__
        
        
    def open(self, aPath: Path) -> "Emitter":
        """Open a file."""
        if not hasattr(self, 'output'):
            self.output = Path.cwd()
        self.filePath = self.output / aPath.name
        self.logger.debug(f"Writing to {self.output} / {aPath.name} == {self.filePath}")
        self.linesWritten = 0
        self.doOpen()
        return self
        
    
    def doOpen(self) -> None:
        self.logger.debug("Creating %r", self.filePath)
    
    
    
    def close(self) -> None:
        self.codeFinish() # Trailing newline for tangler only.
        self.doClose()
        self.totalFiles += 1
        self.totalLines += self.linesWritten
        
    
    def doClose(self) -> None:
        self.logger.debug("Wrote %d lines to %r", self.linesWritten, self.filePath)
    
    
    
    def write(self, text: str) -> None:
        if text is None: return
        self.theFile.write(text)
        self.linesWritten += text.count('\n')
    
    # Context Manager Interface -- used by ``open()`` method
    def __enter__(self) -> "Emitter":
        return self
        
    def __exit__(self, *exc: Any) -> Literal[False]:
        self.close()
        return False
    

        
    def codeBlock(self, text: str) -> None:
        """Indented write of a block of code. 
        Buffers the spaces from the last line provided to act as the indent for the next line.
        """
        indent = self.context[-1]
        lines = text.split('\n')
        if len(lines) == 1: 
            # Fragment with no newline.
            self.logger.debug("Fragment: %d, %r", self.lastIndent, lines[0])
            self.write(f"{self.lastIndent*' '!s}{lines[0]!s}")
            self.lastIndent = 0
            self.fragment = True
        else:
            # Multiple lines with one or more newlines.
            first, rest = lines[:1], lines[1:]
            self.logger.debug("First Line: %d, %r", self.lastIndent, first[0])
            self.write(f"{self.lastIndent*' '!s}{first[0]!s}\n")
            for l in rest[:-1]:
                self.logger.debug("Next Line: %d, %r", indent, l)
                self.write(f"{indent*' '!s}{l!s}\n")
            if rest[-1]:
                # Last line is non-empty.
                self.logger.debug("Last (Partial) Line: %d, %r", indent, rest[-1])
                self.write(f"{indent*' '!s}{rest[-1]!s}")
                self.lastIndent = 0
                self.fragment = True
            else:
                # Last line was empty, a trailing newline.
                self.logger.debug("Last (Empty) Line: indent is %d", len(rest[-1]) + indent)
                # Buffer the next indent
                self.lastIndent = len(rest[-1]) + indent
                self.fragment = False
    
    
    quoted_chars: list[tuple[str, str]] = [
        # Must be empty for tangling.
    ]
    
    def quote(self, aLine: str) -> str:
        """Each individual line of code; often overridden by weavers to quote the code."""
        clean = aLine
        for from_, to_ in self.quoted_chars:
            clean = clean.replace(from_, to_)
        return clean
    
    
    def codeFinish(self) -> None:
        if self.fragment:
            self.write('\n')
    

        
    def addIndent(self, increment: int) -> None:
        self.lastIndent = self.context[-1]+increment
        self.context.append(self.lastIndent)
        self.log_indent.debug("addIndent %d: %r", increment, self.context)
        
    def setIndent(self, indent: int) -> None:
        self.context.append(indent)
        self.lastIndent = self.context[-1]
        self.log_indent.debug("setIndent %d: %r", indent, self.context)
        
    def clrIndent(self) -> None:
        if len(self.context) > 1:
            self.context.pop()
        self.lastIndent = self.context[-1]
        self.log_indent.debug("clrIndent %r", self.context)
        
    def readdIndent(self, indent: int = 0) -> None:
        """Resets the indentation context."""
        self.lastIndent = indent
        self.context = [self.lastIndent]
        self.log_indent.debug("readdIndent %d: %r", indent, self.context)
    





class Weaver(Emitter):
    """Format various types of XRef's and code blocks when weaving.
    
    For RST format we splice in the following two lines
    ::
     
        ..  include:: <isoamsa.txt>
        ..  include:: <isopub.txt>
    """
    extension = ".rst" 
    code_indent = 4
    # Not actually used.
    header = dedent("""
        ..  include:: <isoamsa.txt>
        ..  include:: <isopub.txt>
    """)
    
    reference_style : "Reference"
    
    def __init__(self) -> None:
        super().__init__()
    
        
    def doOpen(self) -> None:
        """Create the final woven document."""
        self.filePath = self.filePath.with_suffix(self.extension)
        self.logger.info("Weaving '%s'", self.filePath)
        self.theFile = self.filePath.open("w")
        self.readdIndent(self.code_indent)
        
    def doClose(self) -> None:
        self.theFile.close()
        self.logger.info("Wrote %d lines to %r", self.linesWritten, self.filePath)
        
    def addIndent(self, increment: int = 0) -> None:
        """increment not used when weaving"""
        self.context.append(self.context[-1])
        self.log_indent.debug("addIndent %d: %r", self.lastIndent, self.context)
        
    def codeFinish(self) -> None:
        pass # Not needed when weaving
    

    
    # Template Expansions.
    
        
    # Prevent some RST markup from being recognized (and processed) in code.
    quoted_chars: list[tuple[str, str]] = [
        ('\\', r'\\'), # Must be first.
        ('`', r'\`'),
        ('_', r'\_'), 
        ('*', r'\*'),
        ('|', r'\|'),
    ]

        
    def docBegin(self, aChunk: Chunk) -> None:
        pass
        
    def docEnd(self, aChunk: Chunk) -> None:
        pass
    

        
    ref_template = string.Template(
        "${refList}"
    )
    ref_separator = "; "
    ref_item_template = string.Template(
        "$fullName (`${seq}`_)"
    )
    
    def references(self, aChunk: Chunk) -> str:
        references = aChunk.references(self)
        if len(references) != 0:
            refList = [ 
                self.ref_item_template.substitute(seq=s, fullName=n)
                for n, s in references 
            ]
            return self.ref_template.substitute(refList=self.ref_separator.join(refList))
        else:
            return ""
    

        
    cb_template = string.Template(
        dedent("""
            ..  _`${seq}`:
            ..  rubric:: ${fullName} (${seq}) ${concat}
            ..  parsed-literal::
                :class: code
                
        """)
    )
    
    ce_template = string.Template(
        dedent("""
            ..
                
                ..  class:: small
                    
                    |loz| *${fullName} (${seq})*. Used by: ${references}
        """)
    )
    
    def codeBegin(self, aChunk: Chunk) -> None:
        txt = self.cb_template.substitute( 
            seq=aChunk.seq,
            lineNumber=aChunk.lineNumber, 
            fullName=aChunk.fullName,
            concat="=" if aChunk.initial else "+=",
        )
        self.write(txt)
        
    def codeEnd(self, aChunk: Chunk) -> None:
        txt = self.ce_template.substitute( 
            seq = aChunk.seq,
            lineNumber = aChunk.lineNumber, 
            fullName = aChunk.fullName,
            references = self.references(aChunk),
        )
        self.write(txt)
    

        
    fb_template = string.Template(
        dedent("""
            ..  _`${seq}`:
            ..  rubric:: ${fullName} (${seq}) ${concat}
            ..  parsed-literal::
                :class: code
        
        """)
    )
    
    fe_template = string.Template(
        dedent("""
            ..
                
                ..  class:: small
                        
                    |loz| *${fullName} (${seq})*.
        """)
    )
    
    def fileBegin(self, aChunk: Chunk) -> None:
        txt = self.fb_template.substitute(
            seq=aChunk.seq, 
            lineNumber=aChunk.lineNumber, 
            fullName=aChunk.fullName,
            concat="=" if aChunk.initial else "+=",
        )
        self.write(txt)
    
    def fileEnd(self, aChunk: Chunk) -> None:
        assert len(self.references(aChunk)) == 0
        txt = self.fe_template.substitute(
            seq=aChunk.seq, 
            lineNumber=aChunk.lineNumber, 
            fullName=aChunk.fullName,
            references=[])
        self.write(txt)
    

        
    refto_name_template = string.Template(
        r"|srarr|\ ${fullName} (`${seq}`_)"
    )
    refto_seq_template = string.Template(
        r"|srarr|\ (`${seq}`_)"
    )
    refto_seq_separator = ", "
    
    def referenceTo(self, aName: str | None, seq: int) -> str:
        """Weave a reference to a chunk.
        Provide name to get a full reference.
        name=None to get a short reference.
        """
        if aName:
            return self.refto_name_template.substitute(fullName=aName, seq=seq)
        else:
            return self.refto_seq_template.substitute(seq=seq)
            
    def referenceSep(self) -> str:
        """Separator between references."""
        return self.refto_seq_separator
    

        
    xref_head_template = string.Template(
        dedent("""
        """)
    )
    xref_foot_template = string.Template(
        dedent("""
        """)
    )
    xref_item_template = string.Template(
        dedent("""    :${fullName}:
        ${refList}
        """)
    )
    xref_empty_template = string.Template(
        dedent("""    (None)
        """)
    )
    
    def xrefHead(self) -> None:
        txt = self.xref_head_template.substitute()
        self.write(txt)
    
    def xrefFoot(self) -> None:
        txt = self.xref_foot_template.substitute()
        self.write(txt)
    
    def xrefLine(self, name: str, refList: list[int]) -> None:
        refList_txt = [self.referenceTo(None, r) for r in refList]
        txt = self.xref_item_template.substitute(fullName=name, refList = " ".join(refList_txt)) # RST Separator
        self.write(txt)
    
    def xrefEmpty(self) -> None:
        self.write(self.xref_empty_template.substitute())
    
    name_def_template = string.Template(
        '[`${seq}`_]'
    )
    name_ref_template = string.Template(
        '`${seq}`_'
    )
    
    def xrefDefLine(self, name: str, defn: int, refList: list[int]) -> None:
        """Special template for the definition, default reference for all others."""
        templates = {defn: self.name_def_template}
        refTxt = [
            templates.get(r, self.name_ref_template).substitute(seq=r)
            for r in sorted(refList + [defn]) 
        ]
        # Generic space separator
        txt = self.xref_item_template.substitute(fullName=name, refList=" ".join(refTxt)) 
        self.write(txt)
    




class RST(Weaver):
    pass


class LaTeX(Weaver):
    """LaTeX formatting for XRef's and code blocks when weaving.
    Requires ``\\usepackage{fancyvrb}``
    """
    extension = ".tex"
    code_indent = 0
    # Not actually used
    header = dedent("""
        \\usepackage{fancyvrb}
    """)

        
    cb_template = string.Template(
        dedent("""        \\label{pyweb${seq}}
            \\begin{flushleft}
            \\textit{Code example ${fullName} (${seq})}
            \\begin{Verbatim}[commandchars=\\\\\\{\\},codes={\\catcode`$$=3\\catcode`^=7},frame=single]
        """)
    )
    

        
    ce_template = string.Template(
        dedent("""
            \\end{Verbatim}
            ${references}
            \\end{flushleft}
        """)
    )
    

        
    fb_template = cb_template
    

        
    fe_template = ce_template
    

        
    ref_item_template = string.Template(
        indent(
            dedent("""
                \\item Code example ${fullName} (${seq}) (Sect. \\ref{pyweb${seq}}, p. \\pageref{pyweb${seq}})
                """),
            '    '
        )
    )
    
    ref_template = string.Template(
        indent(
            dedent("""
                \\footnotesize
                Used by:
                \\begin{list}{}{}
                ${refList}
                \\end{list}
                \\normalsize"""),
            '    '
        )
    )
    

        
    quoted_chars: list[tuple[str, str]] = [
        ("\\end{Verbatim}", "\\end\\,{Verbatim}"),  # Allow \end{Verbatim} in a Verbatim context
        ("\\{", "\\\\,{"), # Prevent unexpected commands in Verbatim
        ("$", "\\$"), # Prevent unexpected math in Verbatim
    ]
    

        
    refto_name_template = string.Template(
        """$$\\triangleright$$ Code Example ${fullName} (${seq})"""
    )
    
    refto_seq_template = string.Template(
        """(${seq})"""
    )
    




class HTML(Weaver):
    """HTML formatting for XRef's and code blocks when weaving."""
    extension = ".html"
    code_indent = 0
    header = ""
    
        
    cb_template = string.Template(
        indent(
            dedent("""
                <a name="pyweb${seq}"></a>
                <!--line number ${lineNumber}-->
                <p><em>${fullName}</em> (${seq})&nbsp;${concat}</p>
                <pre><code>
                """),
            '    '
        )
    )
    

        
    ce_template = string.Template(
        indent(
            dedent("""
                </code></pre>
                <p>&loz; <em>${fullName}</em> (${seq}).
                ${references}
                </p>
                """),
            '    '
        )
    )
    

        
    fb_template = string.Template(
        indent(
            dedent("""            <a name="pyweb${seq}"></a>
                <!--line number ${lineNumber}-->
                <p>``${fullName}`` (${seq})&nbsp;${concat}</p>
                <pre><code>
            """), # No leading \\n.
            '    '
        )
    )
    

        
    fe_template = string.Template(
        indent(
            dedent("""            </code></pre>
                <p>&loz; ``${fullName}`` (${seq}).
                ${references}
                </p>
                """),
            '    '
        )
    )
    

        
    ref_item_template = string.Template(
        '<a href="#pyweb${seq}"><em>${fullName}</em>&nbsp;(${seq})</a>'
    )
    
    ref_template = string.Template(
        '  Used by ${refList}.'
    )
    

        
    quoted_chars: list[tuple[str, str]] = [
        ("&", "&amp;"),  # Must be first
        ("<", "&lt;"),
        (">", "&gt;"),
        ('"', "&quot;"),
    ]
    

        
    refto_name_template = string.Template(
        '<a href="#pyweb${seq}">&rarr;<em>${fullName}</em> (${seq})</a>'
    )
    
    refto_seq_template = string.Template(
        '<a href="#pyweb${seq}">(${seq})</a>'
    )
    

        
    xref_head_template = string.Template(
        dedent("""    <dl>
        """)
    )
    xref_foot_template = string.Template(
        dedent("""    </dl>
        """)
    )
    xref_item_template = string.Template(
        dedent("""    <dt>${fullName}</dt><dd>${refList}</dd>
        """)
    )
    
    
    name_def_template = string.Template(
        '<a href="#pyweb${seq}"><b>&bull;${seq}</b></a>'
    )
    
    name_ref_template = string.Template(
        '<a href="#pyweb${seq}">${seq}</a>'
    )
    
    
    



class HTMLShort(HTML):
    """HTML formatting for XRef's and code blocks when weaving with short references."""
        
    ref_item_template = string.Template(
        '<a href="#pyweb${seq}">(${seq})</a>'
    )
    





class Tangler(Emitter):
    """Tangle output files."""
    def __init__(self) -> None:
        super().__init__()
        self.comment_start: str = "#"
        self.comment_end: str = ""
        self.include_line_numbers = False
        
        
    def checkPath(self) -> None:
        self.filePath.parent.mkdir(parents=True, exist_ok=True)
    
    def doOpen(self) -> None:
        """Tangle out of the output files."""
        self.checkPath()
        self.theFile = self.filePath.open("w")
        self.logger.info("Tangling '%s'", self.filePath)
        
    def doClose(self) -> None:
        self.theFile.close()
        self.logger.info("Wrote %d lines to %r", self.linesWritten, self.filePath)
    

        
    def codeBegin(self, aChunk: Chunk) -> None:
        self.log_indent.debug("<tangle %r:", aChunk.fullName)
        if self.include_line_numbers:
            self.write(
                f"\n{self.comment_start!s} Web: " 
                f"{aChunk.filePath.name!s}:{aChunk.lineNumber!r} " 
                f"{aChunk.fullName!s}({aChunk.seq:d}) {self.comment_end!s}\n"
            )
    

        
    def codeEnd(self, aChunk: Chunk) -> None:
        self.log_indent.debug(">%r", aChunk.fullName)
    




class TanglerMake(Tangler):
    """Tangle output files, leaving files untouched if there are no changes."""
    tempname : str
    def __init__(self, *args: Any) -> None:
        super().__init__(*args)

        
    def doOpen(self) -> None:
        fd, self.tempname = tempfile.mkstemp(dir=os.curdir)
        self.theFile = os.fdopen(fd, "w")
        self.logger.info("Tangling  '%s'", self.filePath)
    


        
    def doClose(self) -> None:
        self.theFile.close()
        try:
            same = filecmp.cmp(self.tempname, self.filePath)
        except OSError as e:
            same = False  # Doesn't exist. (Could check for errno.ENOENT)
        if same:
            self.logger.info("Unchanged '%s'", self.filePath)
            os.remove(self.tempname)
        else:
            # Windows requires the original file name be removed first.
            try: 
                self.filePath.unlink()
            except OSError as e:
                pass  # Doesn't exist. (Could check for errno.ENOENT)
            self.checkPath()
            self.filePath.hardlink_to(self.tempname)
            os.remove(self.tempname)
            self.logger.info("Wrote %d lines to %s", self.linesWritten, self.filePath)
    






class Reference(abc.ABC):
    def __init__(self) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)
        
    @abc.abstractmethod
    def chunkReferencedBy(self, aChunk: Chunk) -> list[Chunk]:
        """Return a list of Chunks."""
        ...

class SimpleReference(Reference):
    def chunkReferencedBy(self, aChunk: Chunk) -> list[Chunk]:
        refBy = aChunk.referencedBy
        return refBy

class TransitiveReference(Reference):
    def chunkReferencedBy(self, aChunk: Chunk) -> list[Chunk]:
        refBy = aChunk.referencedBy
        self.logger.debug("References: %r(%d) %r", aChunk.name, aChunk.seq, refBy)
        return self.allParentsOf(refBy)
    def allParentsOf(self, chunkList: list[Chunk], depth: int = 0) -> list[Chunk]:
        """Transitive closure of parents via recursive ascent.
        """
        final = []
        for c in chunkList:
            final.append(c)
            final.extend(self.allParentsOf(c.referencedBy, depth+1))
        self.logger.debug(f"References: {'--':>{2*depth}s} {final!s}")
        return final
 



class Action:
    """An action performed by pyWeb."""
    options : argparse.Namespace
    web : "Web"
    def __init__(self, name: str) -> None:
        self.name = name
        self.start: float | None = None
        self.logger = logging.getLogger(self.__class__.__qualname__)
        
    def __str__(self) -> str:
        return f"{self.name!s} [{self.web!s}]"
        
        
    def __call__(self) -> None:
        self.logger.info("Starting %s", self.name)
        self.start = time.process_time()
    

    
        
    def duration(self) -> float:
        """Return duration of the action."""
        return (self.start and time.process_time()-self.start) or 0
        
    def summary(self) -> str:
        return f"{self.name!s} in {self.duration():0.3f} sec."
    




class ActionSequence(Action):
    """An action composed of a sequence of other actions."""
    def __init__(self, name: str, opSequence: list[Action] | None = None) -> None:
        super().__init__(name)
        if opSequence: self.opSequence = opSequence
        else: self.opSequence = []
        
    def __str__(self) -> str:
        return "; ".join([str(x) for x in self.opSequence])
        
        
    def __call__(self) -> None:
        super().__call__()
        for o in self.opSequence:
            o.web = self.web
            o.options = self.options
            o()
    

    
        
    def append(self, anAction: Action) -> None:
        self.opSequence.append(anAction)
    

    
        
    def summary(self) -> str:
        return ", ".join([o.summary() for o in self.opSequence])
    




class WeaveAction(Action):
    """Weave the final document."""
    def __init__(self) -> None:
        super().__init__("Weave")
        
    def __str__(self) -> str:
        return f"{self.name!s} [{self.web!s}, {self.options.theWeaver!s}]"

        
    def __call__(self) -> None:
        super().__call__()
        if not self.options.theWeaver: 
            # Examine first few chars of first chunk of web to determine language
            self.options.theWeaver = self.web.language() 
            self.logger.info("Using %s", self.options.theWeaver.__class__.__name__)
        self.options.theWeaver.reference_style = self.options.reference_style
        self.options.theWeaver.output = self.options.output
        try:
            self.web.weave(self.options.theWeaver)
            self.logger.info("Finished Normally")
        except Error as e:
            self.logger.error("Problems weaving document from %r (weave file is faulty).", self.web.web_path)
            #raise
    

    
        
    def summary(self) -> str:
        if self.options.theWeaver and self.options.theWeaver.linesWritten > 0:
            return (
                f"{self.name!s} {self.options.theWeaver.linesWritten:d} lines in {self.duration():0.3f} sec."
            )
        return f"did not {self.name!s}"
    




class TangleAction(Action):
    """Tangle source files."""
    def __init__(self) -> None:
        super().__init__("Tangle")
        
        
    def __call__(self) -> None:
        super().__call__()
        self.options.theTangler.include_line_numbers = self.options.tangler_line_numbers
        self.options.theTangler.output = self.options.output
        try:
            self.web.tangle(self.options.theTangler)
        except Error as e:
            self.logger.error("Problems tangling outputs from %r (tangle files are faulty).", self.web.web_path)
            #raise
    

    
        
    def summary(self) -> str:
        if self.options.theTangler and self.options.theTangler.linesWritten > 0:
            return (
                f"{self.name!s} {self.options.theTangler.totalLines:d} lines in {self.duration():0.3f} sec."
            )
        return f"did not {self.name!r}"
    




class LoadAction(Action):
    """Load the source web."""
    def __init__(self) -> None:
        super().__init__("Load")
    def __str__(self) -> str:
        return f"Load [{self.webReader!s}, {self.web!s}]"
        
        
    def __call__(self) -> None:
        super().__call__()
        self.webReader = self.options.webReader
        self.webReader.command = self.options.command
        self.webReader.permitList = self.options.permitList 
        self.web.web_path = self.options.source_path
        error = f"Problems with source file {self.options.source_path!r}, no output produced."
        try:
            self.webReader.load(self.web, self.options.source_path)
            if self.webReader.errors != 0:
                raise Error("Syntax Errors in the Web")
            self.web.createUsedBy()
            if self.webReader.errors != 0:
                raise Error("Internal Reference Errors in the Web")        
        except Error as e:
            self.logger.exception(error)
            raise # Older design.
        except IOError as e:
            self.logger.exception(error)
            raise
    

    
        
    def summary(self) -> str:
        return (
            f"{self.name!s} {self.webReader.totalLines:d} lines from {self.webReader.totalFiles:d} files in {self.duration():0.3f} sec."
        )
    






class Application:
    def __init__(self) -> None:
        self.logger = logging.getLogger(self.__class__.__qualname__)
                
        self.defaults = argparse.Namespace(
            verbosity=logging.INFO,
            command='@',
            weaver='rst', 
            skip='',  # Don't skip any steps
            permit='',  # Don't tolerate missing includes
            reference='s',  # Simple references
            tangler_line_numbers=False,
            output=Path.cwd(),
            )
        # self.expand(self.defaults)
        
        # Primitive Actions
        self.loadOp = LoadAction()
        self.weaveOp = WeaveAction()
        self.tangleOp = TangleAction()
        
        # Composite Actions
        self.doWeave = ActionSequence("load and weave", [self.loadOp, self.weaveOp])
        self.doTangle = ActionSequence("load and tangle", [self.loadOp, self.tangleOp])
        self.theAction = ActionSequence("load, tangle and weave", [self.loadOp, self.tangleOp, self.weaveOp])

        
        
    def parseArgs(self, argv: list[str]) -> argparse.Namespace:
        p = argparse.ArgumentParser()
        p.add_argument("-v", "--verbose", dest="verbosity", action="store_const", const=logging.INFO)
        p.add_argument("-s", "--silent", dest="verbosity", action="store_const", const=logging.WARN)
        p.add_argument("-d", "--debug", dest="verbosity", action="store_const", const=logging.DEBUG)
        p.add_argument("-c", "--command", dest="command", action="store")
        p.add_argument("-w", "--weaver", dest="weaver", action="store")
        p.add_argument("-x", "--except", dest="skip", action="store", choices=('w', 't'))
        p.add_argument("-p", "--permit", dest="permit", action="store")
        p.add_argument("-r", "--reference", dest="reference", action="store", choices=('t', 's'))
        p.add_argument("-n", "--linenumbers", dest="tangler_line_numbers", action="store_true")
        p.add_argument("-o", "--output", dest="output", action="store", type=Path)
        p.add_argument("-V", "--Version", action='version', version=f"py-web-tool pyweb.py {__version__}")
        p.add_argument("files", nargs='+', type=Path)
        config = p.parse_args(argv, namespace=self.defaults)
        self.expand(config)
        return config
        
    def expand(self, config: argparse.Namespace) -> argparse.Namespace:
        """Translate the argument values from simple text to useful objects.
        Weaver. Tangler. WebReader.
        """
        match config.reference:
            case 't':
                config.reference_style = TransitiveReference() 
            case 's':
                config.reference_style = SimpleReference()
            case _:
                raise Error("Improper configuration")
    
        # Weaver
        try:
            weaver_class = weavers[config.weaver.lower()]
        except KeyError:
            module_name, _, class_name = config.weaver.partition('.')
            weaver_module = __import__(module_name)
            weaver_class = weaver_module.__dict__[class_name]
            if not issubclass(weaver_class, Weaver):
                raise TypeError(f"{weaver_class!r} not a subclass of Weaver")
        config.theWeaver = weaver_class()
        
        # Tangler
        config.theTangler = TanglerMake()
        
        if config.permit:
            # save permitted errors, usual case is ``-pi`` to permit ``@i`` include errors
            config.permitList = [f'{config.command!s}{c!s}' for c in config.permit]
        else:
            config.permitList = []
    
        config.webReader = WebReader()
    
        return config
    

        
    def process(self, config: argparse.Namespace) -> None:
        root = logging.getLogger()
        root.setLevel(config.verbosity)
        self.logger.debug("Setting root log level to %r", logging.getLevelName(root.getEffectiveLevel()))
        
        if config.command:
            self.logger.debug("Command character %r", config.command)
            
        if config.skip:
            if config.skip.lower().startswith('w'):  # not weaving == tangling
                self.theAction = self.doTangle
            elif config.skip.lower().startswith('t'):  # not tangling == weaving
                self.theAction = self.doWeave
            else:
                raise Exception(f"Unknown -x option {config.skip!r}")
    
        self.logger.info("Weaver %s", config.theWeaver)
    
        for f in config.files:
            w = Web() # New, empty web to load and process.
            self.logger.info("%s '%s'", self.theAction.name, f)
            config.source_path = f
            self.theAction.web = w
            self.theAction.options = config
            self.theAction()
            self.logger.info(self.theAction.summary())
    



# Global list of available weaver classes.
weavers = {
    'html':  HTML,
    'htmlshort': HTMLShort,
    'latex': LaTeX,
    'rst': RST, 
}


class Logger:
    def __init__(self, dict_config: dict[str, Any] | None = None, **kw_config: Any) -> None:
        self.dict_config = dict_config
        self.kw_config = kw_config
        
    def __enter__(self) -> "Logger":
        if self.dict_config:
            logging.config.dictConfig(self.dict_config)
        else:
            logging.basicConfig(**self.kw_config)
        return self
        
    def __exit__(self, *args: Any) -> Literal[False]:
        logging.shutdown()
        return False

log_config = {
    'version': 1,
    'disable_existing_loggers': False, # Allow pre-existing loggers to work.
    'style': '{',
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'stream': 'ext://sys.stderr',
            'formatter': 'basic',
        },
    },
    'formatters': {
        'basic': {
            'format': "{levelname}:{name}:{message}",
            'style': "{",
        }
    },
    
    'root': {'handlers': ['console'], 'level': logging.INFO,},
    
    #For specific debugging support...
    'loggers': {
    #    'RST': {'level': logging.DEBUG},
    #    'TanglerMake': {'level': logging.DEBUG},
    #    'WebReader': {'level': logging.DEBUG},
    },
}


def main(argv: list[str] = sys.argv[1:]) -> None:
    a = Application()
    config = a.parseArgs(argv)
    a.process(config)

if __name__ == "__main__":
    with Logger(log_config):
        main()
