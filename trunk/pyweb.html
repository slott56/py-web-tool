<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/2000/REC-xhtml1-20000126/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>pyWeb Literate Programming 2.1</title>
    <meta name="generator" content="BBEdit 6.5.2" />
    <meta name="author" content="Steven F. Lott" />
    <link rel="StyleSheet" href="pyweb.css" type="text/css" />
</head>
<body>
<div class="document">

<!-- title page -->
<p class="title"><em>pyWeb</em> 2.1</p>
<p class="title">In Python, Yet Another Literate Programming Tool</p>
<p class="subtitle"><a href="mailto:s_lott@yahoo.com">Steven F. Lott</a></p>

<hr />
<p class="subtitle">Table of Contents</p>
<ol>
<li><a href="#intro">Introduction</a></li>
<li><a href="#todo">To Do</a></li>
<li><a href="#changes">Change Log</a></li>
<li><a href="#arch">Architecture and Design Overview</a></li>
<li><a href="#impl">Implementation</a></li>
<li><a href="#ix">Indices</a></li>
</ol>
<hr />

<a name="intro"></a><h1>Introduction</h1>
<div class="chapter">
<!-- pyweb/intro.w -->

<p>Literate programming was pioneered by Knuth as a method for
developing readable, understandable presentations of programs.
These would present a program in a literate fashion for people
to read and understand; this would be in parallel with presentation as source text
for a compiler to process and both would be generated from a common source file.
</p>
<p>
One intent is to synchronize the program source with the
documentation about that source.  If the program and the documentation
have a common origin, then the traditional gaps between intent 
(expressed in the documentation) and action (expressed in the
working program) are significantly reduced.
</p>
<p><em>pyWeb</em> is a literate programming tool that combines the actions
of <em>weaving</em> a document with <em>tangling</em> source files.
It is independent of any particular document markup or source language.
Is uses a simple set of markup tags to define chunks of code and 
documentation.
</p>

<h2>Background</h2>

<p>The following is an almost verbatim quote from Briggs' <i>nuweb</i> documentation, and provides an apt summary of Literate Programming.</p>

<div>
<p class="quote">In 1984, Knuth introduced the idea of <em>literate programming</em> and
described a pair of tools to support the practise (Donald E. Knuth, <i>Literate Programming</i>, The Computer Journal <b>27</b> (1984), no. 2, 97-111.)
His approach was to combine Pascal code with T<small>E</small>X documentation to
produce a new language, <tt>WEB</tt>, that offered programmers a superior
approach to programming. He wrote several programs in <tt>WEB</tt>,
including <tt>weave</tt> and <tt>tangle</tt>, the programs used to support
literate programming.
The idea was that a programmer wrote one document, the web file, that
combined documentation written in T<small>E</small>X (Donald E. Knuth, 
<i>The T<small>E</small>Xbook</i>, Computers and Typesetting, 1986) with code (written in Pascal).
</p>
<p class="quote">
Running <tt>tangle</tt> on the web file would produce a complete
Pascal program, ready for compilation by an ordinary Pascal compiler.
The primary function of <tt>tangle</tt> is to allow the programmer to
present elements of the program in any desired order, regardless of
the restrictions imposed by the programming language. Thus, the
programmer is free to present his program in a top-down fashion,
bottom-up fashion, or whatever seems best in terms of promoting
understanding and maintenance.
</p>
<p class="quote">
Running <tt>weave</tt> on the web file would produce a T<small>E</small>X file, ready
to be processed by T<small>E</small>X. The resulting document included a variety of
automatically generated indices and cross-references that made it much
easier to navigate the code. Additionally, all of the code sections
were automatically prettyprinted, resulting in a quite impressive
document. 
</p>
<p class="quote">
Knuth also wrote the programs for T<small>E</small>X and <small><i>METAFONT</i></small>
entirely in <tt>WEB</tt>, eventually publishing them in book
form. These are probably the
largest programs ever published in a readable form.
</p>
</div>

<h2>Other Tools</h2>

<p>Numerous tools have been developed based on Knuth's initial
work.  A relatively complete survey is available at sites
like <a href="http://www.literateprogramming.com/">Literate Programming</a>, 
and the OASIS
<a href="http://www.oasis-open.org/cover/xmlLitProg.html">XML Cover Pages: Literate Programming with SGML and XML</a>.
</p>
<p>The immediate predecessors to this <em>pyWeb</em> tool are 
<a href="http://www.ross.net/funnelweb/"><i>FunnelWeb</i></a>,
<a href="http://www.eecs.harvard.edu/~nr/noweb/"><i>noweb</i></a> and 
<a href="http://sourceforge.net/projects/nuweb/"><i>nuweb</i></a>.  The ideas lifted from these other
tools created the foundation for <em>pyWeb</em>.
</p>
<p>There are several Python-oriented literate programming tools.  
These include 
<a href="http://personalpages.tds.net/~edream/front.html"><i>LEO</i></a>, 
<a href="http://interscript.sourceforge.net/"><i>interscript</i></a>, 
<a href="http://www.danbala.com/python/lpy/"><i>lpy</i></a>, 
<a href="http://www.egenix.com/files/python/SoftwareDescriptions.html#py2html.py"><i>py2html</i></a>,
<a href="http://pylit.berlios.de/"><i>PyLit</i></a>.
</p>
<p>The <i>FunnelWeb</i> tool is independent of any programming language
and only mildly dependent on T<small>E</small>X.
It has 19 commands, many of which duplicate features of HTML or 
L<sup><small>A</small></sup>T<small>E</small>X.
</p>
<p>The <i>noweb</i> tool was written by Norman Ramsey.
This tool uses a sophisticated multi-processing framework, via Unix
pipes, to permit flexible manipulation of the source file to tangle
and weave the programming language and documentation markup files.
</p>
<p>The <i>nuweb</i> Simple Literate Programming Tool was developed by
Preston Briggs (preston@tera.com).  His work was supported by ARPA,
through ONR grant N00014-91-J-1989.  It is written
in C, and very focused on producing L<sup><small>A</small></sup>T<small>E</small>X documents.  It can 
produce HTML, but this is clearly added after the fact.  It cannot be 
easily extended, and is not object-oriented.
</p>
<p>The <i>LEO</i> tool, is a structured GUI editor for creating
source.  It uses XML and <i>noweb</i>-style chunk management.  It is more
than a simple weave and tangle tool.</p>
<p>The <i>interscript</i> tool is very large and sophisticated, but doesn't gracefully
tolerate HTML markup in the document.  It can create a variety of 
markup languages from the interscript source, making it suitable for
creating HTML as well as L<sup><small>A</small></sup>T<small>E</small>X.</p>
<p>The <i>lpy</i> tool can produce very complex HTML representations of
a Python program.  It works by locating documentation markup embedded
in Python comments and docstrings.  This is called "inverted literate
programming".</p>
<p>The <i>py2html</i> tool does very sophisticated syntax coloring.</p>
<p>The <i>PyLit</i> tool is perhaps the very best approach to simple Literate
programming, since it leverages an existing lightweight markup language
and it's output formatting.</p>

<h2><em>pyWeb</em></h2>
<p><em>pyWeb</em> works with any 
programming language and any markup language.  This philosophy
comes from <i>FunnelWeb</i>,
<i>noweb</i>, <i>nuweb</i> and <i>interscript</i>.  The primary differences
between <em>pyWeb</em> and other tools are the following.</p>
<ul>
<li><em>pyWeb</em> is object-oriented, permitting easy extension.  
<i>noweb</i> extensions
are separate processes that communicate through a sophisticated protocol.
<i>nuweb</i> is not easily extended without rewriting and recompiling
the C programs.</li>
<li><em>pyWeb</em> is built in the very portable Python programming 
language.  This allows it to run anywhere that Python 2.6 runs, with
no additional tool or compiler dependencies.  This makes it a useful
tool for programmers in any language.</li>
<li><em>pyWeb</em> is much simpler than <i>FunnelWeb</i>, <i>LEO</i> or <i>Interscript</i>.  It has 
a very limited selection of commands, but can still produce 
complex programs and HTML documents.</li>
<li><em>pyWeb</em> does not invent its own markup language like <i>Interscript</i>.
Because <i>Interscript</i> has its own markup, it can generate LaTex or HTML or other
output formats from a unique input format.  While powerful, it seems simpler to
avoid inventing yet another sophisticated markup language.  The language <em>pyWeb</em>
uses is very simple, and the author's use their preferred markup language almost
exclusively.</li>
<li><em>pyWeb</em> supports the forward literate programming philosophy, 
where a source document creates programming language and markup language.
The alternative, deriving the document from markup embedded in 
program comments ("inverted literate programming"), seems less appealing.
The disadvantage of inverted literate programming is that the final document
can't reflect the original author's preferred order of exposition,
since that informtion generally isn't part of the source code.
</li>
<li><em>pyWeb</em> also specifically rejects some features of <i>nuweb</i>
and <i>FunnelWeb</i>.  These include the macro capability with parameter
substitution, and multiple references to a chunk.  These two capabilities
can be used to grow object-like applications from non-object programming
languages (<em>e.g.</em> C or Pascal).  Since most modern languages (Python,
Java, C++) are object-oriented, this macro capability is more of a problem
than a help.</li>
<li>Since <em>pyWeb</em> is built in the Python interpreter, a source document
can include Python expressions that are evaluated during weave operation to
produce time stamps, source file descriptions or other information in the woven 
or tangled output.</li>
</ul>

<p><em>pyWeb</em> works with any programming language and any markup language.
The initial release supports HTML and 
L<sup><small>A</small></sup>T<small>E</small>X via simple templates.
</p>

<p>The following is extensively quoted from Briggs' <i>nuweb</i> documentation, 
and provides an excellent background in the advantages of the very
simple approach started by <i>nuweb</i> and adopted by <em>pyWeb</em>.</p>

<div>
<p class="quote">
The need to support arbitrary
programming languages has many consequences:</p>
<dl class="quote">
<dt>No prettyprinting</dt><dd class="quote"> Both <tt>WEB</tt> and <tt>CWEB</tt> are able to
  prettyprint the code sections of their documents because they
  understand the language well enough to parse it. Since we want to use
  <em>any</em> language, we've got to abandon this feature.
  However, we do allow particular individual formulas or fragments
  of L<sup><small>A</small></sup>T<small>E</small>X
  or HTML code to be formatted and still be part of the output files.</dd>
<dt>Limited index of identifiers</dt><dd class="quote"> Because <tt>WEB</tt> knows about Pascal,
  it is able to construct an index of all the identifiers occurring in
  the code sections (filtering out keywords and the standard type
  identifiers). Unfortunately, this isn't as easy in our case. We don't
  know what an identifier looks like in each language and we certainly
  don't know all the keywords.  We provide a mechanism to mark 
  identifiers, and we use a pretty standard pattern for recognizing
  identifiers almost most programming languages.</dd>
</dl>
<p class="quote">
Of course, we've got to have some compensation for our losses or the
whole idea would be a waste. Here are the advantages I [Briggs] can see:
</p>

<dl class="quote">
    <dt>Simplicity</dt>
        <dd class="quote">The majority of the commands in <tt>WEB</tt> are concerned with control of the automatic prettyprinting. Since we don't prettyprint, many commands are eliminated. A further set of commands is subsumed by L<sup><small>A</small></sup>T<small>E</small>X  and may also be eliminated. As a result, our set of commands is reduced to only about seven members (explained in the next section). This simplicity is also reflected in the size of this tool, which is quite a bit smaller than the tools used with other approaches.</dd>

    <dt>No prettyprinting</dt>
        <dd class="quote">Everyone disagrees about how their code should look, so automatic formatting annoys many people. One approach is to provide ways to control the formatting. Our approach is simpler -- we perform no automatic formatting and therefore allow the programmer complete control of code layout.</dd>

    <dt>Control</dt>
        <dd class="quote">We also offer the programmer reasonably complete control of the layout of his output files (the files generated during tangling). Of course, this is essential for languages that are sensitive to layout; but it is also important in many practical situations, <em>e.g.</em>, debugging.</dd>

    <dt>Speed</dt>
        <dd class="quote">Since [<em>pyWeb</em>] doesn't do too much, it runs very quickly. It combines the functions of <tt>tangle</tt> and <tt>weave</tt> into a single program that performs both functions at once.</dd>

    <dt>Chunk numbers</dt>
        <dd class="quote">Inspired by the example of <i>noweb</i>, [<em>pyWeb</em>] refers to all program code chunks by a simple, ascending sequence number through the file.  This becomes the HTML anchor name, also.</dd>

    <dt>Multiple file output</dt>
        <dd class="quote">The programmer may specify more than one output file in a single [<em>pyWeb</em>] source file. This is required when constructing programs in a combination of languages (say, Fortran and C). It's also an advantage when constructing very large programs.</dd>
</dl>

</div>

<h2>Use Cases</h2>
<p><em>pyWeb</em> supports two use cases, <i>Tangle Source Files</i> and <i>Weave Documentation</i>.
These are often combined into a single request of the application that will both
weave and tangle.</p>
<h3>Tangle Source Files</h3>
<p>A user initiates this process when they have a complete <tt>.w</tt> file that contains 
a description of source files.  These source files are described with <tt>@o</tt> commands
in the <tt>.w</tt> file.</p>
<p>The use case is successful when the source files are produced.</p>
<p>Outside this use case, the user will debug those source files, possibly updating the
<tt>.w</tt> file.  This will lead to a need to restart this use case.</p>
<p>The use case is a failure when the source files cannot be produced, due to 
errors in the <tt>.w</tt> file.  These must be corrected based on information in log messages.</p>
<p>The sequence is simply <tt>./pyweb.py <i>theFile</i>.w</tt>.</p>

<h3>Weave Source Files</h3>
<p>A user initiates this process when they have a <tt>.w</tt> file that contains 
a description of a document to produce.  The document is described by the entire
<tt>.w</tt> file.</p>
<p>The use case is successful when the documentation file is produced.</p>
<p>Outside this use case, the user will edit the documentation file, possibly updating the
<tt>.w</tt> file.  This will lead to a need to restart this use case.</p>
<p>The use case is a failure when the documentation file cannot be produced, due to 
errors in the <tt>.w</tt> file.  These must be corrected based on information in log messages.</p>
<p>The sequence is simply <tt>./pyweb.py <i>theFile</i>.w</tt>.</p>

<h3>Tangle, Regression Test and Weave</h3>
<p>A user initiates this process when they have a <tt>.w</tt> file that contains 
a description of a document to produce.  The document is described by the entire
<tt>.w</tt> file.  Further, their final document should include regression test output 
from the source files created by the tangle operation.</p>
<p>The use case is successful when the documentation file is produced, including
current regression test output.</p>
<p>Outside this use case, the user will edit the documentation file, possibly updating the
<tt>.w</tt> file.  This will lead to a need to restart this use case.</p>
<p>The use case is a failure when the documentation file cannot be produced, due to 
errors in the <tt>.w</tt> file.  These must be corrected based on information in log messages.</p>
<p>The use case is a failure when the documentation file does not include current
regression test output.</p>
<p>The sequence is as follows:</p>
<pre>
./pyweb.py -xw -pi <i>theFile</i>.w
python <i>theTest</i> &gt;<i>aLog</i>
./pyweb.py -xt <i>theFile</i>.w
</pre>
<p>The first step excludes weaving and permits errors on the <tt>@i</tt> command.  The <tt>-pi</tt> option
is necessary in the event that the log file does not yet exist.  The second step 
runs the regression test, creating a log file.  The third step weaves the final document,
including the regression test output.</p> 

<h2>Writing <em>pyWeb</em> .w Files</h2>
<p>The input to <em>pyWeb</em> is a <tt>.w</tt> file that consists of a
series of <i>Chunks</i>.  Each Chunk is either program source code to 
be <i>tangled</i> or it is documentation to be <i>woven</i>.  The bulk of
the file is typically documentation chunks that describe the program in
some human-oriented markup language like HTML 
or L<sup><small>A</small></sup>T<small>E</small>X.
</p>

<p>The <em>pyWeb</em> tool parses the input, and performs the
tangle and weave operations.  It <em>tangles</em> each individual output file
from the program source chunks.  It <em>weaves</em> a final documentation file
file from the entire sequence of chunks provided, mixing the author's 
original documentation with some markup around the embedded program source.
</p>

<p><em>pyWeb</em> defines a very simple markup system in which the code
chunks are surrounded with  tags.   The tags are used to assemble the tangled output
into the requested file(s).  The tags are replaced with markup so that 
a resulting woven document will process correctly through a browser
or LaTeX tool.
</p>

<p>The non-code chunks are not marked up in any way.  Everything that's not
explicitly a code chunk is simply output without modification.
</p>

<p>All of the <em>pyWeb</em> tags begin with <tt>@</tt>.  This can be changed.</p>

<p>The <i>Structural</i> tags (historically called "major commands") partition the input and define the
various chunks.  The <i>Inline</i> tags are (called "minor commands") are used to control the
woven and tangled output from those chunks.
</p>


<h3>Structure Tags</h3>
<p>There are two definitional tags; these define the various chunks
in an input file.  The </p>
<dl>
    <dt><tt>@o <i>file</i> @{ <i>text</i> @}</tt></dt>
        <dd>The <tt>@o</tt> (output) command defines a named output file chunk.  
        The text is tangled to the named
        file with no alteration.  It is woven into the document
        in an appropriate fixed-width font.</dd>
    <dt><tt>@d <i>name</i> @{ <i>text</i> @}</tt></dt>
        <dd>The <tt>@d</tt> (define) command defines a named chunk of program source. 
        This text is tangled
        or woven when it is referenced by the <i>reference</i> inline tag.</dd>
</dl

<p>Each <tt>@o</tt> and <tt>@d</tt> tag is followed by a chunk which is
delited by <tt>@{</tt> and <tt>@}</tt> tags.  
End the end of that chunk, there is an optional "major" tag.  
</p>
<dl>
    <dt><tt>@|</tt></dt>
        <dd>A chunk may define user identifiers.  The list of defined identifiers is placed
in the chunk, separated by the <tt>@|</tt> separator.</dd>
</dl>

Additionally, these tags provide for the inclusion of additional input files.
This is necessary for decomposing a long document into easy-to-edit sections.
<dl>
    <dt><tt>@i <i>file</i></tt></dt>
        <dd>The <tt>@i</tt> (include) command includes another file.  The previous chunk
        is ended.  The file is processed completely, then a new chunk
        is started for the text after the <tt>@i</tt> command.</dd>
</dl>

<p>All material that is not explicitly in a <tt>@o</tt> or <tt>@d</tt> named chunk is
implicitly collected into a sequence of anonymous document source chunks.
These anonymous chunks form the backbone of the document that is woven.
The anonymous chunks are never tangled into output program source files.
They are woven into the document without any alteration.
</p>
<p>Note that white space (line breaks (<tt>'\n'</tt>), tabs and spaces) have no effect on the input parsing.
They are completely preserved on output.</p>

<p>The following example has three chunks.  An anonymous chunk of
documentation, a named output chunk, and an anonymous chunk of documentation.
</p>
<pre><code>
&lt;p&gt;Some HTML documentation that describes the following piece of the
program.&lt;/p&gt;
@o myFile.py 
@{
import math
print math.pi
@| math math.pi
@}
&lt;p&gt;Some more HTML documentation.&lt;/p&gt;
</code></pre>

<h3>Inline Tags</h3>
<p>There are several tags that are replaced by content in the woven output.</p>
<dl>
    <dt><tt>@@</tt></dt>
        <dd>The <tt>@@</tt> command creates a single <tt>@</tt> in the output file.
        This is replaced in tangled as well as woven output.</dd>
    <dt><tt>@&lt;<i>name</i>@&gt;</tt></dt>
        <dd>The <i>name</i> references a named chunk.
        When tangling, the referenced chunk replaces the reference command.
        When weaving, a reference marker is used.  For example, in HTML, this can be 
        replaced with  <tt>&lt;A HREF=...&gt;</tt> markup.
        Note that the indentation of the <tt>@&lt;</tt> tag is preserved
        for the tangled chunk that replaces the tag.
        </dd>
    <dt><tt>@(<i>Python expression</i>@)</tt></dt>
        <dd>The <i>Python expression</i> is evaluated and the result is tangled or
        woven in place.  A few global variables and modules are available.
        These are described <a href="#expressionContext">below</a>.</dd>
</dl>

<p>There are three index creation tags that are replaced by content in the woven output.</p>

<dl>
    <dt><tt>@f</tt></dt>
        <dd>The <tt>@f</tt> command inserts a file cross reference.  This
        lists the name of each file created by an <tt>@o</tt> command, and all of the various
        chunks that are concatenated to create this file.</dd>
    <dt><tt>@m</tt></dt>
        <dd>The <tt>@m</tt> command inserts a named chunk ("macro") cross reference.  This
        lists the name of each chunk created by an @d command, and all of the various
        chunks that are concatenated to create the complete chunk.</dd>
    <dt><tt>@u</tt></dt>
        <dd>The <tt>@u</tt> command inserts a user identifier cross reference.  This
        lists the name of each chunk created by an <tt>@d</tt> command, and all of the various
        chunks that are concatenated to create the complete chunk.</dd>
</dl>

<h3>Document Overhead</h3>
<p>The documents generally need some minimal overheads to work correctly.</p>
<p>The <b>RST</b> weaver requires that you have <tt>..  include &lt;isoamsa.txt&gt;</tt></p>
<p>The <b>LaTeX</b> weaver requires that you have <tt>\usepackage{fancyvrb}</tt></p>

<h3>Additional Features</h3>
<p>The named chunks (from both <tt>@o</tt> and <tt>@d</tt> commands) are assigned 
unique sequence numbers to simplify cross references.  In LaTex it is possible 
to determine the page breaks and assign the sequence numbers based on
the physical pages.</p>
<p>Chunk names and file names are case sensitive.</p>

<p>Chunk names can be abbreviated.  A partial name can have a trailing ellipsis (...), 
this will be resolved to the full name.  The most typical use for this
is shown in the following example.</p>

<pre><code>
&lt;p&gt;Some HTML documentation.&lt;/p&gt;
@o myFile.py 
@{
@&lt;imports of the various packages used@&gt;
print math.pi,time.time()
@}
&lt;p&gt;Some notes on the packages used.&lt;/p&gt;
@d imports...
@{
import math,time
@| math time
@}
&lt;p&gt;Some more HTML documentation.&lt;/p&gt;
</code></pre>

<ol>
<li>An anonymous chunk of documentation.</li>
<li>A named chunk that tangles the <tt>myFile.py</tt> output.  It has
a reference to the <i>imports of the various packages used</i> chunk.
Note that the full name of the chunk is essentially a line of 
documentation, traditionally done as a comment line in a non-literate
programming environment.</li>
<li>An anonymous chunk of documentation.</li>
<li>A named chunk with an abbreviated name.  The <i>imports...</i>
matches the complete name.  Set off after the <tt>@|</tt> separator is
the list of identifiers defined in this chunk.</li>
<li>An anonymous chunk of documentation.</li>
</ol>

<p>Note that the first time a name appears (in a reference or definition),
it must be the full name.  All subsequent uses can be elisions.
Also not that ambiguous elision is an annoying problem when you 
first start creating a document.
</p>
<p>Named chunks are concatenated from their various pieces.
This allows a named chunk to be broken into several pieces, simplifying
the description.  This is most often used when producing 
fairly complex output files.</p>

<pre><code>
&lt;p&gt;An anonymous chunk with some HTML documentation.&lt;/p&gt;
@o myFile.py 
@{
import math,time
@}
&lt;p&gt;Some notes on the packages used.&lt;/p&gt;
@o myFile.py
@{
print math.pi,time.time()
@}
&lt;p&gt;Some more HTML documentation.&lt;/p&gt;
</code></pre>

<ol>
<li>An anonymous chunk of documentation.</li>
<li>A named chunk that tangles the <tt>myFile.py</tt> output.  It has
the first part of the file.  In the woven document
this is marked with <tt>"="</tt>.</li>
<li>An anonymous chunk of documentation.</li>
<li>A named chunk that also tangles the <tt>myFile.py</tt> output. This
chunk's content is appended to the first chunk.  In the woven document
this is marked with <tt>"+="</tt>.</li>
<li>An anonymous chunk of documentation.</li>
</ol>

<p>Newline characters are preserved on input.  Because of this the output may appear to have excessive newlines.  In all of the above examples, each
named chunk was defined with the following.</p>
<pre><code>
@{
import math,time
@}
</code></pre>
<p>This puts a newline character before and after the import line.</p>

<p>One transformation is performed when tangling output.  The indentation
of a chunk reference is applied to the entire chunk.  This makes it
simpler to prepare source for languages (like Python) where indentation
is important.  It also gives the author control over how the final
tangled output looks.</p>

<p>Also, note that the <tt>myFile.py</tt> uses the <tt>@|</tt> command
to show that this chunk defines the identifier <tt>aFunction</tt>.
</p>
<pre><code>
&lt;p&gt;An anonymous chunk with some HTML documentation.&lt;/p&gt;
@o myFile.py 
@{
def aFunction( a, b ):
    @&lt;body of the aFunction@&gt;
@| aFunction @}
&lt;p&gt;Some notes on the packages used.&lt;/p&gt;
@d body...
@{
"""doc string"""
return a + b
@}
&lt;p&gt;Some more HTML documentation.&lt;/p&gt;
</code></pre>

<p>The tangled output from this will look like the following.
All of the newline characters are preserved, and the reference to
<i>body of the aFunction</i> is indented to match the prevailing
indent where it was referenced.  In the following example, 
explicit line markers of <b><tt>~</tt></b> are provided to make the blank lines 
more obvious.
</p>
<pre><code>
~
~def aFunction( a, b ):
~        
~    """doc string"""
~    return a + b
~
</code></pre>

<p>There are two possible implementations for evaluation of a Python
expression in the input.</p>
<ol>
<li>Create an <b>ExpressionCommand</b>, and append this to the current <b>Chunk</b>.
This will allow evaluation during weave processing and during tangle processing.  This
makes the entire weave (or tangle) context available to the expression, including
completed cross reference information.</li>
<li>Evaluate the expression during input parsing, and append the resulting text
as a <b>TextCommand</b> to the current <b>Chunk</b>.  This provides a common result
available to both weave and parse, but the only context available is the <b>WebReader</b> and
the incomplete <b>Web</b>, built up to that point.</li>
</ol>
<a name="expressionContext"></a>
<p>In this implementation, we adopt the latter approach, and evaluate expressions immediately.
A simple global context is created with the following variables defined.</p>
<dl>
    <dt><tt>time</tt></dt><dd>This is the standard time module.</dd>
    <dt><tt>os</tt></dt><dd>This is the standard os module.</dd>
    <dt><tt>theLocation</tt></dt><dd>A tuple with the file name, first line number and last line number
    for the original expression's location</dd>
    <dt><tt>theWebReader</tt></dt><dd>The <b>WebReader</b> instance doing the parsing.</dd>
    <dt><tt>thisApplication</tt></dt><dd>The name of the running <em>pyWeb</em> application.</dd>
    <dt><tt>__version__</tt></dt><dd>The version string in the <em>pyWeb</em> application.</dd>
</dl>

<h2>Running <em>pyWeb</em> to Tangle and Weave</h2>

<p>Assuming that you have marked <tt>pyweb.py</tt> as executable,
you do the following.</p>
<pre>
./pyweb.py <i>file</i>...
</pre>
<p>This will tangle the <tt>@o</tt> commands in each <i>file</i>.
It will also weave the output, and create <i>file</i>.html.
</p>

<h3>Command Line Options</h3>
<p>Currently, the following command line options are accepted.</p>
<dl>
    <dt><tt>-v</tt></dt>
        <dd>Verbose logging.  The default is changed by updating the 
        <a href="#log_setting">constructor</a>
        for <i>theLog</i> from <tt>Logger(standard)</tt> to <tt>Logger(verbose)</tt>.</dd>
    <dt><tt>-s</tt></dt>
        <dd>Silent operation.  The default is changed by updating the 
        <a href="#log_setting">constructor</a>
        for <i>theLog</i> from <tt>Logger(standard)</tt> to <tt>Logger(silent)</tt>.</dd>
    <dt><tt>-c <i>x</i></tt></dt>
        <dd>Change the command character from <tt>@</tt> to <tt><i>x</i></tt>.
        The default is changed by updating the 
        <a href="#command_setting">constructor</a> for <i>theWebReader</i> from
        <tt>WebReader(f,'@')</tt> to <tt>WebReader(f,'<i>x</i>')</tt>.</dd>
    <dt><tt>-w <i>weaver</i></tt></dt>
        <dd>Choose a particular documentation weaver, for instance 'rst', 'html', 'latex'.  
        The default is based on the first few characters of the input file.
        You can do this by updating the 
        <a href="#pick_language">language determination</a> call in the application
        main function from <tt>l= w.language()</tt> to <tt>l= HTML()</tt>.</dd>
    <dt><tt>-xw</tt></dt>
        <dd>Exclude weaving.  This does tangling of source program files only.</dd>
    <dt><tt>-xt</tt></dt>
        <dd>Exclude tangling.  This does weaving of the document file only.</dd>
    <dt><tt>-p<i>command</i></tt></dt>
        <dd>Permit errors in the given list of commands.  The most common
        version is <tt>-pi</tt> to permit errors in locating an include file.
        This is done in the following scenario: pass 1 uses <tt>-xw -pi</tt> to exclude
        weaving and permit include-file errors; 
        the tangled program is run to create test results; pass 2 uses
        <tt>-xt</tt> to exclude tangling and include the test results.</dd>
</dl>


<h2>Restrictions</h2>
<p><em>pyWeb</em> requires any Python that supports <tt>from __future__ import print_function</tt>.
Generally  version 2.6. or newer.
</p>
<p>Currently, input is not detabbed; Python users generally are discouraged from using tab characters in their files.</p>

<h2>Installation</h2>
<p>You must have <a href="http://www.python.org">Python 2.6</a>.</p>
<ol>
<li>Download and expand pyweb.zip.  You will get pyweb.css, pyweb.html, pyweb.pdf,
pyweb.py and pyweb.w.</li>
<li>Except on Windows, <tt>chmod +x pyweb.py</tt>.</li>
<li>If you like, <tt>cp pyweb.py /usr/local/bin/pyweb</tt> to make a global command.</li>
<li>Make a bootstrap copy of pyweb.py (I copy it to pyweb-2.1.py).  
You can run <tt>./pyweb.py pyweb.w</tt> to generate the latest and greatest pyweb.py file,
as well as this documentation, pyweb.html.</li>
</ol>
<p>Be sure to save a bootstrap copy of pyweb.py before changing pyweb.w.  
Should your changes to pyweb.w introduce a bug into pyweb.py, you will need a fall-back version
of <em>pyWeb</em> that you can use in place of the one you just damaged.
</p>

<h2>Acknowledgements</h2>
<p>This application is very directly based on (derived from?) work that
 preceded this, particularly the following:</p>
<ul>
<li>Ross N. Williams' <a href="http://www.ross.net/funnelweb/"><i>FunnelWeb</i></a></li>
<li>Norman Ramsey's <a href="http://www.eecs.harvard.edu/~nr/noweb/"><i>noweb</i></a></li> 
<li>Preston Briggs' <a href="http://sourceforge.net/projects/nuweb/"><i>nuweb</i></a>, 
currently supported by Charles Martin and Marc W. Mengel</li>
</ul>
<p>Also, after using John Skaller's <a href="http://interscript.sourceforge.net/"><i>interscript</i></a>
for two large development efforts, I finally understood the feature set I really needed.
</p>
<p>Jason Fruit contributed the current LaTeX template segments being used.</p></div>

<a name="todo"></a><h1>To Do</h1>
<div class="chapter">

<!-- pyweb/todo.w -->

<ol>
<li>Fix OutputChunk to also include the comment convention for the file 
being produced.  While it's possible to guess from the file extension, 
this can be unwise.  '.py' is "#", '.java' or '.cpp' is '//', etc.
</li>
<li>Offer an HTML template with a code-quoting filter like 
<a href="http://www.reportlab.com/apis/reportlab/reportlab.lib.PyFontify-module.html">
PyFontify</a> or <a href="http://pygments.org/">Pygments</a> to add Syntax coloring
to a Python-specific HTML weaver.  
See <a href="http://docutils.sourceforge.net/sandbox/code-block-directive/docs/syntax-highlight.html">
Syntax Highlight</a> for more information.
</li>
<li>Rethink the MacroAction.  Is this really necessary?  Wouldn't the Application
be simpler without it?</li>
<li>Consider getting templates from a "header" section in the <tt>.w</tt> file.  This removes
any weaver command-line option; it's defined within the file.
Also, setting the command character can be done in the header.  
To support multiple projects, the header would probably be included with @i, indicating
that embedding in the <tt>.w</tt> file isn't as useful as keeping it separate.
See the <tt>weave.py</tt> example.</li>
<li>Offer a basic HTML template that uses CDATA sections instead of quoting.
Does require the standard quoting for the CDATA end tag.</li>
<li>The <b>createUsedBy()</b> method can be done incrementally by 
accumulating a list of forward references to chunks; as each
new chunk is added, any references to the chunk are removed from
the forward references list, and a call is made to the Web's
setUsage method.  References backward to already existing chunks
are easily resolved with a simple lookup.</li>
<li>Use a <b>Builder</b> pattern to plug an explicit <tt>WebBuilder</tt> instance
into the <tt>WebReader</tt> class to build the parse tree.   This can be overridden to,
for example, do incremental building in one pass.</li>
<li>Note that the Web is a lot like a NamedChunk; this could be factored out.
This will create a more proper Composition pattern implementation.</li>
</ol>
</div>

<a name="changes"></a><h1>Change Log</h1>
<div class="chapter">

<p>Changes since version 1.4.</p>
<ol>
<li>Removed home-brewed logger.</li>
<li>Replaced getopt with optparse.</li>
<li>Replaced LaTeX markup.</li>
<li>Corrected significant problems in cross-reference resolution.</li>
<li>Replaced all HTML and LaTeX-specific features with a much simpler template
engine which applies a template to a Chunk.  The Templates are separate
configuration items.  The big issue with templates are conditional processing
and the use of loops to handle multiple references in a transitive closure.
While it's nice to depend on Jinja2, it's also nice to be totally stand-alone.
Sigh.  Choices include the no-logic <tt>string.Template</tt> in the standard library
an the <tt>Templite+</tt> Recipe 576663.
</li>
<li>Looked at SCons API.  Renamed "Operation" to "Action"; renamed "perform" to "__call__".  
Consider having "__call__" which does logging, then call "execute".  Weaver fits nicely with SCons
Builder since we can see <tt>Weave( "someFile.w" )</tt> as sensible.  Tangling is tougher
because the <tt>@o</tt> commands define the dependencies there.  
</li>
<li>Eliminated the EmitterFactory; replace this with simple injection of
the proper template configuration.  
</li>
<li>Removed the <tt>@O</tt> command; it was essentially a variant template for LaTeX.</li>
<li>Disentangled indentation and quoting in the codeBlock.
Everyone needs indentation -- it's a lower-level feature of write.
Quoting, however, is unique to a woven codeBlock.  Fix referenceTo  to write
indented without code quoting.
</li>
<li>Offer an RST template.
Note that colorizing may be easier to handle with an RST template.
The weaving markup template degenerates 
to <tt>..   parsed-literal::</tt> and indent.  By doing this,
the RST output from <em>pyWeb</em> can be run through DocUtils <b>rst2html.py</b>
or perhaps <b>Sphix</b> to create final HTML.  <b>The hard part is the indent.</b>
</li> 
<li>Fixed ReferenceCommand tangle and all setIndent/clrIndent operations. 
Only a ReferenceCommand actually cares about indentation.  And that indentation
is totally based on the "context" plus the text in the Command immediate in front
of the ReferenceCommand.
</li>

</ol></div>

<a name="arch"></a><h1>Architecture and Design Overview</h1>
<div class="chapter">

<!-- pyweb/overview.w -->

<p>This application breaks the overall problem into the following sub-problems.</p>
<ol>
<li>Repesentation of the Web as Chunks and Commands</li>
<li>Reading and parsing the input.</li>
<li>Weaving a document file.</li>
<li>Tangling the desired program source files.</li>
</ol>

<h2>Representation</h2>
<p>The basic "parse tree" is actually quite flat.  The source document can be
decomposed into a simple sequence of Chunks.  Each Chunk is a simple sequence
of Commands.</p>
<p>Chunks and commands cannot be nested, leading to delightful simplification.</p>

<p>The overall parse "tree" is contained in the overall <b>Web</b>.  The web
includes the sequence of Chunks as well as an index for the Named chunks.
</p>
<p>Note that a named chunk may be created through a number of <tt>@d</tt> commands.
This means that
Each named chunk may be a sequence of Chunks with a common name.
</p>
<p>Each chunk is composed of a sequence of instances of <b>Command</b>.  
Because of this uniform composition, the several operations (particularly
weave and tangle) can be 
delegated to each Chunk, and in turn, delegated to each Command that
composes a Chunk.
</p>

<h2>Reading and Parsing</h2>
<p>A solution to the reading and parsing problem depends on a convenient 
tool for breaking up the input stream and a representation for the chunks of input.
Input decomposition is done with the Python <b>Splitter</b> pattern. 
</p>
<p>The Splitter pattern is widely used in text processing, and has a long legacy
in a variety of languages and libraries.  A Splitter decomposes a string into
a sequence of strings using the split pattern.  There are many variant implementations.
One variant locates only a single occurence (usually the left-most); this is
commonly implemented as a Find or Search string function.  Another variant locates all
occurrences of a specific string or character, and discards the matching string or
character.
</p>
<p>
The variation on Splitter that we use in this application
creates each element in the resulting sequence as either (1) an instance of the 
split regular expression or (2) the text between split patterns.  By preserving 
the actual split text, we can define our splitting pattern with the regular
expression <tt>'@.'</tt>.  This will split on any <tt>@</tt> followed by a single character.
We can then examine the instances of the split RE to locate pyWeb commands.
</p>
<p>We could be a tad more specific and use the following as a split pattern:
<tt>'@[doOifmu|<>(){}[\]]'</tt>.  This would silently ignore unknown commands, 
merging them in with the surrounding text.  This would leave the <tt>'@@'</tt> sequences 
completely alone, allowing us to replace <tt>'@@'</tt> with <tt>'@'</tt> in
every text chunk.
</p>

<h2>Weaving</h2>
<p>The weaving operation depends on the target document markup language.
There are several approaches to this problem.  One is to use a markup language
unique to <em>pyWeb</em>, and emit markup in the desired target language.
Another is to use a standard markup language and use converters to transform
the standard markup to the desired target markup.  The problem with the second
method is specifying the markup for actual source code elements in the
document.  These must be emitted in the proper markup language.
</p>
<p>Since the application must transform input into a specific markup language,
we opt using the Strategy pattern to encapsulate markup language details.
Each alternative markup strategy is then a subclass of <b>Weaver</b>.  This 
simplifies adding additional markup languages without inventing a 
markup language unique to <em>pyWeb</em>.
The author uses their preferred markup, and their preferred
toolset to convert to other output languages.
</p>

<h2>Tangling</h2>
<p>The tangling operation produces output files.  In earlier tools,
some care was taken to understand the source code context for tangling, and
provide a correct indentation.  This required a command-line parameter
to turn off indentation for languages like Fortran, where identation
is not used.  In <em>pyWeb</em>, the indent of
the actual <tt>@&lt;</tt> command is used to set the indent of the 
material that follows.  If all <tt>@&lt;</tt> commands are presented at the
left margin, no indentation will be done.  This is helpful simplification,
particularly for users of Python, where indentation is significant.
</p>
<p>The standard <b>Emitter</b> class handles this basic indentation.  A subclass can be 
created, if necessary, to handle more elaborate indentation rules.</p></div>

<a name="impl"></a><h1>Implementation</h1>
<div class="chapter">

<!-- pyweb/impl.w -->

<p>The implementation is contained in a file that both defines
the base classes and provides an overall <tt>main()</tt> function.  The <tt>main()</tt> 
function uses these base classes to weave and tangle the output files.
</p>

The broad outline of the presentation is as follows:

<ul>
<li><a href="#base">Base Class Definitions</a>.  This includes the web structure, 
the emitters (Weavers and Tanglers) and the high-level actions.</li>
<li><a href="#mod"><em>pyWeb</em> Module File</a>, including
Module Initialization, Application Class and <span class="code">main</span> function.</li>  
<li><a href="#scripts">Additional Scripts</a></li>
<li><a href="#admin">Administrative Elements</a></li>
</ul>

<a name="base"></a><h2>Base Class Definitions</h2>

<p>There are three major class hierarchies that compose the base of this application.  These are
families of related classes that express the basic relationships among entities.</p>
<ul>
<li>Emitters - An <span class="code">Emitter</span> creates an output file, either source code, LaTeX or HTML from
the chunks that make up the source file.  Two major subclasses are <span class="code">Weaver</span>, which 
has a focus on markup output, and <span class="code">Tangler</span> which has a focus on pure source output.
<span class="code">HTML</span> and <span class="code">LaTeX</span> are further specializations of the <span class="code">Weaver</span> class.  
The <span class="code">TanglerMake</span> subclass of the <span class="code">Tangler</span> class is a make-friendly source-code emitter.</li>
<li>Chunks - a <span class="code">Chunk</span> is a collection of <span class="code">Command</span> instances.  This can be
either an anonymous chunk that will be sent directly to the output, 
or one the classes of named chunks delimited by the
major <tt>@d</tt> or <tt>@o</tt> commands.</li>
<li>Commands - A <span class="code">Command</span> contains user input and creates output.  
This can be a block of text from the input file, 
one of the various kinds of cross reference commands (<tt>@f</tt>, <tt>@m</tt>, <tt>@u</tt>) 
or a reference to a chunk (via the <tt>@&lt;<i>name</i>@&gt;</tt> sequence).</li>
</ul>
<p>Additionally, there are several supporting classes:</p>
<ul>
<li>a <span class="code">Web</span> class for the interconnected web of Chunks.</li>
<li>a <span class="code">WebReader</span> class that parses the input, creating the Commands and Chunks.</li>
<li>an <span class="code">Error</span> class for exceptions that are unique to this application.</li>
</ul>


    <a name="pyweb1"></a>
    <!--line number 46-->
    <p><em>Base Class Definitions</em> (1)&nbsp;=</p>
    <code><pre>

<a href="#pyweb90">&rarr;<em>Error class - defines the errors raised</em> (90)</a>
<a href="#pyweb75">&rarr;<em>Command class hierarchy - used to describe individual commands</em> (75)</a>
<a href="#pyweb51">&rarr;<em>Chunk class hierarchy - used to describe input chunks</em> (51)</a>
<a href="#pyweb94">&rarr;<em>Web class - describes the overall "web" of chunks</em> (94)</a>
<a href="#pyweb2">&rarr;<em>Emitter class hierarchy - used to control output files</em> (2)</a>
<a href="#pyweb91">&rarr;<em>Reference class hierarchy - references to a chunk</em> (91)</a><a href="#pyweb92">(92)</a><a href="#pyweb93">(93)</a> 
<a href="#pyweb112">&rarr;<em>WebReader class - parses the input file, building the Web structure</em> (112)</a>
<a href="#pyweb131">&rarr;<em>Action class hierarchy - used to describe basic actions of the application</em> (131)</a>

    </pre></code>
    <p>&loz; <em>Base Class Definitions</em> (1).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h3>Emitters</h3>

<p>An <span class="code">Emitter</span> instance is resposible for control of an output file format.
This includes the necessary file naming, opening, writing and closing operations.
It also includes providing the correct markup for the file type.
</p>

<p>There are several subclasses of the <span class="code">Emitter</span> superclass, specialized for various file
formats.
</p>

    <a name="pyweb2"></a>
    <!--line number 68-->
    <p><em>Emitter class hierarchy - used to control output files</em> (2)&nbsp;=</p>
    <code><pre>

<a href="#pyweb3">&rarr;<em>Emitter superclass</em> (3)</a>
<a href="#pyweb13">&rarr;<em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em> (13)</a>
<a href="#pyweb23">&rarr;<em>LaTeX subclass of Weaver</em> (23)</a>
<a href="#pyweb31">&rarr;<em>HTML subclass of Weaver</em> (31)</a><a href="#pyweb32">(32)</a>
<a href="#pyweb43">&rarr;<em>Tangler subclass of Emitter to create source files with no markup</em> (43)</a>
<a href="#pyweb48">&rarr;<em>Tangler subclass which is make-sensitive</em> (48)</a>

    </pre></code>
    <p>&loz; <em>Emitter class hierarchy - used to control output files</em> (2).
      Used by <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>An <span class="code">Emitter</span> instance is created to contain the various details of
writing an output file.  Emitters are created as follows:
</p>
<ol>
<li>A <span class="code">Web</span> object will create an <span class="code">Emitter</span> to <em>weave</em> the final document.</li>
<li>A <span class="code">Web</span> object will create an <span class="code">Emitter</span> to <em>tangle</em> each file.</li>
</ol>
<p>Since each <span class="code">Emitter</span> instance is responsible for the details of one file
type, different subclasses of Emitter are used when tangling source code files (<span class="code">Tangler</span>) and 
weaving files that include source code plus markup (<span class="code">Weaver</span>).
</p>
<p>
Further specialization is required when weaving HTML or LaTeX.  Generally, this is 
a matter of providing two things:
<ul>
<li>Boilerplate text to replace various pyWeb constructs</li>
<li>Escape rules to make source code amenable to the markup language</li>
</ul>
</p>
<p>An additional part of the escape rules can include using a syntax coloring 
toolset instead of simply applying escapes.
</p>
<p>In the case of tangling, the following algorithm is used:</p>
<ol>
<li>Visit each each output <span class="code">Chunk</span> (<tt>@o</tt>), doing the following:
    <ol>
    <li>Open the <span class="code">Tangler</span> instance using the target file name.</li>
    <li>Visit each <span class="code">Chunk</span> directed to the file, calling the chunk's <span class="code">tangle()</span> method.
        <ol>
        <li>Call the Tangler's <span class="code">docBegin()</span> method.  This sets the Tangler's indents.</li>
        <li>Visit each <span class="code">Command</span>, call the command's <span class="code">tangle()</span> method.  For the text
            of the chunk, the
            text is written to the tangler using the <span class="code">codeBlock()</span> method.  For
            references to other chunks, the referenced chunk is tangled using the 
            referenced chunk's <span class="code">tangler()</span> method.</li>
        <li>Call the Tangler's <span class="code">docEnd()</span> method.  This clears the Tangler's indents.</li>
        </ol>
    </li>
    </ol>
</li>
</ol>
<p>In the case of weaving, the following algorithm is used:</p>
<ol>
<li>If no Weaver is given, examine the first Command of the first Chunk and create a weaver
appropriate for the output format.  A leading '<' indicates HTML, otherwise assume LaTeX.
<li>Open the <span class="code">Weaver</span> instance using the source file name.  This name is transformed
by the weaver to an output file name appropriate to the language.</li>
<li>Visit each each sequential <span class="code">Chunk</span> (anonymous, <tt>@d</tt> or <tt>@o</tt>), doing the following:
    <ol>
    <li>Visit each <span class="code">Chunk</span>, calling the Chunk's <span class="code">weave()</span> method.
        <ol>
        <li>Call the Weaver's <span class="code">docBegin()</span>, <span class="code">fileBegin()</span> or <span class="code">codeBegin()</span> method, 
        depending on the subclass of Chunk.  For 
        <span class="code">fileBegin()</span> and <span class="code">codeBegin()</span>, this writes the header for
        a code chunk in the weaver's markup language.  A slightly different decoration
        is applied by <span class="code">fileBegin()</span> and <span class="code">codeBegin()</span>.</li>
        <li>Visit each <span class="code">Command</span>, call the Command's <span class="code">weave()</span> method.  
            For ordinary text, the
            text is written to the Weaver using the <span class="code">codeBlock()</span> method.  For
            references to other chunks, the referenced chunk is woven using 
            the Weaver's <span class="code">referenceTo()</span> method.</li>
        <li>Call the Weaver's <span class="code">docEnd()</span>, <span class="code">fileEnd()</span> or <span class="code">codeEnd()</span> method.  
        For <span class="code">fileEnd()</span> or <span class="code">codeEnd()</span>, this writes a trailer for
        a code chunk in the Weaver's markup language.</li>
        </ol>
    </li>
    </ol>
</li>
</ol>

<h4>Emitter Superclass</h4>

<h5>Usage</h5>
<p>The <span class="code">Emitter</span> class is not a concrete class; it is never instantiated.  It
contains common features factored out of the <span class="code">Weaver</span> and <span class="code">Tangler</span> subclasses.</p>
<p>Inheriting from the Emitter class generally requires overriding one or more
of the core methods: <span class="code">doOpen()</span>, <span class="code">doClose()</span> and <span class="code">doWrite()</span>.
A subclass of Tangler, might override the code writing methods: 
<span class="code">codeLine()</span>, <span class="code">codeBlock()</span> or <span class="code">codeFinish()</span>.
</p>

<h5>Design</h5>

<p>The <span class="code">Emitter</span> class is an abstract superclass for all emitters.  It defines the basic
framework used to create and write to an output file.
This class follows the <i>Template</i> design pattern.  This design pattern
directs us to factor the basic open(), close() and write() methods into three step algorithms.
</p>
<pre>
def open( self ):
    <i>common preparation</i>
    self.do_open() <i>#overridden by subclasses</i>
    <i>common finish-up tasks</i>
</pre>
<p>The <i>common preparation</i> and <i>common finish-up</i> sections are generally internal 
housekeeping.  The <span class="code">do_open()</span> method would be overridden by subclasses to change the
basic behavior.
</p>

<h5>Implementation</h5>

<p>The class has the following attributes:</p>
<ul>
<li><i>fileName</i>, the name of the current open file created by the
open method;</li>
<li><i>theFile</i>, the current open file created by the
open method;</li>
<li><i>context</i>, the indentation context stack, updated by setIndent, clrIndent 
and resetIndent methods;</li>
<li><i>indent</i>, the current indentation, the topmost value on the <i>context</i>
stack;</li>
<li><i>lastIndent</i>, the last indent used when writing a line of source code.</li>
<li><i>linesWritten</i>, the total number of '\n' characters written to the file.</li>
</ul>


    <a name="pyweb3"></a>
    <!--line number 193-->
    <p><em>Emitter superclass</em> (3)&nbsp;=</p>
    <code><pre>

class Emitter( object ):
    &quot;&quot;&quot;Emit an output file; handling indentation context.&quot;&quot;&quot;
    def __init__( self ):
        self.fileName= &quot;&quot;
        self.theFile= None
        self.context= [0]
        self.indent= 0
        self.lastIndent= 0
        self.linesWritten= 0
        self.totalFiles= 0
        self.totalLines= 0
        self.log_indent= logging.getLogger( &quot;pyweb.%s.indent&quot; % self.__class__.__name__ )
    def __str__( self ):
        return self.__class__.__name__
    <a href="#pyweb4">&rarr;<em>Emitter core open, close and write</em> (4)</a>
    <a href="#pyweb8">&rarr;<em>Emitter write a block of code</em> (8)</a><a href="#pyweb9">(9)</a><a href="#pyweb10">(10)</a>
    <a href="#pyweb11">&rarr;<em>Emitter indent control: set, clear and reset</em> (11)</a>

    </pre></code>
    <p>&loz; <em>Emitter superclass</em> (3).
      Used by <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The core <span class="code">open()</span> method tracks the open files.
A subclass overrides a <span class="code">doOpen()</span> method to name the output file, and
then actually open the file.  The Weaver will create an output file with
a name that's based on the overall project.  The Tangler will open the given file
name.
</p>
<p>The <span class="code">close()</span> method closes the file.  As with  <span class="code">open()</span>, a
<span class="code">doClose()</span> method actually closes the file.  This allows subclasses
to do overrides on the actual file processing.
</p>
<p>The <span class="code">write()</span> method is the lowest-level, unadorned write.
This does no some additional counting as well as moving the
characters to the file.  Any further processing could be added in a function
that overrides <span class="code">doWrite()</span>.
</p>
<p>The default <span class="code">write()</span> method prints to  the standard output file.
</p>


    <a name="pyweb4"></a>
    <!--line number 233-->
    <p><em>Emitter core open, close and write</em> (4)&nbsp;=</p>
    <code><pre>

def open( self, aFile ):
    &quot;&quot;&quot;Open a file.&quot;&quot;&quot;
    self.fileName= aFile
    self.doOpen( aFile )
    self.linesWritten= 0
<a href="#pyweb5">&rarr;<em>Emitter doOpen, to be overridden by subclasses</em> (5)</a>
def close( self ):
    self.codeFinish()
    self.doClose()
    self.totalFiles += 1
    self.totalLines += self.linesWritten
<a href="#pyweb6">&rarr;<em>Emitter doClose, to be overridden by subclasses</em> (6)</a>
def write( self, text ):
    if text is None: return
    self.linesWritten += text.count('\n')
    self.doWrite( text )
<a href="#pyweb7">&rarr;<em>Emitter doWrite, to be overridden by subclasses</em> (7)</a>

    </pre></code>
    <p>&loz; <em>Emitter core open, close and write</em> (4).
      Used by <a href="#pyweb3"><em>Emitter superclass</em>&nbsp;(3)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">doOpen()</span>, <span class="code">doClose()</span> and <span class="code">doWrite()</span> 
method is overridden by the various subclasses to
perform the unique operation for the subclass.
</p>

    <a name="pyweb5"></a>
    <!--line number 258-->
    <p><em>Emitter doOpen, to be overridden by subclasses</em> (5)&nbsp;=</p>
    <code><pre>

def doOpen( self, aFile ):
    self.fileName= aFile
    logger.debug( &quot;creating %r&quot;, self.fileName )

    </pre></code>
    <p>&loz; <em>Emitter doOpen, to be overridden by subclasses</em> (5).
      Used by <a href="#pyweb4"><em>Emitter core open, close and write</em>&nbsp;(4)</a>; <a href="#pyweb3"><em>Emitter superclass</em>&nbsp;(3)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb6"></a>
    <!--line number 265-->
    <p><em>Emitter doClose, to be overridden by subclasses</em> (6)&nbsp;=</p>
    <code><pre>

def doClose( self ):
    logger.debug( &quot;wrote %d lines to %s&quot;,
        self.linesWritten, self.fileName )

    </pre></code>
    <p>&loz; <em>Emitter doClose, to be overridden by subclasses</em> (6).
      Used by <a href="#pyweb4"><em>Emitter core open, close and write</em>&nbsp;(4)</a>; <a href="#pyweb3"><em>Emitter superclass</em>&nbsp;(3)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb7"></a>
    <!--line number 272-->
    <p><em>Emitter doWrite, to be overridden by subclasses</em> (7)&nbsp;=</p>
    <code><pre>

def doWrite( self, text ):
    print( text, end=None )

    </pre></code>
    <p>&loz; <em>Emitter doWrite, to be overridden by subclasses</em> (7).
      Used by <a href="#pyweb4"><em>Emitter core open, close and write</em>&nbsp;(4)</a>; <a href="#pyweb3"><em>Emitter superclass</em>&nbsp;(3)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



<p>The <span class="code">codeBlock()</span> method writes several lines of code.  It calls
the <span class="code">codeLine()</span> method for each line of code after doing the correct indentation.
Often, the last line of code is incomplete, so it is left unterminated.
This last line of code also shows the indentation for any 
additional code to be tangled into this section.
</p>
<p>
Note that tab characters confuse the indent algorithm.  Tabs are 
not expanded to spaces in this application.  They should be expanded 
prior to creating a .w file.
</p>
<p>The algorithm is as follows:</p>
<ol>
<li>Save the topmost value of the context stack as the current indent.</li>
<li>Split the block of text on <tt>'\n'</tt> boundaries.</li>
<li>For each line (except the last), call <span class="code">codeLine()</span> with the indented text, 
ending with a newline.</li>
<li>The string <span class="code">split()</span> method will put a trailing 
zero-length element in the list if the original block ended with a
newline.  We drop this zero length piece to prevent writing a useless fragment 
of indent-only after the final <tt>'\n'</tt>.  
If the last line has content, call codeLine with the indented text, 
but do not write a trailing <tt>'\n'</tt>.</li>
<li>Save the length of the last line as the most recent indent.</li>
</ol>


    <a name="pyweb8"></a>
    <!--line number 306-->
    <p><em>Emitter write a block of code</em> (8)&nbsp;=</p>
    <code><pre>

def codeBlock( self, text ):
    &quot;&quot;&quot;Indented write of a block of code.&quot;&quot;&quot;
    self.indent= self.context[-1]
    lines= text.split( '\n' )
    for l in lines[:-1]:
        self.write( '%s%s\n' % (self.indent*' ',l) )
    if lines[-1]:
        self.write( '%s%s' % (self.indent*' ',lines[-1]) )
    self.lastIndent= len(lines[-1]) + self.indent

    </pre></code>
    <p>&loz; <em>Emitter write a block of code</em> (8).
      Used by <a href="#pyweb3"><em>Emitter superclass</em>&nbsp;(3)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">codeLine()</span> method writes a single line of source code.
This is often overridden by Weaver subclasses to transform source into
a form acceptable by the final weave file format.
</p>
<p>In the case of an HTML weaver, the HTML reserved characters
(<tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&amp;</tt>, and <tt>&quot;</tt>) must be replaced in the output
of code.  However, since the author's original document sections contain
HTML these will not be altered.
</p>


    <a name="pyweb9"></a>
    <!--line number 330-->
    <p><em>Emitter write a block of code</em> (9)&nbsp;+=</p>
    <code><pre>

quoted_chars = [
    # Must be empty for tangling to work.
]

def quote( self, aLine ):
    &quot;&quot;&quot;Each individual line of code; often overridden by weavers to quote the code.&quot;&quot;&quot;
    clean= aLine
    for from_, to_ in self.quoted_chars:
        clean= clean.replace( from_, to_ )
    return clean

    </pre></code>
    <p>&loz; <em>Emitter write a block of code</em> (9).
      Used by <a href="#pyweb3"><em>Emitter superclass</em>&nbsp;(3)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">codeFinish()</span> method finishes writing any cached lines when
the emitter is closed.</p>


    <a name="pyweb10"></a>
    <!--line number 348-->
    <p><em>Emitter write a block of code</em> (10)&nbsp;+=</p>
    <code><pre>

def codeFinish( self ):
    if self.lastIndent &gt; 0:
        self.write('\n')

    </pre></code>
    <p>&loz; <em>Emitter write a block of code</em> (10).
      Used by <a href="#pyweb3"><em>Emitter superclass</em>&nbsp;(3)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">setIndent()</span> method pushes the last indent on the context stack.  
This is used when tangling source
to be sure that the included text is indented correctly with respect to the
surrounding text.
</p>
<p>The <span class="code">clrIndent()</span> method discards the most recent indent from the context stack.  
This is used when finished
tangling a source chunk.  This restores the indent to the prevailing indent.
</p>
<p>The <span class="code">resetIndent()</span> method removes all indent context information.
</p>

<blockquote><p>TODO:  Note that <span class="code">setIndent()</span> should be
refactored, since tangling uses the <tt>command</tt> option and weaving uses
the <tt>fixed</tt> option.
</blockquote>


    <a name="pyweb11"></a>
    <!--line number 373-->
    <p><em>Emitter indent control: set, clear and reset</em> (11)&nbsp;=</p>
    <code><pre>

def setIndent( self, fixed=None, command=None ):
    &quot;&quot;&quot;Either use a fixed indent (for weaving) or the previous command (for tangling).&quot;&quot;&quot;
    self.context.append( self.context[-1]+command.indent() if fixed is None else fixed )
    self.log_indent.debug( &quot;setIndent %s: %r&quot;, fixed, self.context )
def clrIndent( self ):
    if len(self.context) &gt; 1:
        self.context.pop()
    self.indent= self.context[-1]
    self.log_indent.debug( &quot;clrIndent %r&quot;, self.context )
def resetIndent( self ):
    self.context= [0]
    self.log_indent.debug( &quot;resetIndent %r&quot;, self.context )

    </pre></code>
    <p>&loz; <em>Emitter indent control: set, clear and reset</em> (11).
      Used by <a href="#pyweb3"><em>Emitter superclass</em>&nbsp;(3)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>Weaver subclass of Emitter</h4>
<h5>Usage</h5>
<p>A Weaver is an Emitter that produces the final user-focused document.
This will include the source document with the code blocks surrounded by
markup to present that code properly.  In effect, the pyWeb <tt>@</tt> commands
are replaced by markup.
</p>
<p>
The Weaver class uses a simple set of templates to product RST markup.
</p>
<p>Most weaver languages don't rely on special indentation rules.
The woven code samples usually start right on the left margin of 
the source document.  However, the RST markup language does rely
on indentation of code blocks.  For that reason, the weavers
have a fixed indent for code blocks.  This is generally 
set to zero, except when generating RST.
</p>

<h5>Design</h5>
<p>The <span class="code">Weaver</span> subclass defines an <span class="code">Emitter</span> used to <em>weave</em> the final
documentation.  This involves decorating source code to make it
displayable.  It also involves creating references and cross
references among the various chunks.
</p>
<p>The <span class="code">Weaver</span> class adds several methods to the basic <span class="code">Emitter</span> methods.  These
additional methods are also included that are used exclusively when weaving, never when tangling.
</p>

<h5>Implementation</h5>
<p>This class hierarch depends heavily on the <span class="code">string</span> module.


    <a name="pyweb12"></a>
    <!--line number 421-->
    <p><em>Imports</em> (12)&nbsp;=</p>
    <code><pre>
import string

    </pre></code>
    <p>&loz; <em>Imports</em> (12).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb13"></a>
    <!--line number 426-->
    <p><em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em> (13)&nbsp;=</p>
    <code><pre>

class Weaver( Emitter ):
    &quot;&quot;&quot;Format various types of XRef's and code blocks when weaving.&quot;&quot;&quot;
    extension= &quot;.rst&quot; # A subclass will provide their preferred extension
    code_indent= 4
    <a href="#pyweb14">&rarr;<em>Weaver doOpen, doClose and doWrite overrides</em> (14)</a>
    
    # Template Expansions.
    <a href="#pyweb15">&rarr;<em>Weaver quoted characters</em> (15)</a>
    <a href="#pyweb16">&rarr;<em>Weaver document chunk begin-end</em> (16)</a>
    <a href="#pyweb17">&rarr;<em>Weaver reference summary, used by code chunk and file chunk</em> (17)</a>
    <a href="#pyweb18">&rarr;<em>Weaver code chunk begin-end</em> (18)</a>
    <a href="#pyweb19">&rarr;<em>Weaver file chunk begin-end</em> (19)</a>
    <a href="#pyweb20">&rarr;<em>Weaver reference command output</em> (20)</a>
    <a href="#pyweb21">&rarr;<em>Weaver cross reference output methods</em> (21)</a><a href="#pyweb22">(22)</a>

    </pre></code>
    <p>&loz; <em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em> (13).
      Used by <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The open method opens the file for writing.  For weavers, the file extension
is specified part of the target markup language being created.
</p>
<p>The close method overrides the <span class="code">Emitter</span> class <span class="code">close()</span> method by closing the
actual file created by the open() method.
</p>
<p>This write method overrides the <span class="code">Emitter</span> class <span class="code">write()</span> method by writing to the
actual file created by the <span class="code">open()</span> method.
</p>


    <a name="pyweb14"></a>
    <!--line number 455-->
    <p><em>Weaver doOpen, doClose and doWrite overrides</em> (14)&nbsp;=</p>
    <code><pre>

def doOpen( self, aFile ):
    src, _ = os.path.splitext( aFile )
    self.fileName= src + self.extension
    self.theFile= open( self.fileName, &quot;w&quot; )
    logger.info( &quot;Weaving %r&quot;, self.fileName )
def doClose( self ):
    self.theFile.close()
    logger.info( &quot;Wrote %d lines to %r&quot;, 
        self.linesWritten, self.fileName )
def doWrite( self, text ):
    self.theFile.write( text )

    </pre></code>
    <p>&loz; <em>Weaver doOpen, doClose and doWrite overrides</em> (14).
      Used by <a href="#pyweb13"><em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em>&nbsp;(13)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The remaining methods apply a chunk to a template.</p>


    <a name="pyweb15"></a>
    <!--line number 473-->
    <p><em>Weaver quoted characters</em> (15)&nbsp;=</p>
    <code><pre>

quoted_chars = [
    # prevent some RST markup from being recognized
    ('`',r'\`'),
    ('_',r'\_'), 
    ('*',r'\*'),
    ('|',r'\|'),
]

    </pre></code>
    <p>&loz; <em>Weaver quoted characters</em> (15).
      Used by <a href="#pyweb13"><em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em>&nbsp;(13)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">docBegin()</span> and <span class="code">docEnd()</span> 
methods are used when weaving a document text chunk.
Typically, nothing is done before emitting these kinds of chunks.
However, putting a <tt>&lt;!--line number--&gt;</tt> comment is an example
of possible additional processing.
</p>


    <a name="pyweb16"></a>
    <!--line number 491-->
    <p><em>Weaver document chunk begin-end</em> (16)&nbsp;=</p>
    <code><pre>

def docBegin( self, aChunk ):
    pass
def docEnd( self, aChunk ):
    pass

    </pre></code>
    <p>&loz; <em>Weaver document chunk begin-end</em> (16).
      Used by <a href="#pyweb13"><em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em>&nbsp;(13)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>Each code chunk includes the places where the chunk is referenced</p>

    <a name="pyweb17"></a>
    <!--line number 501-->
    <p><em>Weaver reference summary, used by code chunk and file chunk</em> (17)&nbsp;=</p>
    <code><pre>

ref_template = string.Template( &quot;\nUsed by: ${refList}\n&quot; )
ref_item_template = string.Template( &quot;$fullName (`${seq}`_)&quot; )
def references( self, aChunk ):
    if aChunk.references_list:
        refList= [ 
            self.ref_item_template.substitute( seq=s, fullName=n )
            for n,s in aChunk.references_list ]
        return self.ref_template.substitute( refList=&quot;; &quot;.join( refList ) ) # HTML Separator
    return &quot;&quot;

    </pre></code>
    <p>&loz; <em>Weaver reference summary, used by code chunk and file chunk</em> (17).
      Used by <a href="#pyweb13"><em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em>&nbsp;(13)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



<p>The <span class="code">codeBegin()</span> method emits the necessary material prior to 
a chunk of source code, defined with the <tt>@d</tt> command.
</p>
<p>The <span class="code">codeEnd()</span> method emits the necessary material subsequent to 
a chunk of source code, defined with the <tt>@d</tt> command.  
Links or cross references to chunks that 
refer to this chunk can be emitted.
</p>


    <a name="pyweb18"></a>
    <!--line number 525-->
    <p><em>Weaver code chunk begin-end</em> (18)&nbsp;=</p>
    <code><pre>

cb_template = string.Template( &quot;\n..  _`${seq}`:\n..  rubric:: ${fullName} (${seq})\n..  parsed-literal::\n    &quot; )
def codeBegin( self, aChunk ):
    tex = self.cb_template.substitute( 
        seq= aChunk.seq,
        lineNumber= aChunk.lineNumber, 
        fullName= aChunk.fullName,
        concat= &quot;=&quot; if aChunk.initial else &quot;+=&quot;, # LaTeX Separator
    )
    self.write( tex )
ce_template = string.Template( &quot;\n${references}\n&quot; )
def codeEnd( self, aChunk ):
    tex = self.ce_template.substitute( 
        seq= aChunk.seq,
        lineNumber= aChunk.lineNumber, 
        fullName= aChunk.fullName,
        references= self.references( aChunk ),
    )
    self.write(tex)

    </pre></code>
    <p>&loz; <em>Weaver code chunk begin-end</em> (18).
      Used by <a href="#pyweb13"><em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em>&nbsp;(13)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">fileBegin()</span> method emits the necessary material prior to 
a chunk of source code, defined with the <tt>@o</tt> command.
A subclass would override this to provide specific text
for the intended file type.
</p>
<p>The <span class="code">fileEnd()</span> method emits the necessary material subsequent to 
a chunk of source code, defined with the <tt>@o</tt> command.  
The list of references
is also provided so that links or cross references to chunks that 
refer to this chunk can be emitted.
A subclass would override this to provide specific text
for the intended file type.
</p>


    <a name="pyweb19"></a>
    <!--line number 562-->
    <p><em>Weaver file chunk begin-end</em> (19)&nbsp;=</p>
    <code><pre>

fb_template = string.Template( &quot;\n..  _`${seq}`:\n..  rubric:: ${fullName} (${seq})\n..  parsed-literal::\n    &quot; )
def fileBegin( self, aChunk ):
    txt= self.fb_template.substitute(
        seq= aChunk.seq, 
        lineNumber= aChunk.lineNumber, 
        fullName= aChunk.fullName,
        concat= &quot;=&quot; if aChunk.initial else &quot;+=&quot;, # HTML Separator
    )
    self.write( txt )
fe_template= string.Template( &quot;\n${references}\n&quot; )
def fileEnd( self, aChunk ):
    txt= self.fe_template.substitute(
        seq= aChunk.seq, 
        lineNumber= aChunk.lineNumber, 
        fullName= aChunk.fullName,
        references= self.references( aChunk ) )
    self.write( txt )

    </pre></code>
    <p>&loz; <em>Weaver file chunk begin-end</em> (19).
      Used by <a href="#pyweb13"><em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em>&nbsp;(13)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">referenceTo()</span> method emits a reference to 
a chunk of source code.  There reference is made with a
<tt>@&lt;...@&gt;</tt> reference  within a <tt>@d</tt> or <tt>@o</tt> chunk.
The references are defined with the <tt>@d</tt> or <tt>@o</tt> commands.  
A subclass would override this to provide specific text
for the intended file type.
</p>


    <a name="pyweb20"></a>
    <!--line number 592-->
    <p><em>Weaver reference command output</em> (20)&nbsp;=</p>
    <code><pre>

refto_name_template= string.Template(&quot;&quot;&quot;|srarr| ${fullName} (`${seq}`_)&quot;&quot;&quot;)
refto_seq_template= string.Template(&quot;&quot;&quot;|srarr| (`${seq}`_)&quot;&quot;&quot;)
def referenceTo( self, aName, seq ):
    &quot;&quot;&quot;Weave a reference to a chunk.&quot;&quot;&quot;
    # Provide name to get a full reference.
    # Omit name to get a short reference.
    if aName:
        return self.refto_name_template.substitute( fullName= aName, seq= seq )
    else:
        return self.refto_seq_template.substitute( seq= seq )

    </pre></code>
    <p>&loz; <em>Weaver reference command output</em> (20).
      Used by <a href="#pyweb13"><em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em>&nbsp;(13)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">xrefHead()</span> method puts decoration in front of cross-reference
output.  A subclass may override this to change the look of the final
woven document.
</p>
<p>The <span class="code">xrefFoot()</span> method puts decoration after cross-reference
output.  A subclass may override this to change the look of the final
woven document.
</p>
<p>The <span class="code">xrefLine()</span> method is used for both 
file and chunk ("macro") cross-references to show a name (either file name
or chunk name) and a list of chunks that reference the file or chunk.
</p>
<p>The <span class="code">xrefDefLine()</span> method is used for the user identifier cross-reference.
This shows a name and a list of chunks that 
reference or define the name.  One of the chunks is identified as the
defining chunk, all others are referencing chunks.
</p>
<p>The default behavior simply writes the Python data structure used
to represent cross reference information.  A subclass may override this 
to change the look of the final woven document.
</p>


    <a name="pyweb21"></a>
    <!--line number 629-->
    <p><em>Weaver cross reference output methods</em> (21)&nbsp;=</p>
    <code><pre>

xref_head_template = string.Template( &quot;\n&quot; )
xref_foot_template = string.Template( &quot;\n&quot; )
xref_item_template = string.Template( &quot;:${fullName}:\n    ${refList}\n&quot; )
def xrefHead( self ):
    txt = self.xref_head_template.substitute()
    self.write( txt )
def xrefFoot( self ):
    txt = self.xref_foot_template.substitute()
    self.write( txt )
def xrefLine( self, name, refList ):
    refList= [ self.referenceTo( None, r ) for r in refList ]
    txt= self.xref_item_template.substitute( fullName= name, refList = &quot; &quot;.join(refList) ) # HTML Separator
    self.write( txt )

    </pre></code>
    <p>&loz; <em>Weaver cross reference output methods</em> (21).
      Used by <a href="#pyweb13"><em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em>&nbsp;(13)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>xref Def Line...</p>


    <a name="pyweb22"></a>
    <!--line number 648-->
    <p><em>Weaver cross reference output methods</em> (22)&nbsp;+=</p>
    <code><pre>

name_def_template = string.Template( '[`${seq}`_]' )
name_ref_template = string.Template( '`${seq}`_' )
def xrefDefLine( self, name, defn, refList ):
    templates = { defn: self.name_def_template }
    refTxt= [ templates.get(r,self.name_ref_template).substitute( seq= r )
        for r in sorted( refList + [defn] ) 
        ]
    txt= self.xref_item_template.substitute( fullName= name, refList = &quot; &quot;.join(refTxt) ) # HTML Separator
    self.write( txt )

    </pre></code>
    <p>&loz; <em>Weaver cross reference output methods</em> (22).
      Used by <a href="#pyweb13"><em>Weaver subclass of Emitter to create documentation with fancy markup and escapes</em>&nbsp;(13)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>LaTeX subclass of Weaver</h4>
<h5>Usage</h5>
<p>An instance of <span class="code">LaTeX</span> can be used by the <span class="code">Web</span> object to 
weave an output document.  The instance is created outside the Web, and
given to the <span class="code">weave()</span> method of the Web.
</p>
<pre>
w= Web( "someName.w" )
WebReader().web(w).load()
weave_latex= LaTeX()
w.weave( weave_latex )
</pre>

<p>Note that the template language and LaTeX both use <tt>$</tt>.
This means that all  <tt>$</tt> that are intended to be output to LaTeX
must appear as <tt>$$</tt> in the template.
</p>

<h5>Design</h5>
<p>The <span class="code">LaTeX</span> subclass defines a Weaver that is customized to
produce LaTeX output of code sections and cross reference information.
Its markup is pretty rudimentary, but it's also distinctive enough to
function pretty well in most <b>LaTeX</b> documents.
</p>

<h5>Implementation</h5>


    <a name="pyweb23"></a>
    <!--line number 689-->
    <p><em>LaTeX subclass of Weaver</em> (23)&nbsp;=</p>
    <code><pre>

class LaTeX( Weaver ):
    &quot;&quot;&quot;LaTeX formatting for XRef's and code blocks when weaving.
    Requires \\usepackage{fancyvrb}
    &quot;&quot;&quot;
    extension= &quot;.tex&quot;
    code_indent= 0
    <a href="#pyweb24">&rarr;<em>LaTeX code chunk begin</em> (24)</a>
    <a href="#pyweb25">&rarr;<em>LaTeX code chunk end</em> (25)</a>
    <a href="#pyweb26">&rarr;<em>LaTeX file output begin</em> (26)</a>
    <a href="#pyweb27">&rarr;<em>LaTeX file output end</em> (27)</a>
    <a href="#pyweb28">&rarr;<em>LaTeX references summary at the end of a chunk</em> (28)</a>
    <a href="#pyweb29">&rarr;<em>LaTeX write a line of code</em> (29)</a>
    <a href="#pyweb30">&rarr;<em>LaTeX reference to a chunk</em> (30)</a>

    </pre></code>
    <p>&loz; <em>LaTeX subclass of Weaver</em> (23).
      Used by <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The LaTeX <span class="code">open()</span> method opens the woven file by replacing the
source file's suffix with <tt>".tex"</tt> and creating the resulting file.
</p>

<p>The LaTeX <b>codeBegin()</b> template writes the header prior to a
chunk of source code.  It aligns the block to the left, prints an
italicised header, and opens a preformatted block.
</p>
  

    <a name="pyweb24"></a>
    <!--line number 716-->
    <p><em>LaTeX code chunk begin</em> (24)&nbsp;=</p>
    <code><pre>

cb_template = string.Template( &quot;&quot;&quot;\\label{pyweb${seq}}
\\begin{flushleft}
\\textit{Code example ${fullName} (${seq})}
\\begin{Verbatim}[commandchars=\\\\\\{\\},codes={\\catcode`$$=3\\catcode`^=7},frame=single]\n&quot;&quot;&quot;) # Prevent indent

    </pre></code>
    <p>&loz; <em>LaTeX code chunk begin</em> (24).
      Used by <a href="#pyweb23"><em>LaTeX subclass of Weaver</em>&nbsp;(23)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



<p>The LaTeX <b>codeEnd()</b> template writes the trailer subsequent to
a chunk of source code.  This first closes the preformatted block and
then calls the <b>references()</b> method to write a reference
to the chunk that invokes this chunk; finally, it restores paragraph
indentation.
</p>
  

    <a name="pyweb25"></a>
    <!--line number 733-->
    <p><em>LaTeX code chunk end</em> (25)&nbsp;=</p>
    <code><pre>

ce_template= string.Template(&quot;&quot;&quot;
\\end{Verbatim}
${references}
\\end{flushleft}\n&quot;&quot;&quot;) # Prevent indentation

    </pre></code>
    <p>&loz; <em>LaTeX code chunk end</em> (25).
      Used by <a href="#pyweb23"><em>LaTeX subclass of Weaver</em>&nbsp;(23)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



<p>The LaTeX <b>fileBegin()</b> template writes the header prior to a
the creation of a tangled file.  Its formatting is identical to the
start of a code chunk.
</p>


    <a name="pyweb26"></a>
    <!--line number 748-->
    <p><em>LaTeX file output begin</em> (26)&nbsp;=</p>
    <code><pre>

fb_template= cb_template

    </pre></code>
    <p>&loz; <em>LaTeX file output begin</em> (26).
      Used by <a href="#pyweb23"><em>LaTeX subclass of Weaver</em>&nbsp;(23)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The LaTeX <b>fileEnd()</b> template writes the trailer subsequent to
a tangled file.  This closes the preformatted block, calls the LaTeX
<b>references()</b> method to write a reference to the chunk that
invokes this chunk, and restores normal indentation.  </p>


    <a name="pyweb27"></a>
    <!--line number 759-->
    <p><em>LaTeX file output end</em> (27)&nbsp;=</p>
    <code><pre>

fe_template= ce_template

    </pre></code>
    <p>&loz; <em>LaTeX file output end</em> (27).
      Used by <a href="#pyweb23"><em>LaTeX subclass of Weaver</em>&nbsp;(23)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <b>references()</b> template writes a list of references after a
chunk of code.  Each reference includes the example number, the title,
and a reference to the LaTeX section and page numbers on which the
referring block appears.  </p>
  

    <a name="pyweb28"></a>
    <!--line number 770-->
    <p><em>LaTeX references summary at the end of a chunk</em> (28)&nbsp;=</p>
    <code><pre>

ref_item_template = string.Template( &quot;&quot;&quot;
\\item Code example ${fullName} (${seq}) (Sect. \\ref{pyweb${seq}}, p. \\pageref{pyweb${seq}})\n&quot;&quot;&quot;)
ref_template = string.Template( &quot;&quot;&quot;
\\footnotesize
Used by:
\\begin{list}{}{}
${refList}
\\end{list}
\\normalsize\n&quot;&quot;&quot;)

    </pre></code>
    <p>&loz; <em>LaTeX references summary at the end of a chunk</em> (28).
      Used by <a href="#pyweb23"><em>LaTeX subclass of Weaver</em>&nbsp;(23)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <b>codeLine()</b> method quotes a single line of code to the
weaver; since these lines are always in preformatted blocks, no
special formatting is needed, except to avoid ending the preformatted
block.  Our one compromise is a thin space if the phrase
<tt>\\end{Verbatim}</tt> is used in a code block.</p>
  

    <a name="pyweb29"></a>
    <!--line number 790-->
    <p><em>LaTeX write a line of code</em> (29)&nbsp;=</p>
    <code><pre>

quoted_chars = [
    (&quot;\\end{Verbatim}&quot;, &quot;\\end\,{Verbatim}&quot;), # Allow \end{Verbatim}
    (&quot;\\{&quot;,&quot;\\\,{&quot;), # Prevent unexpected commands in Verbatim
    (&quot;$&quot;,&quot;\\$&quot;), # Prevent unexpected math in Verbatim
]

    </pre></code>
    <p>&loz; <em>LaTeX write a line of code</em> (29).
      Used by <a href="#pyweb23"><em>LaTeX subclass of Weaver</em>&nbsp;(23)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">referenceTo()</span> template writes a reference to another chunk of
code.  It uses write directly as to follow the current indentation on
the current line of code.
</p>


    <a name="pyweb30"></a>
    <!--line number 805-->
    <p><em>LaTeX reference to a chunk</em> (30)&nbsp;=</p>
    <code><pre>

refto_name_template= string.Template(&quot;&quot;&quot;$$\\triangleright$$ Code Example ${fullName} (${seq})&quot;&quot;&quot;)
refto_seq_template= string.Template(&quot;&quot;&quot;(${seq})&quot;&quot;&quot;)

    </pre></code>
    <p>&loz; <em>LaTeX reference to a chunk</em> (30).
      Used by <a href="#pyweb23"><em>LaTeX subclass of Weaver</em>&nbsp;(23)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>HTML subclasses of Weaver</h4>
<h5>Usage</h5>
<p>An instance of <span class="code">HTML</span> can be used by the <span class="code">Web</span> object to 
weave an output document.  The instance is created outside the Web, and
given to the <span class="code">weave()</span> method of the Web.
</p>
<pre>
w= Web( "someName.w" )
WebReader().web(w).load()
weave_html= HTML()
w.weave( weave_html )
</pre>

<p>Variations in the output formatting are accomplished by having
variant subclasses of HTML.  In this implementation, we have two
variations: full path references, and short references.  The base class
produces complete reference paths; a subclass produces abbreviated references.
</p>

<h5>Design</h5>
<p>The <span class="code">HTML</span> subclass defines a Weaver that is customized to
produce HTML output of code sections and cross reference information.
</p>
<p>All HTML chunks are identified by anchor names of the form <tt>pyweb<i>n</i></tt>.  Each
<i>n</i> is the unique chunk number, in sequential order.
</p>
<p>An <span class="code">HTMLShort</span> subclass defines a Weaver that produces HTML output
with abbreviated (no name) cross references at the end of the chunk.</p>

<h5>Implementation</h5>


    <a name="pyweb31"></a>
    <!--line number 843-->
    <p><em>HTML subclass of Weaver</em> (31)&nbsp;=</p>
    <code><pre>

class HTML( Weaver ):
    &quot;&quot;&quot;HTML formatting for XRef's and code blocks when weaving.&quot;&quot;&quot;
    extension= &quot;.html&quot;
    code_indent= 0
    <a href="#pyweb33">&rarr;<em>HTML code chunk begin</em> (33)</a>
    <a href="#pyweb34">&rarr;<em>HTML code chunk end</em> (34)</a>
    <a href="#pyweb35">&rarr;<em>HTML output file begin</em> (35)</a>
    <a href="#pyweb36">&rarr;<em>HTML output file end</em> (36)</a>
    <a href="#pyweb37">&rarr;<em>HTML references summary at the end of a chunk</em> (37)</a>
    <a href="#pyweb38">&rarr;<em>HTML write a line of code</em> (38)</a>
    <a href="#pyweb39">&rarr;<em>HTML reference to a chunk</em> (39)</a>
    <a href="#pyweb40">&rarr;<em>HTML simple cross reference markup</em> (40)</a>

    </pre></code>
    <p>&loz; <em>HTML subclass of Weaver</em> (31).
      Used by <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb32"></a>
    <!--line number 860-->
    <p><em>HTML subclass of Weaver</em> (32)&nbsp;+=</p>
    <code><pre>

class HTMLShort( HTML ):
    &quot;&quot;&quot;HTML formatting for XRef's and code blocks when weaving with short references.&quot;&quot;&quot;
    <a href="#pyweb42">&rarr;<em>HTML short references summary at the end of a chunk</em> (42)</a>

    </pre></code>
    <p>&loz; <em>HTML subclass of Weaver</em> (32).
      Used by <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">codeBegin()</span> template starts a chunk of code, defined with <tt>@d</tt>, providing a label
and HTML tags necessary to set the code off visually.
</p>


    <a name="pyweb33"></a>
    <!--line number 872-->
    <p><em>HTML code chunk begin</em> (33)&nbsp;=</p>
    <code><pre>

cb_template= string.Template(&quot;&quot;&quot;
&lt;a name=&quot;pyweb${seq}&quot;&gt;&lt;/a&gt;
&lt;!--line number ${lineNumber}--&gt;
&lt;p&gt;&lt;em&gt;${fullName}&lt;/em&gt; (${seq})&amp;nbsp;${concat}&lt;/p&gt;
&lt;code&gt;&lt;pre&gt;\n&quot;&quot;&quot;)

    </pre></code>
    <p>&loz; <em>HTML code chunk begin</em> (33).
      Used by <a href="#pyweb31"><em>HTML subclass of Weaver</em>&nbsp;(31)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">codeEnd()</span> template ends a chunk of code, providing a HTML tags necessary 
to finish the code block visually.  This calls the references method to
write the list of chunks that reference this chunk.
</p>


    <a name="pyweb34"></a>
    <!--line number 887-->
    <p><em>HTML code chunk end</em> (34)&nbsp;=</p>
    <code><pre>

ce_template= string.Template(&quot;&quot;&quot;
&lt;/pre&gt;&lt;/code&gt;
&lt;p&gt;&amp;loz; &lt;em&gt;${fullName}&lt;/em&gt; (${seq}).
${references}
&lt;/p&gt;\n&quot;&quot;&quot;)

    </pre></code>
    <p>&loz; <em>HTML code chunk end</em> (34).
      Used by <a href="#pyweb31"><em>HTML subclass of Weaver</em>&nbsp;(31)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">fileBegin()</span> template starts a chunk of code, defined with <tt>@o</tt>, providing a label
and HTML tags necessary to set the code off visually.
</p>


    <a name="pyweb35"></a>
    <!--line number 901-->
    <p><em>HTML output file begin</em> (35)&nbsp;=</p>
    <code><pre>

fb_template= string.Template(&quot;&quot;&quot;&lt;a name=&quot;pyweb${seq}&quot;&gt;&lt;/a&gt;
&lt;!--line number ${lineNumber}--&gt;
&lt;p&gt;&lt;tt&gt;${fullName}&lt;/tt&gt; (${seq})&amp;nbsp;${concat}&lt;/p&gt;
&lt;code&gt;&lt;pre&gt;\n&quot;&quot;&quot;) # Prevent indent

    </pre></code>
    <p>&loz; <em>HTML output file begin</em> (35).
      Used by <a href="#pyweb31"><em>HTML subclass of Weaver</em>&nbsp;(31)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">fileEnd()</span> template ends a chunk of code, providing a HTML tags necessary 
to finish the code block visually.  This calls the references method to
write the list of chunks that reference this chunk.
</p>


    <a name="pyweb36"></a>
    <!--line number 915-->
    <p><em>HTML output file end</em> (36)&nbsp;=</p>
    <code><pre>

fe_template= string.Template( &quot;&quot;&quot;&lt;/pre&gt;&lt;/code&gt;
&lt;p&gt;&amp;loz; &lt;tt&gt;${fullName}&lt;/tt&gt; (${seq}).
${references}
&lt;/p&gt;\n&quot;&quot;&quot;)

    </pre></code>
    <p>&loz; <em>HTML output file end</em> (36).
      Used by <a href="#pyweb31"><em>HTML subclass of Weaver</em>&nbsp;(31)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">references()</span> template writes the list of chunks that refer to this chunk.
Note that this list could be rather long because of the possibility of 
transitive references.
</p>

    <a name="pyweb37"></a>
    <!--line number 928-->
    <p><em>HTML references summary at the end of a chunk</em> (37)&nbsp;=</p>
    <code><pre>

ref_item_template = string.Template(
'&lt;a href=&quot;#pyweb${seq}&quot;&gt;&lt;em&gt;${fullName}&lt;/em&gt;&amp;nbsp;(${seq})&lt;/a&gt;'
)
ref_template = string.Template( '  Used by ${refList}.'  )

    </pre></code>
    <p>&loz; <em>HTML references summary at the end of a chunk</em> (37).
      Used by <a href="#pyweb31"><em>HTML subclass of Weaver</em>&nbsp;(31)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">codeLine()</span> method writes an individual line of code for HTML purposes.
This encodes the four basic HTML entities (&lt;, &gt;, &amp;, &quot;) to prevent code from being interpreted
as HTML.
</p>


    <a name="pyweb38"></a>
    <!--line number 942-->
    <p><em>HTML write a line of code</em> (38)&nbsp;=</p>
    <code><pre>

quoted_chars = [
    (&quot;&amp;&quot;, &quot;&amp;amp;&quot;), # Must be first
    (&quot;&lt;&quot;, &quot;&amp;lt;&quot;),
    (&quot;&gt;&quot;, &quot;&amp;gt;&quot;),
    ('&quot;', &quot;&amp;quot;&quot;),
]

    </pre></code>
    <p>&loz; <em>HTML write a line of code</em> (38).
      Used by <a href="#pyweb31"><em>HTML subclass of Weaver</em>&nbsp;(31)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">referenceTo()</span> template writes a reference to another chunk.  It uses the 
direct <span class="code">write()</span> method so that the reference is indented properly with the
surrounding source code.
</p>


    <a name="pyweb39"></a>
    <!--line number 958-->
    <p><em>HTML reference to a chunk</em> (39)&nbsp;=</p>
    <code><pre>

refto_name_template = string.Template(
'&lt;a href=&quot;#pyweb${seq}&quot;&gt;&amp;rarr;&lt;em&gt;${fullName}&lt;/em&gt; (${seq})&lt;/a&gt;'
)
refto_seq_template = string.Template(
'&lt;a href=&quot;#pyweb${seq}&quot;&gt;(${seq})&lt;/a&gt;'
)

    </pre></code>
    <p>&loz; <em>HTML reference to a chunk</em> (39).
      Used by <a href="#pyweb31"><em>HTML subclass of Weaver</em>&nbsp;(31)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">xrefHead()</span> method writes the heading for any of the cross reference blocks created by
<tt>@f</tt>, <tt>@m</tt>, or <tt>@u</tt>.  In this implementation, the cross references are simply unordered lists. 
</p>
<p>The <span class="code">xrefFoot()</span> method writes the footing for any of the cross reference blocks created by
<tt>@f</tt>, <tt>@m</tt>, or <tt>@u</tt>.  In this implementation, the cross references are simply unordered lists. 
</p>
<p>The <span class="code">xrefLine()</span> method writes a line for the file or macro cross reference blocks created by
<tt>@f</tt> or <tt>@m</tt>.  In this implementation, the cross references are simply unordered lists. 
</p>


    <a name="pyweb40"></a>
    <!--line number 979-->
    <p><em>HTML simple cross reference markup</em> (40)&nbsp;=</p>
    <code><pre>

xref_head_template = string.Template( &quot;&lt;dl&gt;\n&quot; )
xref_foot_template = string.Template( &quot;&lt;/dl&gt;\n&quot; )
xref_item_template = string.Template( &quot;&lt;dt&gt;${fullName}&lt;/dt&gt;&lt;dd&gt;${refList}&lt;/dd&gt;\n&quot; )
<a href="#pyweb41">&rarr;<em>HTML write user id cross reference line</em> (41)</a>

    </pre></code>
    <p>&loz; <em>HTML simple cross reference markup</em> (40).
      Used by <a href="#pyweb31"><em>HTML subclass of Weaver</em>&nbsp;(31)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">xrefDefLine()</span> method writes a line for the user identifier cross reference blocks created by
@u.  In this implementation, the cross references are simply unordered lists.  The defining instance 
is included in the correct order with the other instances, but is bold and marked with a bullet (&bull;).
</p>


    <a name="pyweb41"></a>
    <!--line number 993-->
    <p><em>HTML write user id cross reference line</em> (41)&nbsp;=</p>
    <code><pre>

name_def_template = string.Template( '&lt;a href=&quot;#pyweb${seq}&quot;&gt;&lt;b&gt;&amp;bull;${seq}&lt;/b&gt;&lt;/a&gt;' )
name_ref_template = string.Template( '&lt;a href=&quot;#pyweb${seq}&quot;&gt;${seq}&lt;/a&gt;' )

    </pre></code>
    <p>&loz; <em>HTML write user id cross reference line</em> (41).
      Used by <a href="#pyweb40"><em>HTML simple cross reference markup</em>&nbsp;(40)</a>; <a href="#pyweb31"><em>HTML subclass of Weaver</em>&nbsp;(31)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The HTMLShort subclass enhances the HTML class to provide short 
cross references.
The <span class="code">references()</span> method writes the list of chunks that refer to this chunk.
Note that this list could be rather long because of the possibility of 
transitive references.
</p>

    <a name="pyweb42"></a>
    <!--line number 1006-->
    <p><em>HTML short references summary at the end of a chunk</em> (42)&nbsp;=</p>
    <code><pre>

ref_item_template = string.Template( '&lt;a href=&quot;#pyweb${seq}&quot;&gt;(${seq})&lt;/a&gt;' )

    </pre></code>
    <p>&loz; <em>HTML short references summary at the end of a chunk</em> (42).
      Used by <a href="#pyweb32"><em>HTML subclass of Weaver</em>&nbsp;(32)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>Tangler subclass of Emitter</h4>
<h5>Usage</h5>
<p>The <span class="code">Tangler</span> class is concrete, and can tangle source files.  An
instance of <span class="code">Tangler</span> is given to the <span class="code">Web</span> class <span class="code">tangle()</span> method.
<pre>
w= Web( "someFile.w" )
WebReader().web(w).load()
t= Tangler()
w.tangle( t )
</pre>

<h5>Design</h5>
<p>The <span class="code">Tangler</span> subclass defines an Emitter used to <em>tangle</em> the various
program source files.  The superclass is used to simply emit correctly indented 
source code and do very little else that could corrupt or alter the output.
</p>
<p>Language-specific subclasses could be used to provide additional decoration.
For example, inserting <tt>#line</tt> directives showing the line number
in the original source file.
</p>
<p>For Python, where indentation matters, the indent rules are relatively
simple.  The whitespace berfore a <tt>@&lt;</tt> command is preserved as
the prevailing indent for the block tangled as a replacement for the  <tt>@&lt;...@&gt;</tt>.
</p>
<h5>Implementation</h5>


    <a name="pyweb43"></a>
    <!--line number 1038-->
    <p><em>Tangler subclass of Emitter to create source files with no markup</em> (43)&nbsp;=</p>
    <code><pre>

class Tangler( Emitter ):
    &quot;&quot;&quot;Tangle output files.&quot;&quot;&quot;
    def __init__( self ):
        super( Tangler, self ).__init__()
        self.comment_start= &quot;&quot;
        self.comment_end= &quot;&quot;
        self.debug= False
    <a href="#pyweb44">&rarr;<em>Tangler doOpen, doClose and doWrite overrides</em> (44)</a>
    <a href="#pyweb45">&rarr;<em>Tangler code chunk begin</em> (45)</a>
    <a href="#pyweb46">&rarr;<em>Tangler code chunk end</em> (46)</a>

    </pre></code>
    <p>&loz; <em>Tangler subclass of Emitter to create source files with no markup</em> (43).
      Used by <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The default for all tanglers is to create the named file.
</p>
<p>This <span class="code">doClose()</span> method overrides the <span class="code">Emitter</span> class <span class="code">doClose()</span> method by closing the
actual file created by open.
</p>
<p>This <span class="code">doWrite()</span> method overrides the <span class="code">Emitter</span> class <span class="code">doWrite()</span> method by writing to the
actual file created by open.
</p>


    <a name="pyweb44"></a>
    <!--line number 1062-->
    <p><em>Tangler doOpen, doClose and doWrite overrides</em> (44)&nbsp;=</p>
    <code><pre>

def doOpen( self, aFile ):
    self.fileName= aFile
    self.theFile= open( aFile, &quot;w&quot; )
    logger.info( &quot;Tangling %r&quot;, aFile )
def doClose( self ):
    self.theFile.close()
    logger.info( &quot;Wrote %d lines to %r&quot;,
        self.linesWritten, self.fileName )
def doWrite( self, text ):
    self.theFile.write( text )

    </pre></code>
    <p>&loz; <em>Tangler doOpen, doClose and doWrite overrides</em> (44).
      Used by <a href="#pyweb43"><em>Tangler subclass of Emitter to create source files with no markup</em>&nbsp;(43)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">codeBegin()</span> method starts emitting a new chunk of code.
It does this by setting the Tangler's indent to the
prevailing indent at the start of the <tt>@&lt;</tt> reference command.</p>


    <a name="pyweb45"></a>
    <!--line number 1081-->
    <p><em>Tangler code chunk begin</em> (45)&nbsp;=</p>
    <code><pre>

def codeBegin( self, aChunk ):
    self.log_indent.debug( &quot;&lt;tangle %s:&quot;, aChunk.fullName )
    if self.debug:
        self.write( &quot;\n%s %s (%d) -- %s %s\n&quot; % ( 
            self.comment_start, aChunk.fullName, aChunk.seq, aChunk.lineNumber, self.comment_end ) )

    </pre></code>
    <p>&loz; <em>Tangler code chunk begin</em> (45).
      Used by <a href="#pyweb43"><em>Tangler subclass of Emitter to create source files with no markup</em>&nbsp;(43)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">codeEnd()</span> method ends emitting a new chunk of code.
It does this by resetting the Tangler's indent to the previous
setting.</p>


    <a name="pyweb46"></a>
    <!--line number 1095-->
    <p><em>Tangler code chunk end</em> (46)&nbsp;=</p>
    <code><pre>

def codeEnd( self, aChunk ):
    self.log_indent.debug( &quot;&gt;%s&quot;, aChunk.fullName )

    </pre></code>
    <p>&loz; <em>Tangler code chunk end</em> (46).
      Used by <a href="#pyweb43"><em>Tangler subclass of Emitter to create source files with no markup</em>&nbsp;(43)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>TanglerMake subclass of Tangler</h4>

<h5>Usage</h5>
<p>The <span class="code">TanglerMake</span> class is can tangle source files.  An
instance of <span class="code">TanglerMake</span> is given to the <span class="code">Web</span> class <span class="code">tangle()</span> method.
<pre>
w= Web( "someFile.w" )
WebReader().web(w).load()
t= TanglerMake()
w.tangle( t )
</pre>

<h5>Design</h5>
<p>The <span class="code">TanglerMake</span> subclass makes the <span class="code">Tangler</span> used to <em>tangle</em> the various
program source files more make-friendly.  This subclass of <span class="code">Tangler</span> 
does not <i>touch</i> an output file
where there is no change.  This is helpful when <em>pyWeb</em>'s output is
sent to <i>make</i>.  Using <span class="code">TanglerMake</span> assures that only files with real changes
are rewritten, minimizing recompilation of an application for changes to
the associated documentation.
</p>

<h5>Implementation</h5>
<p>This subclass of <span class="code">Tangler</span> changes how files
are opened and closed.</p>


    <a name="pyweb47"></a>
    <!--line number 1128-->
    <p><em>Imports</em> (47)&nbsp;+=</p>
    <code><pre>
import tempfile
import filecmp

    </pre></code>
    <p>&loz; <em>Imports</em> (47).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb48"></a>
    <!--line number 1134-->
    <p><em>Tangler subclass which is make-sensitive</em> (48)&nbsp;=</p>
    <code><pre>

class TanglerMake( Tangler ):
    &quot;&quot;&quot;Tangle output files, leaving files untouched if there are no changes.&quot;&quot;&quot;
    def __init__( self ):
        Tangler.__init__( self )
        self.tempname= None
    <a href="#pyweb49">&rarr;<em>TanglerMake doOpen override, using a temporary file</em> (49)</a>
    <a href="#pyweb50">&rarr;<em>TanglerMake doClose override, comparing temporary to original</em> (50)</a>

    </pre></code>
    <p>&loz; <em>Tangler subclass which is make-sensitive</em> (48).
      Used by <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>A <span class="code">TanglerMake</span> creates a temporary file to collect the
tangled output.  When this file is completed, we can compare
it with the original file in this directory, avoiding
a "touch" if the new file is the same as the original.
</p>


    <a name="pyweb49"></a>
    <!--line number 1152-->
    <p><em>TanglerMake doOpen override, using a temporary file</em> (49)&nbsp;=</p>
    <code><pre>

def doOpen( self, aFile ):
    self.tempname= tempfile.mktemp()
    self.theFile= open( self.tempname, &quot;w&quot; )
    logger.info( &quot;Tangling %r&quot;, aFile )

    </pre></code>
    <p>&loz; <em>TanglerMake doOpen override, using a temporary file</em> (49).
      Used by <a href="#pyweb48"><em>Tangler subclass which is make-sensitive</em>&nbsp;(48)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>If there is a previous file: compare the temporary file and the previous file.  
If there was  previous file or the files are different: rename temporary to replace previous;
else: unlink temporary and discard it.  This preserves the original (with the original date
and time) if nothing has changed.
</p>


    <a name="pyweb50"></a>
    <!--line number 1167-->
    <p><em>TanglerMake doClose override, comparing temporary to original</em> (50)&nbsp;=</p>
    <code><pre>

def doClose( self ):
    self.theFile.close()
    try:
        same= filecmp.cmp( self.tempname, self.fileName )
    except OSError,e:
        same= 0
    if same:
        logger.info( &quot;No change to %r&quot;, self.fileName )
        os.remove( self.tempname )
    else:
        # note the Windows requires the original file name be removed first
        try: 
            os.remove( self.fileName )
        except OSError,e:
            pass
        os.rename( self.tempname, self.fileName )
        logger.info( &quot;Wrote %d lines to %r&quot;,
            self.linesWritten, self.fileName )

    </pre></code>
    <p>&loz; <em>TanglerMake doClose override, comparing temporary to original</em> (50).
      Used by <a href="#pyweb48"><em>Tangler subclass which is make-sensitive</em>&nbsp;(48)</a>; <a href="#pyweb2"><em>Emitter class hierarchy - used to control output files</em>&nbsp;(2)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h3>Chunks</h3>

<p>A <span class="code">Chunk</span> is a piece of the input file.  It is a collection of <span class="code">Command</span> instances.
A chunk can be woven or tangled to create output.</p>
<p>The two most important methods are the <span class="code">weave()</span> and <span class="code">tangle()</span> methods.  These
visit the commands of this chunk, producing the required output file.
</p>
<p>Additional methods (<span class="code">startswith()</span>, <span class="code">searchForRE()</span> and <span class="code">usedBy()</span>)
 are used to examine the text of the <span class="code">Command</span> instances within
the chunk.</p>
<p>A <span class="code">Chunk</span> instance is created by the <span class="code">WebReader</span> as the input file is parsed.
Each <span class="code">Chunk</span> instance has one or more pieces of the original input text.  This text can be program source,
a reference command, or the documentation source.
</p>


    <a name="pyweb51"></a>
    <!--line number 1205-->
    <p><em>Chunk class hierarchy - used to describe input chunks</em> (51)&nbsp;=</p>
    <code><pre>

<a href="#pyweb52">&rarr;<em>Chunk class</em> (52)</a>
<a href="#pyweb63">&rarr;<em>NamedChunk class</em> (63)</a>
<a href="#pyweb68">&rarr;<em>OutputChunk class</em> (68)</a>
<a href="#pyweb72">&rarr;<em>NamedDocumentChunk class</em> (72)</a>

    </pre></code>
    <p>&loz; <em>Chunk class hierarchy - used to describe input chunks</em> (51).
      Used by <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">Chunk</span> class is both the superclass for this hierarchy and the implementation 
for anonymous chunks.  An anonymous chunk is always documentation in the 
target markup language.  No transformation is ever done on anonymous chunks.
</p>
<p>A <span class="code">NamedChunk</span> is a chunk created with a <tt>@d</tt> command.  
This is a chunk of source programming language, bracketed with <tt>@{</tt> and <tt>@}</tt>.
</p>
<p>An <span class="code">OutputChunk</span> is a named chunk created with a <tt>@o</tt> command.  
This must be a chunk of source programming language, bracketed with <tt>@{</tt> and <tt>@}</tt>.
</p>
<p>A <span class="code">NamedDocumentChunk</span> is a named chunk created with a <tt>@d</tt> command.  
This is a chunk of documentation in the target markup language,
 bracketed with <tt>@[</tt> and <tt>@]</tt>.
</p>

<h4>Chunk Superclass</h4>

<h5>Usage</h5>
<p>An instance of the <span class="code">Chunk</span> class has a life that includes four important events:
creation, cross-reference, weave and tangle.</p>
<p>A <span class="code">Chunk</span> is created by a <span class="code">WebReader</span>, and associated with a <span class="code">Web</span>.
There are several web append methods, depending on the exact subclass of <span class="code">Chunk</span>.
The <span class="code">WebReader</span> calls the chunk's <span class="code">webAdd()</span> method select the correct method
for appending and indexing the chunk.
Individual instances of <span class="code">Command</span> are appended to the chunk.
The basic outline for creating a <span class="code">Chunk</span> instance is as follows:</p>
<pre>
w= Web( "someFile.w" )
c= Chunk()
c.webAdd( w )
c.append( ...some Command... )
c.append( ...some Command... )
</pre>
<p>Before weaving or tangling, a cross reference is created for all
user identifiers in all of the <span class="code">Chunk</span> instances.
This is done by: (1) visit each <span class="code">Chunk</span> and call the 
<span class="code">getUserIDRefs()</span> method to gather all identifiers; (2) for each identifier, 
visit each <span class="code">Chunk</span> and call the <span class="code">searchForRE()</span> method to find uses of
the identifier.</p>
<pre>
ident= []
for c in <i>the Web's named chunk list</i>:
    ident.extend( c.getUserIDRefs() )
for i in ident:
    pattern= re.compile('\W%s\W' % i)
    for c in <i>the Web's named chunk list</i>:
        c.searchForRE( pattern )
</pre>
<p>A <span class="code">Chunk</span> is woven or tangled by the <span class="code">Web</span>.  The basic outline for weaving is
as follows.  The tangling action is essentially the same.</p>
<pre>
for c in <i>the Web's chunk list</i>:
    c.weave( aWeaver )
</pre>

<h5>Design</h5>
<p>The <span class="code">Chunk</span> class contains the overall definitions for all of the
various specialized subclasses.  In particular, it contains the <span class="code">append()</span>,
and <span class="code">appendText()</span> methods used by all of the various <span class="code">Chunk</span> subclasses.
</p>

<p>When a <tt>@@</tt> construct is located in the input stream, the stream contains
three text tokens: material before the <tt>@@</tt>, the <tt>@@</tt>, 
and the material after the <tt>@@</tt>.
These three tokens are reassembled into a single block of text.  This reassembly
is accomplished by changing the chunk's state so that the next <span class="code">TextCommand</span> is
appended onto the previous <span class="code">TextCommand</span>.
</p>

<p>The <span class="code">appendText()</span> method either:</p>
<ul>
<li>appends to a previous <span class="code">TextCommand</span>  instance,</li>
<li>or finds that there are not commands at all, and creates a <span class="code">TextCommand</span> instance,</li>
<li>or finds that the last Command isn't a subclass of <span class="code">TextCommand</span>and creates a <span class="code">TextCommand</span> instance.</li>
</ul>

<p>Each subclass of <span class="code">Chunk</span> has a particular type of text that it will process.  Anonymous chunks
only handle document text.  The <span class="code">NamedChunk</span> subclass that handles program source
will override this method to create a different command type.  The <span class="code">makeContent()</span> method
creates the appropriate <span class="code">Command</span> instance for this <span class="code">Chunk</span> subclass.
</p>

<p>The <span class="code">weave()</span> method of an anonymous <span class="code">Chunk</span> uses the weaver's 
<span class="code">docBegin()</span> and <span class="code">docEnd()</span>
methods to insert text that is source markup.  Other subclasses will override this to 
use different <span class="code">Weaver</span> methods for different kinds of text.
</p>

<p>A Chunk has a <span class="code">Strategy</span> object which is a subclass of Reference.  This is
either an instance of SimpleReference or TransitiveReference.  
A SimpleRerence does no additional processing, and locates the proximate reference to 
this chunk.  The TransitiveReference walks "up" the web toward top-level file
definitions that reference this Chunk.
</p>

<h5>Implementation</h5>

<p>The <span class="code">Chunk</span> constructor initializes the following instance variables:</p>
<ul>
<li><i>commands</i> is a sequence of the various <span class="code">Command</span> instances the comprise this
chunk.</li>
<li><i>user_id_list</i> is used the list of user identifiers associated with
this chunk.  This attribute is always <span class="code">None</span> for this class.
The <span class="code">NamedChunk</span> subclass, however, can have user identifiers.</li>
<li><i>initial</i> is True if this is the first
definition (display with <tt>'='</tt>) or a subsequent definition (display with <tt>'+='</tt>).
</li>
<li><i>name</i> has the name of the chunk.  This is '' for anonymous chunks.</li>
<li><i>seq</i> has the sequence number associated with this chunk.  This is None
for anonymous chunks.</li>
<li><i>referencedBy</i> is the list of Chunks which reference this chunk.</li>
<li><i>references</i> is the list of Chunks this chunk references.</li>
</ul>

<blockquote class="note">
<p>These variables are deprecated.</p>
<ul>
<li><i>_lastCommand</i> is used to force a character to be appended to the last
command (which must be a <span class="code">Textcommand</span> instance) instead of appending a new command.
This needs to be removed.  If each Command has trailing text, then this
isn't necessary.</li>
</ul>
</blockquote>


    <a name="pyweb52"></a>
    <!--line number 1337-->
    <p><em>Chunk class</em> (52)&nbsp;=</p>
    <code><pre>

class Chunk( object ):
    &quot;&quot;&quot;Anonymous piece of input file: will be output through the weaver only.&quot;&quot;&quot;
    # construction and insertion into the web
    def __init__( self ):
        self.commands= [ ] # The list of children of this chunk
        self.user_id_list= None
        self.initial= None
        self.name= ''
        self.fullName= None
        self.seq= None
        self.referencedBy= [] # Chunks which reference this chunk.  Ideally just one.
        self.references= [] # Names that this chunk references
        
        self.reference_style= None # Instance of Reference 
        
        self._lastCommand= None
    def __str__( self ):
        return &quot;\n&quot;.join( map( str, self.commands ) )
    def __repr__( self ):
        return &quot;%s('%s')&quot; % ( self.__class__.__name__, self.name )
    <a href="#pyweb53">&rarr;<em>Chunk append a command</em> (53)</a>
    <a href="#pyweb54">&rarr;<em>Chunk append text</em> (54)</a>
    <a href="#pyweb55">&rarr;<em>Chunk add to the web</em> (55)</a>
    <a href="#pyweb59">&rarr;<em>Chunk generate references from this Chunk</em> (59)</a>
    <a href="#pyweb56">&rarr;<em>Chunk superclass make Content definition</em> (56)</a>
    <a href="#pyweb57">&rarr;<em>Chunk examination: starts with, matches pattern</em> (57)</a>
    <a href="#pyweb60">&rarr;<em>Chunk references to this Chunk</em> (60)</a>
    <a href="#pyweb61">&rarr;<em>Chunk weave this Chunk into the documentation</em> (61)</a>
    <a href="#pyweb62">&rarr;<em>Chunk tangle this Chunk into a code file</em> (62)</a>

    </pre></code>
    <p>&loz; <em>Chunk class</em> (52).
      Used by <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">append()</span> method simply appends a <span class="code">Command</span> instance to this chunk.</p>


    <a name="pyweb53"></a>
    <!--line number 1373-->
    <p><em>Chunk append a command</em> (53)&nbsp;=</p>
    <code><pre>

def append( self, command ):
    &quot;&quot;&quot;Add another Command to this chunk.&quot;&quot;&quot;
    self.commands.append( command )
    command.chunk= self

    </pre></code>
    <p>&loz; <em>Chunk append a command</em> (53).
      Used by <a href="#pyweb52"><em>Chunk class</em>&nbsp;(52)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



<p>The <span class="code">appendText()</span> method appends a <span class="code">TextCommand</span> to this chunk,
or it concatenates it to the most recent <span class="code">TextCommand</span>.  
</p>

<p>When an <tt>@@</tt> construct is located, the <span class="code">appendText()</span> method is
used to accumulate this character.  This means that it will be appended to 
any previous TextCommand, or  new TextCommand will be built.
</p>

<p>The reason for appending is that a TextCommand has an implicit indentation.  The "@" cannot
be a separate TextCommand because it will wind up indented.
</p>


    <a name="pyweb54"></a>
    <!--line number 1396-->
    <p><em>Chunk append text</em> (54)&nbsp;=</p>
    <code><pre>

def appendText( self, text, lineNumber=0 ):
    &quot;&quot;&quot;Append a single character to the most recent TextCommand.&quot;&quot;&quot;
    try:
        # Works for TextCommand, otherwise breaks
        self.commands[-1].text += text
    except IndexError, e:
        # First command?  Then the list will have been empty.
        self.commands.append( self.makeContent(text,lineNumber) )
    except AttributeError, e:
        # Not a TextCommand?  Then there won't be a text attribute.
        self.commands.append( self.makeContent(text,lineNumber) )
    self._lastCommand= self.commands[-1]

    </pre></code>
    <p>&loz; <em>Chunk append text</em> (54).
      Used by <a href="#pyweb52"><em>Chunk class</em>&nbsp;(52)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">webAdd()</span> method adds this chunk to the given document web.
Each subclass of the <span class="code">Chunk</span> class must override this to be sure that the various
<span class="code">Chunk</span> subclasses are indexed properly.  The
<span class="code">Chunk</span> class uses the <span class="code">add()</span> method
of the <span class="code">Web</span> class to append an anonymous, unindexed chunk.
</p>


    <a name="pyweb55"></a>
    <!--line number 1420-->
    <p><em>Chunk add to the web</em> (55)&nbsp;=</p>
    <code><pre>

def webAdd( self, web ):
    &quot;&quot;&quot;Add self to a Web as anonymous chunk.&quot;&quot;&quot;
    web.add( self )

    </pre></code>
    <p>&loz; <em>Chunk add to the web</em> (55).
      Used by <a href="#pyweb52"><em>Chunk class</em>&nbsp;(52)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>This superclass creates a specific Command for a given piece of content.
A subclass can override this to change the underlying assumptions of that Chunk.
The generic chunk doesn't contain code, it contains text and can only be woven,
never tangled.  A Named Chunk using <tt>@{</tt> and <tt>@}</tt> creates code.
A Named Chunk using <tt>@[</tt> and <tt>@[</tt> creates text.
</p>


    <a name="pyweb56"></a>
    <!--line number 1435-->
    <p><em>Chunk superclass make Content definition</em> (56)&nbsp;=</p>
    <code><pre>

def makeContent( self, text, lineNumber=0 ):
    return TextCommand( text, lineNumber )

    </pre></code>
    <p>&loz; <em>Chunk superclass make Content definition</em> (56).
      Used by <a href="#pyweb52"><em>Chunk class</em>&nbsp;(52)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">startsWith()</span> method examines a the first <span class="code">Command</span> instance this
<span class="code">Chunk</span> instance to see if it starts
with the given prefix string.
</p>
<p>The <span class="code">lineNumber()</span> method returns the line number of the first
<span class="code">Command</span> in this chunk.  This provides some context for where the chunk
occurs in the original input file.
</p>
<p>A <span class="code">NamedChunk</span> instance may define one or more identifiers.  This parent class
provides a dummy version of the <span class="code">getUserIDRefs</span> method.  The <span class="code">NamedChunk</span>
subclass overrides this to provide actual results.  By providing this
at the superclass level, the <span class="code">Web</span> can easily gather identifiers without
knowing the actual subclass of <span class="code">Chunk</span>.
</p>
<p>The <span class="code">searchForRE()</span> method examines each <span class="code">Command</span> instance to see if it matches
with the given regular expression.  If so, this can be reported to the Web instance
and accumulated as part of a cross reference for this <span class="code">Chunk</span>.
</p>


    <a name="pyweb57"></a>
    <!--line number 1461-->
    <p><em>Chunk examination: starts with, matches pattern</em> (57)&nbsp;=</p>
    <code><pre>

def startswith( self, prefix ):
    &quot;&quot;&quot;Examine the first command's starting text.&quot;&quot;&quot;
    return len(self.commands) &gt;= 1 and self.commands[0].startswith( prefix )
def searchForRE( self, rePat ):
    &quot;&quot;&quot;Visit each command, applying the pattern.&quot;&quot;&quot;
    <a href="#pyweb58">&rarr;<em>Chunk search for user identifiers in each child command</em> (58)</a>
@property
def lineNumber( self ):
    &quot;&quot;&quot;Return the first command's line number or None.&quot;&quot;&quot;
    return self.commands[0].lineNumber if len(self.commands) &gt;= 1 else None
def getUserIDRefs( self ):
    return []

    </pre></code>
    <p>&loz; <em>Chunk examination: starts with, matches pattern</em> (57).
      Used by <a href="#pyweb52"><em>Chunk class</em>&nbsp;(52)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The chunk search in the <span class="code">searchForRE()</span> method parallels weaving and tangling a <span class="code">Chunk</span>.
The operation is delegated to each <span class="code">Command</span> instance within the <span class="code">Chunk</span> instance.
</p>


    <a name="pyweb58"></a>
    <!--line number 1482-->
    <p><em>Chunk search for user identifiers in each child command</em> (58)&nbsp;=</p>
    <code><pre>

for c in self.commands:
    if c.searchForRE( rePat ):
        return self
return None

    </pre></code>
    <p>&loz; <em>Chunk search for user identifiers in each child command</em> (58).
      Used by <a href="#pyweb57"><em>Chunk examination: starts with, matches pattern</em>&nbsp;(57)</a>; <a href="#pyweb52"><em>Chunk class</em>&nbsp;(52)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">genReferences()</span> method visits each <span class="code">Command</span> instance inside this chunk;
a <span class="code">Command</span> will yield the references.  
</p>
<p>Note that an exception may be raised by this operation if a referenced
<span class="code">Chunk</span> does not actually exist.  If a reference <span class="code">Command</span> does raise an error, 
we append this <span class="code">Chunk</span> information and reraise the error with the additional 
context information.
</p>


    <a name="pyweb59"></a>
    <!--line number 1499-->
    <p><em>Chunk generate references from this Chunk</em> (59)&nbsp;=</p>
    <code><pre>

def genReferences( self, aWeb ):
    &quot;&quot;&quot;Generate references from this Chunk.&quot;&quot;&quot;
    try:
        for t in self.commands:
            ref= t.ref( aWeb )
            if ref is not None:
                yield ref
    except Error,e:
        raise Error,e.args+(self,)

    </pre></code>
    <p>&loz; <em>Chunk generate references from this Chunk</em> (59).
      Used by <a href="#pyweb52"><em>Chunk class</em>&nbsp;(52)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The list of references to a Chunk uses a <span class="code">Strategy</span> plug-in
to either generate a simple parent or a transitive closure of all parents.
</p>


    <a name="pyweb60"></a>
    <!--line number 1517-->
    <p><em>Chunk references to this Chunk</em> (60)&nbsp;=</p>
    <code><pre>

@property
def references_list( self ):
    &quot;&quot;&quot;This should return chunks themselves, not (name,seq) pairs.&quot;&quot;&quot;
    return self.reference_style.chunkReferencedBy( self )

    </pre></code>
    <p>&loz; <em>Chunk references to this Chunk</em> (60).
      Used by <a href="#pyweb52"><em>Chunk class</em>&nbsp;(52)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">weave()</span> method weaves this chunk into the final document as follows:</p>
<ol>
<li>call
the <span class="code">Weaver</span> class <span class="code">docBegin()</span> method.  This method does nothing for document content.</li>
<li>visit each <span class="code">Command</span> instance: call the <span class="code">Command</span> instance <span class="code">weave()</span> method to 
emit the content of the <span class="code">Command</span> instance</li>
<li>call the <span class="code">Weaver</span> class <span class="code">docEnd()</span> method.  This method does nothing for document content.</li>
</ol>
<p>Note that an exception may be raised by this action if a referenced
<span class="code">Chunk</span> does not actually exist.  If a reference <span class="code">Command</span> does raise an error, 
we append this <span class="code">Chunk</span> information and reraise the error with the additional 
context information.
</p>


    <a name="pyweb61"></a>
    <!--line number 1539-->
    <p><em>Chunk weave this Chunk into the documentation</em> (61)&nbsp;=</p>
    <code><pre>

def weave( self, aWeb, aWeaver ):
    &quot;&quot;&quot;Create the nicely formatted document from an anonymous chunk.&quot;&quot;&quot;
    aWeaver.docBegin( self )
    try:
        for t in self.commands:
            t.weave( aWeb, aWeaver )
    except Error, e:
        raise Error,e.args+(self,)
    aWeaver.docEnd( self )
def weaveReferenceTo( self, aWeb, aWeaver ):
    &quot;&quot;&quot;Create a reference to this chunk -- except for anonymous chunks.&quot;&quot;&quot;
    raise Exception( &quot;Cannot reference an anonymous chunk.&quot;&quot;&quot;)
def weaveShortReferenceTo( self, aWeb, aWeaver ):
    &quot;&quot;&quot;Create a short reference to this chunk -- except for anonymous chunks.&quot;&quot;&quot;
    raise Exception( &quot;Cannot reference an anonymous chunk.&quot;&quot;&quot;)

    </pre></code>
    <p>&loz; <em>Chunk weave this Chunk into the documentation</em> (61).
      Used by <a href="#pyweb52"><em>Chunk class</em>&nbsp;(52)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>Anonymous chunks cannot be tangled.  Any attempt indicates a serious
problem with this program or the input file.</p>


    <a name="pyweb62"></a>
    <!--line number 1562-->
    <p><em>Chunk tangle this Chunk into a code file</em> (62)&nbsp;=</p>
    <code><pre>

def tangle( self, aWeb, aTangler ):
    &quot;&quot;&quot;Create source code -- except anonymous chunks should not be tangled&quot;&quot;&quot;
    raise Error( 'Cannot tangle an anonymous chunk', self )

    </pre></code>
    <p>&loz; <em>Chunk tangle this Chunk into a code file</em> (62).
      Used by <a href="#pyweb52"><em>Chunk class</em>&nbsp;(52)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>NamedChunk class</h4>

<h5>Usage</h5>
<p>A <span class="code">NamedChunk</span> is created and used almost identically to an anonymous <span class="code">Chunk</span>.
The most significant difference is that a name is provided when the <span class="code">NamedChunk</span> is created.
This name is used by the <span class="code">Web</span> to organize the chunks.
</p>

<h5>Design</h5>

<p>A <span class="code">NamedChunk</span> is created with a <tt>@d</tt> or <tt>@o</tt> command.  
A <span class="code">NamedChunk</span> contains programming language source
 when the brackets are <tt>@{</tt> and <tt>@}</tt>.  A
separate subclass of <span class="code">NamedDocumentChunk</span> is used when
the brackets are <tt>@[</tt> and <tt>@]</tt>.
</p>
<p>A <span class="code">NamedChunk</span> can be both tangled into the output program files, and
woven into the output document file. 
</p>
<p>The <span class="code">weave()</span> method of a <span class="code">NamedChunk</span> uses the Weaver's 
<span class="code">codeBegin()</span> and <span class="code">codeEnd()</span>
methods to insert text that is program source and requires additional
markup to make it stand out from documentation.  Other subclasses can override this to 
use different <span class="code">Weaver</span> methods for different kinds of text.
</p>

<h5>Implementation</h5>

<p>This class introduces some additional attributes.</p>
<ul>
<li><i>fullName</i> is the full name of the chunk.  It's possible for a 
chunk to be an abbreviated forward reference; full names cannot be resolved
until all chunks have been seen.</li>
<li><i>user_id_list</i> is the list of user identifiers associated with this chunk.</li>
<li><i>refCount</i> is the count of references to this chunk.  If this is
zero, the chunk is unused; if this is more than one, this chunk is 
multiply used.  Either of these conditions is a possible error in the input. 
This is set by the <span class="code">usedBy()</span> method.</li>
<li><i>name</i> has the name of the chunk.  Names can be abbreviated.</li>
<li><i>seq</i> has the sequence number associated with this chunk.  This
is set by the Web by the <span class="code">webAdd()</span> method.</li>
</ul>


    <a name="pyweb63"></a>
    <!--line number 1613-->
    <p><em>NamedChunk class</em> (63)&nbsp;=</p>
    <code><pre>

class NamedChunk( Chunk ):
    &quot;&quot;&quot;Named piece of input file: will be output as both tangler and weaver.&quot;&quot;&quot;
    def __init__( self, name ):
        Chunk.__init__( self )
        self.name= name
        self.user_id_list= []
        self.refCount= 0
    def __str__( self ):
        return &quot;%r: %s&quot; % ( self.name, Chunk.__str__(self) )
    def makeContent( self, text, lineNumber=0 ):
        return CodeCommand( text, lineNumber )
    <a href="#pyweb64">&rarr;<em>NamedChunk user identifiers set and get</em> (64)</a>
    <a href="#pyweb65">&rarr;<em>NamedChunk add to the web</em> (65)</a>
    <a href="#pyweb66">&rarr;<em>NamedChunk weave</em> (66)</a>
    <a href="#pyweb67">&rarr;<em>NamedChunk tangle into the source file</em> (67)</a>

    </pre></code>
    <p>&loz; <em>NamedChunk class</em> (63).
      Used by <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">setUserIDRefs()</span> method accepts a list of user identifiers that are
associated with this chunk.  These are provided after the <tt>@|</tt> separator
in a <tt>@d</tt> named chunk.  These are used by the <tt>@u</tt> cross reference generator.
</p>


    <a name="pyweb64"></a>
    <!--line number 1638-->
    <p><em>NamedChunk user identifiers set and get</em> (64)&nbsp;=</p>
    <code><pre>

def setUserIDRefs( self, text ):
    &quot;&quot;&quot;Save user ID's associated with this chunk.&quot;&quot;&quot;
    self.user_id_list= text.split()
def getUserIDRefs( self ):
    return self.user_id_list

    </pre></code>
    <p>&loz; <em>NamedChunk user identifiers set and get</em> (64).
      Used by <a href="#pyweb63"><em>NamedChunk class</em>&nbsp;(63)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">webAdd()</span> method adds this chunk to the given document <span class="code">Web</span> instance.
Each class of <span class="code">Chunk</span> must override this to be sure that the various
<span class="code">Chunk</span> classes are indexed properly.  This class uses the <span class="code">addNamed()</span> method
of the <span class="code">Web</span> class to append a named chunk.
</p>


    <a name="pyweb65"></a>
    <!--line number 1654-->
    <p><em>NamedChunk add to the web</em> (65)&nbsp;=</p>
    <code><pre>

def webAdd( self, web ):
    &quot;&quot;&quot;Add self to a Web as named chunk, update xrefs.&quot;&quot;&quot;
    web.addNamed( self )

    </pre></code>
    <p>&loz; <em>NamedChunk add to the web</em> (65).
      Used by <a href="#pyweb63"><em>NamedChunk class</em>&nbsp;(63)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">weave()</span> method weaves this chunk into the final document as follows:</p>
<ol>
<li>call
the <span class="code">Weaver</span> class <span class="code">codeBegin()</span> method.  This method emits the necessary markup
for code appearing in the woven output.</li>
<li>visit each <span class="code">Command</span>, calling the command's <span class="code">weave()</span> method to emit the command's content</li>
<li>call the <span class="code">Weaver</span> class <span class="code">CodeEnd()</span> method.  This method emits the necessary markup
for code appearing in the woven output.</li>
</ol>

<p>The <span class="code">weaveRefenceTo()</span> method weaves a reference to a chunk using both name and sequence number.
The <span class="code">weaveShortReferenceTo()</span> method weaves a reference to a chunk using only the sequence number.
These references are created by <span class="code">ReferenceCommand</span> instances within a chunk being woven.
</p>
<p>If a <span class="code">ReferenceCommand</span> does raise an error during weaving,
we append this <span class="code">Chunk</span> information and reraise the error with the additional 
context information.
</p>


    <a name="pyweb66"></a>
    <!--line number 1681-->
    <p><em>NamedChunk weave</em> (66)&nbsp;=</p>
    <code><pre>

def weave( self, aWeb, aWeaver ):
    &quot;&quot;&quot;Create the nicely formatted document from a chunk of code.&quot;&quot;&quot;
    # format as &lt;pre&gt; in a different-colored box
    self.fullName= aWeb.fullNameFor( self.name )
    aWeaver.codeBegin( self )
    aWeaver.setIndent( aWeaver.code_indent )
    for t in self.commands:
        try:
            t.weave( aWeb, aWeaver )
        except Error,e:
            raise Error,e.args+(self,)
    aWeaver.clrIndent( )
    aWeaver.codeEnd( self )
def weaveReferenceTo( self, aWeb, aWeaver ):
    &quot;&quot;&quot;Create a reference to this chunk.&quot;&quot;&quot;
    self.fullName= aWeb.fullNameFor( self.name )
    txt= aWeaver.referenceTo( self.fullName, self.seq )
    aWeaver.codeBlock( txt )
def weaveShortReferenceTo( self, aWeb, aWeaver ):
    &quot;&quot;&quot;Create a shortened reference to this chunk.&quot;&quot;&quot;
    txt= aWeaver.referenceTo( None, self.seq )
    aWeaver.codeBlock( txt )

    </pre></code>
    <p>&loz; <em>NamedChunk weave</em> (66).
      Used by <a href="#pyweb63"><em>NamedChunk class</em>&nbsp;(63)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <small>tangle()</small> method tangles this chunk into the final document as follows:</p>
<ol>
<li>call the <span class="code">Tangler</span> class <span class="code">codeBegin()</span> method to set indents properly.</li>
<li>visit each Command, calling the Command's <span class="code">tangle()</span> method to emit the Command's content</li>
<li>call the <span class="code">Tangler</span> class <span class="code">codeEnd()</span> method to restore indents.</li>
</ol>
<p>If a <span class="code">ReferenceCommand</span> does raise an error during tangling,
we append this Chunk information and reraise the error with the additional 
context information.
</p>


    <a name="pyweb67"></a>
    <!--line number 1719-->
    <p><em>NamedChunk tangle into the source file</em> (67)&nbsp;=</p>
    <code><pre>

def tangle( self, aWeb, aTangler ):
    &quot;&quot;&quot;Create source code.&quot;&quot;&quot;
    # use aWeb to resolve @&lt;namedChunk@&gt;
    # format as correctly indented source text
    self.previous_command= TextCommand( &quot;&quot;, self.commands[0].lineNumber )
    aTangler.codeBegin( self )
    for t in self.commands:
        try:
            t.tangle( aWeb, aTangler )
        except Error,e:
            raise Error,e.args+(self,)
        self.previous_command= t
    aTangler.codeEnd( self )

    </pre></code>
    <p>&loz; <em>NamedChunk tangle into the source file</em> (67).
      Used by <a href="#pyweb63"><em>NamedChunk class</em>&nbsp;(63)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>OutputChunk class</h4>
<h5>Usage</h5>
<p>A <span class="code">OutputChunk</span> is created and used identically to a <span class="code">NamedChunk</span>.
The difference between this class and the parent class is the decoration of 
the markup when weaving.
</p>

<h5>Design</h5>

<p>The <span class="code">OutputChunk</span> class is a subclass of <span class="code">NamedChunk</span> that handles 
file output chunks defined with <tt>@o</tt>. 
</p>
<p>The <span class="code">weave()</span> method of a <span class="code">OutputChunk</span> uses the Weaver's 
<span class="code">fileBegin()</span> and <span class="code">fileEnd()</span>
methods to insert text that is program source and requires additional
markup to make it stand out from documentation.  Other subclasses could override this to 
use different <span class="code">Weaver</span> methods for different kinds of text.
</p>
<p>All other methods, including the tangle method are identical to <span class="code">NamedChunk</span>.</p>

<h5>Implementation</h5>


    <a name="pyweb68"></a>
    <!--line number 1759-->
    <p><em>OutputChunk class</em> (68)&nbsp;=</p>
    <code><pre>

class OutputChunk( NamedChunk ):
    &quot;&quot;&quot;Named piece of input file, defines an output tangle.&quot;&quot;&quot;
    def __init__( self, name, comment_start=&quot;&quot;, comment_end=&quot;&quot; ):
        super( OutputChunk, self ).__init__( name )
        self.comment_start= comment_start
        self.comment_end= comment_end
    <a href="#pyweb69">&rarr;<em>OutputChunk add to the web</em> (69)</a>
    <a href="#pyweb70">&rarr;<em>OutputChunk weave</em> (70)</a>
    <a href="#pyweb71">&rarr;<em>OutputChunk tangle</em> (71)</a>

    </pre></code>
    <p>&loz; <em>OutputChunk class</em> (68).
      Used by <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">webAdd()</span> method adds this chunk to the given document <span class="code">Web</span>.
Each class of <span class="code">Chunk</span> must override this to be sure that the various
<span class="code">Chunk</span> classes are indexed properly.  This class uses the <span class="code">addOutput()</span> method
of the <span class="code">Web</span> class to append a file output chunk.
</p>


    <a name="pyweb69"></a>
    <!--line number 1779-->
    <p><em>OutputChunk add to the web</em> (69)&nbsp;=</p>
    <code><pre>

def webAdd( self, web ):
    &quot;&quot;&quot;Add self to a Web as output chunk, update xrefs.&quot;&quot;&quot;
    web.addOutput( self )

    </pre></code>
    <p>&loz; <em>OutputChunk add to the web</em> (69).
      Used by <a href="#pyweb68"><em>OutputChunk class</em>&nbsp;(68)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">weave()</span> method weaves this chunk into the final document as follows:</p>
<ol>
<li>call the <span class="code">Weaver</span> class <span class="code">codeBegin()</span> method to emit proper markup for an output file chunk.</li>
<li>visit each <span class="code">Command</span>, call the Command's <span class="code">weave()</span> method to emit the Command's content</li>
<li>call the <span class="code">Weaver</span> class <span class="code">codeEnd()</span> method to emit proper markup for an output file chunk.</li>
</ol>
<p>These chunks of documentation are never tangled.  Any attempt is an
error.</p>
<p>If a <span class="code">ReferenceCommand</span> does raise an error during weaving,
we append this <span class="code">Chunk</span> information and reraise the error with the additional 
context information.
</p>


    <a name="pyweb70"></a>
    <!--line number 1800-->
    <p><em>OutputChunk weave</em> (70)&nbsp;=</p>
    <code><pre>

def weave( self, aWeb, aWeaver ):
    &quot;&quot;&quot;Create the nicely formatted document from a chunk of code.&quot;&quot;&quot;
    # format as &lt;pre&gt; in a different-colored box
    self.fullName= aWeb.fullNameFor( self.name )
    aWeaver.fileBegin( self )
    try:
        for t in self.commands:
            t.weave( aWeb, aWeaver )
    except Error,e:
        raise Error,e.args+(self,)
    aWeaver.fileEnd( self )

    </pre></code>
    <p>&loz; <em>OutputChunk weave</em> (70).
      Used by <a href="#pyweb68"><em>OutputChunk class</em>&nbsp;(68)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb71"></a>
    <!--line number 1816-->
    <p><em>OutputChunk tangle</em> (71)&nbsp;=</p>
    <code><pre>

def tangle( self, aWeb, aTangler ):
    aTangler.comment_start= self.comment_start
    aTangler.comment_end= self.comment_end
    super( OutputChunk, self ).tangle( aWeb, aTangler )

    </pre></code>
    <p>&loz; <em>OutputChunk tangle</em> (71).
      Used by <a href="#pyweb68"><em>OutputChunk class</em>&nbsp;(68)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>

<h4>NamedDocumentChunk class</h4>
<h5>Usage</h5>
<p>A <span class="code">NamedDocumentChunk</span> is created and used identically to a <span class="code">NamedChunk</span>.
The difference between this class and the parent class is that this chunk
is only woven when referenced.  The original definition is silently skipped.
</p>

<h5>Design</h5>

<p>The <span class="code">NamedDocumentChunk</span> class is a subclass of <span class="code">NamedChunk</span> that handles 
named chunks defined with <tt>@d</tt> and the <tt>@[</tt>...<tt>@]</tt> delimiters.  
These are woven slightly
differently, since they are document source, not programming language source.
</p>
<p>We're not as interested in the cross reference of named document chunks.
They can be used multiple times or never.  They are often referenced
by anonymous chunks.  While this chunk subclass participates in this data 
gathering, it is ignored for reporting purposes.</p>
<p>All other methods, including the tangle method are identical to <span class="code">NamedChunk</span>.</p>

<h5>Implementation</h5>


    <a name="pyweb72"></a>
    <!--line number 1845-->
    <p><em>NamedDocumentChunk class</em> (72)&nbsp;=</p>
    <code><pre>

class NamedDocumentChunk( NamedChunk ):
    &quot;&quot;&quot;Named piece of input file with document source, defines an output tangle.&quot;&quot;&quot;
    def makeContent( self, text, lineNumber=0 ):
        return TextCommand( text, lineNumber )
    <a href="#pyweb73">&rarr;<em>NamedDocumentChunk weave</em> (73)</a>
    <a href="#pyweb74">&rarr;<em>NamedDocumentChunk tangle</em> (74)</a>

    </pre></code>
    <p>&loz; <em>NamedDocumentChunk class</em> (72).
      Used by <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">weave()</span> method quietly ignores this chunk in the document.
A named document chunk is only included when it is referenced 
during weaving of another chunk (usually an anonymous document
chunk).
</p>
<p>The <span class="code">weaveReferenceTo()</span> method inserts the content of this
chunk into the output document.  This is done in response to a
<span class="code">ReferenceCommand</span> in another chunk.  
The <span class="code">weaveShortReferenceTo()</span> method calls the <span class="code">weaveReferenceTo()</span>
to insert the entire chunk.
</p>


    <a name="pyweb73"></a>
    <!--line number 1868-->
    <p><em>NamedDocumentChunk weave</em> (73)&nbsp;=</p>
    <code><pre>

def weave( self, aWeb, aWeaver ):
    &quot;&quot;&quot;Ignore this when producing the document.&quot;&quot;&quot;
    pass
def weaveReferenceTo( self, aWeb, aWeaver ):
    &quot;&quot;&quot;On a reference to this chunk, expand the body in place.&quot;&quot;&quot;
    try:
        for t in self.commands:
            t.weave( aWeb, aWeaver )
    except Error,e:
        raise Error,e.args+(self,)
def weaveShortReferenceTo( self, aWeb, aWeaver ):
    &quot;&quot;&quot;On a reference to this chunk, expand the body in place.&quot;&quot;&quot;
    self.weaveReferenceTo( aWeb, aWeaver )

    </pre></code>
    <p>&loz; <em>NamedDocumentChunk weave</em> (73).
      Used by <a href="#pyweb72"><em>NamedDocumentChunk class</em>&nbsp;(72)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb74"></a>
    <!--line number 1886-->
    <p><em>NamedDocumentChunk tangle</em> (74)&nbsp;=</p>
    <code><pre>

def tangle( self, aWeb, aTangler ):
    &quot;&quot;&quot;Raise an exception on an attempt to tangle.&quot;&quot;&quot;
    raise Error( &quot;Cannot tangle a chunk defined with @[.&quot;&quot;&quot; )

    </pre></code>
    <p>&loz; <em>NamedDocumentChunk tangle</em> (74).
      Used by <a href="#pyweb72"><em>NamedDocumentChunk class</em>&nbsp;(72)</a>; <a href="#pyweb51"><em>Chunk class hierarchy - used to describe input chunks</em>&nbsp;(51)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h3>Commands</h3>

<p>The input stream is broken into individual commands, based on the
various <tt>@<i>x</i></tt> strings in the file.  There are several subclasses of <span class="code">Command</span>,
each used to describe a different command or block of text in the input.
</p>

<p>All instances of the <span class="code">Command</span> class are created by a <span class="code">WebReader</span> instance.  
In this case, a <span class="code">WebReader</span> can be thought of as a factory for <span class="code">Command</span> instances.
Each <span class="code">Command</span> instance is appended to the sequence of commands that
belong to a <span class="code">Chunk</span>.  A chunk may be as small as a single command, or a long sequence
of commands.</p>

<p>Each command instance responds to methods to examine the content, gather 
cross reference information and tangle a file or weave the final document.
</p>


    <a name="pyweb75"></a>
    <!--line number 1911-->
    <p><em>Command class hierarchy - used to describe individual commands</em> (75)&nbsp;=</p>
    <code><pre>

<a href="#pyweb76">&rarr;<em>Command superclass</em> (76)</a>
<a href="#pyweb79">&rarr;<em>TextCommand class to contain a document text block</em> (79)</a>
<a href="#pyweb80">&rarr;<em>CodeCommand class to contain a program source code block</em> (80)</a>
<a href="#pyweb81">&rarr;<em>XrefCommand superclass for all cross-reference commands</em> (81)</a>
<a href="#pyweb82">&rarr;<em>FileXrefCommand class for an output file cross-reference</em> (82)</a>
<a href="#pyweb83">&rarr;<em>MacroXrefCommand class for a named chunk cross-reference</em> (83)</a>
<a href="#pyweb84">&rarr;<em>UserIdXrefCommand class for a user identifier cross-reference</em> (84)</a>
<a href="#pyweb85">&rarr;<em>ReferenceCommand class for chunk references</em> (85)</a>

    </pre></code>
    <p>&loz; <em>Command class hierarchy - used to describe individual commands</em> (75).
      Used by <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>Command Superclass</h4>

<h5>Usage</h5>
<p>A <span class="code">Command</span> is created by the <span class="code">WebReader</span>, and attached to a <span class="code">Chunk</span>.
The Command participates in cross reference creation, weaving and tangling.
</p>
<p>The <span class="code">Command</span> superclass is abstract, and has default methods factored out
of the various subclasses.  When a subclass is created, it will override some
of the methods provided in this superclass.
</p>
<pre>
class MyNewCommand( Command ):
    ... overrides for various methods ...
</pre>
<p>Additionally, a subclass of <span class="code">WebReader</span> must be defined to parse the new command
syntax.  The main <span class="code">process()</span> function must also be updated to use this new subclass
of <span class="code">WebReader</span>.</p>

<h5>Design</h5>

<p>The <span class="code">Command</span> superclass provides the parent class definition
for all of the various command types.  The most common command
is a block of text, which is woven or tangled.  The next most
common command is a reference to a chunk, which is woven as a 
mark-up reference, but tangled as an expansion of the source 
code.
</p>

<ul>
<li>The <span class="code">startswith()</span> method examines any source text to see if
it begins with the given prefix text.</li>
<li>The <span class="code">searchForRE()</span> method examines any source text to see if
it matches the given regular expression, usually a match for a user identifier.</li>
<li>The <span class="code">ref()</span> method is ignored by all but the <span class="code">Reference</span> subclass,
which returns reference made by the command to the parent chunk.</li>
<li>The <span class="code">weave()</span> method weaves this into the output.  If a document text
command, it is emitted directly; if a program source code command, 
markup is applied.  In the case of cross-reference commands,
the actual cross-reference content is emitted.  In the case of 
reference commands, they are woven as a reference to a named
chunk.</li>
<li>The <span class="code">tangle()</span> method tangles this into the output.  If a
this is a document text command, it is ignored; if a this is a
program source code
command, it is indented and emitted.  In the case of cross-reference
commands, no output is produced.  In the case of reference
commands, the named chunk is indented and emitted.</li>
</ul>
<p>The attributes of a <span class="code">Command</span> instance includes the line number on which
the command began, in <i>lineNumber</i>.</p>

<h5>Implementation</h5>


    <a name="pyweb76"></a>
    <!--line number 1976-->
    <p><em>Command superclass</em> (76)&nbsp;=</p>
    <code><pre>

class Command( object ):
    &quot;&quot;&quot;A Command is the lowest level of granularity in the input stream.&quot;&quot;&quot;
    def __init__( self, fromLine=0 ):
        self.lineNumber= fromLine
        self.chunk= None
    def __str__( self ):
        return &quot;at %r&quot; % self.lineNumber
    <a href="#pyweb77">&rarr;<em>Command analysis features: starts-with and Regular Expression search</em> (77)</a>
    <a href="#pyweb78">&rarr;<em>Command tangle and weave functions</em> (78)</a>

    </pre></code>
    <p>&loz; <em>Command superclass</em> (76).
      Used by <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb77"></a>
    <!--line number 1990-->
    <p><em>Command analysis features: starts-with and Regular Expression search</em> (77)&nbsp;=</p>
    <code><pre>

def startswith( self, prefix ):
    return None
def searchForRE( self, rePat ):
    return None
def indent( self ):
    return None

    </pre></code>
    <p>&loz; <em>Command analysis features: starts-with and Regular Expression search</em> (77).
      Used by <a href="#pyweb76"><em>Command superclass</em>&nbsp;(76)</a>; <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb78"></a>
    <!--line number 2001-->
    <p><em>Command tangle and weave functions</em> (78)&nbsp;=</p>
    <code><pre>

def ref( self, aWeb ):
    return None
def weave( self, aWeb, aWeaver ):
    pass
def tangle( self, aWeb, aTangler ):
    pass

    </pre></code>
    <p>&loz; <em>Command tangle and weave functions</em> (78).
      Used by <a href="#pyweb76"><em>Command superclass</em>&nbsp;(76)</a>; <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>TextCommand class</h4>
<h5>Usage</h5>

<p>A <span class="code">TextCommand</span> is created by a <span class="code">Chunk</span> or a <span class="code">NamedDocumentChunk</span> when a 
<span class="code">WebReader</span> calls the chunk's <span class="code">appendText()</span> method.
This Command participates in cross reference creation, weaving and tangling.  When it is
created, the source line number is provided so that this text can be tied back
to the source document. 
</p>

<h5>Design</h5>
<p>An instance of the <span class="code">TextCommand</span> class is a block of document text.  It can originate
in an anonymous block or a named chunk delimited with <tt>@[</tt> and <tt>@]</tt>.
</p>
<p>This subclass provides a concrete implementation for all of the methods.  Since
text is the author's original markup language, it is emitted directly to the weaver
or tangler.
</p>

<h5>Implementation</h5>



    <a name="pyweb79"></a>
    <!--line number 2034-->
    <p><em>TextCommand class to contain a document text block</em> (79)&nbsp;=</p>
    <code><pre>

class TextCommand( Command ):
    &quot;&quot;&quot;A piece of document source text.&quot;&quot;&quot;
    def __init__( self, text, fromLine=0 ):
        super( TextCommand, self ).__init__( fromLine )
        self.text= text
    def __str__( self ):
        return &quot;at %r: %r...&quot; % (self.lineNumber,self.text[:32])
    def startswith( self, prefix ):
        return self.text.startswith( prefix )
    def searchForRE( self, rePat ):
        return rePat.search( self.text )
    def indent( self ):
        if self.text.endswith('\n'):
            return 0
        try:
            last_line = self.text.splitlines()[-1]
            return len(last_line)
        except IndexError:
            return 0
    def weave( self, aWeb, aWeaver ):
        aWeaver.write( self.text )
    def tangle( self, aWeb, aTangler ):
        aTangler.write( self.text )

    </pre></code>
    <p>&loz; <em>TextCommand class to contain a document text block</em> (79).
      Used by <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>CodeCommand class</h4>
<h5>Usage</h5>
<p>A <span class="code">CodeCommand</span> is created by a <span class="code">NamedChunk</span> when a 
<span class="code">WebReader</span> calls the <span class="code">appendText()</span> method.
The Command participates in cross reference creation, weaving and tangling.  When it is
created, the source line number is provided so that this text can be tied back
to the source document. 
</p>
<h5>Design</h5>
<p>An instance of the <span class="code">CodeCommand</span> class is a block of program source code text.
It can originate in a named chunk (<tt>@d</tt>) with a <tt>@{</tt> and <tt>@}</tt> delimiter.
Or it can be a file output chunk (<tt>@o</tt>).
</p>
<p>It uses the <span class="code">codeBlock()</span> methods of a <span class="code">Weaver</span> or <span class="code">Tangler</span>.  The weaver will 
insert appropriate markup for this code.  The tangler will assure that the prevailing
indentation is maintained.
<h5>Implementation</h5>


    <a name="pyweb80"></a>
    <!--line number 2080-->
    <p><em>CodeCommand class to contain a program source code block</em> (80)&nbsp;=</p>
    <code><pre>

class CodeCommand( TextCommand ):
    &quot;&quot;&quot;A piece of program source code.&quot;&quot;&quot;
    def weave( self, aWeb, aWeaver ):
        aWeaver.codeBlock( aWeaver.quote( self.text ) )
    def tangle( self, aWeb, aTangler ):
        aTangler.codeBlock( self.text )

    </pre></code>
    <p>&loz; <em>CodeCommand class to contain a program source code block</em> (80).
      Used by <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>XrefCommand superclass</h4>
<h5>Usage</h5>
<p>An <span class="code">XrefCommand</span> is created by the <span class="code">WebReader</span> when any of the 
<tt>@f</tt>, <tt>@m</tt>, <tt>@u</tt> commands are found in the input stream.
The Command is then appended to the current Chunk being built by the WebReader.
</p>

<h5>Design</h5>
<p>The <span class="code">XrefCommand</span> superclass defines any common features of the
various cross-reference commands (<tt>@f</tt>, <tt>@m</tt>, <tt>@u</tt>).
</p>
<p>The <span class="code">formatXref()</span> method creates the body of a cross-reference
by the following algorithm:</p>
<ol>
<li>Use the <span class="code">Weaver</span> class <span class="code">xrefHead()</span> method to emit the cross-reference header.</li>
<li>Sort the keys in the cross-reference mapping.</li>
<li>Use the <span class="code">Weaver</span> class <span class="code">xrefLine()</span> method to emit each line of the cross-reference mapping.</li>
<li>Use the <span class="code">Weaver</span> class <span class="code">xrefFoot()</span> method to emit the cross-reference footer.</li>
</ol>
<p>If this command winds up in a tangle action, that use
is illegal.  An exception is raised and processing stops.
</p>
 
<h5>Implementation</h5>


    <a name="pyweb81"></a>
    <!--line number 2116-->
    <p><em>XrefCommand superclass for all cross-reference commands</em> (81)&nbsp;=</p>
    <code><pre>

class XrefCommand( Command ):
    &quot;&quot;&quot;Any of the Xref-goes-here commands in the input.&quot;&quot;&quot;
    def __str__( self ):
        return &quot;at %r: cross reference&quot; % (self.lineNumber)
    def formatXref( self, xref, aWeaver ):
        aWeaver.xrefHead()
        for n in sorted(xref):
            aWeaver.xrefLine( n, xref[n] )
        aWeaver.xrefFoot()
    def tangle( self, aWeb, aTangler ):
        raise Error('Illegal tangling of a cross reference command.')

    </pre></code>
    <p>&loz; <em>XrefCommand superclass for all cross-reference commands</em> (81).
      Used by <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>FileXrefCommand class</h4>
<h5>Usage</h5>
<p>A <span class="code">FileXrefCommand</span> is created by the <span class="code">WebReader</span> when the 
<tt>@f</tt> command is found in the input stream.
The Command is then appended to the current Chunk being built by the WebReader.
</p>
<h5>Design</h5>
<p>The <span class="code">FileXrefCommand</span> class weave method gets the
file cross reference from the overall web instance, and uses
the  <span class="code">formatXref()</span> method of the <span class="code">XrefCommand</span> superclass for format this result.
</p>

<h5>Implementation</h5>


    <a name="pyweb82"></a>
    <!--line number 2146-->
    <p><em>FileXrefCommand class for an output file cross-reference</em> (82)&nbsp;=</p>
    <code><pre>

class FileXrefCommand( XrefCommand ):
    &quot;&quot;&quot;A FileXref command.&quot;&quot;&quot;
    def weave( self, aWeb, aWeaver ):
        &quot;&quot;&quot;Weave a File Xref from @o commands.&quot;&quot;&quot;
        self.formatXref( aWeb.fileXref(), aWeaver )

    </pre></code>
    <p>&loz; <em>FileXrefCommand class for an output file cross-reference</em> (82).
      Used by <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>MacroXrefCommand class</h4>
<h5>Usage</h5>
<p>A <span class="code">MacroXrefCommand</span> is created by the <span class="code">WebReader</span> when the 
<tt>@m</tt> command is found in the input stream.
The Command is then appended to the current Chunk being built by the WebReader.
</p>
<h5>Design</h5>

<p>The <span class="code">MacroXrefCommand</span> class weave method gets the
named chunk (macro) cross reference from the overall web instance, and uses
the <span class="code">formatXref()</span> method of the <span class="code">XrefCommand</span> superclass method for format this result.
</p>

<h5>Implementation</h5>


    <a name="pyweb83"></a>
    <!--line number 2171-->
    <p><em>MacroXrefCommand class for a named chunk cross-reference</em> (83)&nbsp;=</p>
    <code><pre>

class MacroXrefCommand( XrefCommand ):
    &quot;&quot;&quot;A MacroXref command.&quot;&quot;&quot;
    def weave( self, aWeb, aWeaver ):
        &quot;&quot;&quot;Weave the Macro Xref from @d commands.&quot;&quot;&quot;
        self.formatXref( aWeb.chunkXref(), aWeaver )

    </pre></code>
    <p>&loz; <em>MacroXrefCommand class for a named chunk cross-reference</em> (83).
      Used by <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>UserIdXrefCommand class</h4>
<h5>Usage</h5>
<p>A <span class="code">MacroXrefCommand</span> is created by the <span class="code">WebReader</span> when the 
<tt>@u</tt> command is found in the input stream.
The Command is then appended to the current Chunk being built by the WebReader.
</p>
<h5>Design</h5>

<p>The <span class="code">UserIdXrefCommand</span> class weave method gets the
user identifier cross reference information from the 
overall web instance.  It then formats this line using the following 
algorithm, which is similar to the algorithm in the <span class="code">XrefCommand</span> superclass.
</p>
<ol>
<li>Use the <span class="code">Weaver</span> class <span class="code">xrefHead()</span> method to emit the cross-reference header.</li>
<li>Sort the keys in the cross-reference mapping.</li>
<li>Use the <span class="code">Weaver</span> class <span class="code">xrefDefLine()</span> method to emit each line of the cross-reference definition mapping.</li>
<li>Use the <span class="code">Weaver</span> class <span class="code">xrefFoor()</span> method to emit the cross-reference footer.</li>
</ol>
<h5>Implementation</h5>


    <a name="pyweb84"></a>
    <!--line number 2202-->
    <p><em>UserIdXrefCommand class for a user identifier cross-reference</em> (84)&nbsp;=</p>
    <code><pre>

class UserIdXrefCommand( XrefCommand ):
    &quot;&quot;&quot;A UserIdXref command.&quot;&quot;&quot;
    def weave( self, aWeb, aWeaver ):
        &quot;&quot;&quot;Weave a user identifier Xref from @d commands.&quot;&quot;&quot;
        ux= aWeb.userNamesXref()
        aWeaver.xrefHead()
        for u in sorted(ux):
            defn, refList= ux[u]
            aWeaver.xrefDefLine( u, defn, refList )
        aWeaver.xrefFoot()

    </pre></code>
    <p>&loz; <em>UserIdXrefCommand class for a user identifier cross-reference</em> (84).
      Used by <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>ReferenceCommand class</h4>
<h5>Usage</h5>
<p>A <span class="code">ReferenceCommand</span> instance is created by a <span class="code">WebReader</span> when
 a <tt>@&lt;<i>name</i>@&gt;</tt> construct in is found in the input stream.  This is attached
 to the current <span class="code">Chunk</span> being built by the WebReader.  
 </p>

<h5>Design</h5>
<p>During a weave, this creates a markup reference to
another <span class="code">NamedChunk</span>.  During tangle, this actually includes the <span class="code">NamedChunk</span> 
at this point in the tangled output file.
</p>

<p>The constructor creates several attributes of an instance
of a <span class="code">ReferenceCommand</span>.
</p>
<ul>
<li><i>refTo</i>, the name of the chunk to which this refers, possibly 
elided with a trailing <tt>'...'</tt>.</li>
<li><i>fullName</i>, the full name of the chunk to which this refers.</li>
<li><i>chunkList</i>, the list of the chunks to which the name refers.</li>
</ul>

<h5>Implementation</h5>



    <a name="pyweb85"></a>
    <!--line number 2243-->
    <p><em>ReferenceCommand class for chunk references</em> (85)&nbsp;=</p>
    <code><pre>

class ReferenceCommand( Command ):
    &quot;&quot;&quot;A reference to a named chunk, via @&lt;name@&gt;.&quot;&quot;&quot;
    def __init__( self, refTo, fromLine=0 ):
        Command.__init__( self, fromLine )
        self.refTo= refTo
        self.fullname= None
        self.sequenceList= None
        self.chunkList= []
    def __str__( self ):
        return &quot;at %r: reference to chunk %r&quot; % (self.lineNumber,self.refTo)
    <a href="#pyweb86">&rarr;<em>ReferenceCommand resolve a referenced chunk name</em> (86)</a>
    <a href="#pyweb87">&rarr;<em>ReferenceCommand refers to a chunk</em> (87)</a>
    <a href="#pyweb88">&rarr;<em>ReferenceCommand weave a reference to a chunk</em> (88)</a>
    <a href="#pyweb89">&rarr;<em>ReferenceCommand tangle a referenced chunk</em> (89)</a>

    </pre></code>
    <p>&loz; <em>ReferenceCommand class for chunk references</em> (85).
      Used by <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">resolve()</span> method queries the overall <span class="code">Web</span> instance for the full
name and sequence number for this chunk reference.  This is used
by the <span class="code">Weaver</span> class <span class="code">referenceTo()</span> method to write the markup reference
to the chunk.
</p>


    <a name="pyweb86"></a>
    <!--line number 2268-->
    <p><em>ReferenceCommand resolve a referenced chunk name</em> (86)&nbsp;=</p>
    <code><pre>

def resolve( self, aWeb ):
    &quot;&quot;&quot;Expand the referenced chunk name into a full name and list of parts&quot;&quot;&quot;
    self.fullName= aWeb.fullNameFor( self.refTo )
    self.chunkList= [ c.seq for c in aWeb.getchunk( self.refTo ) ]

    </pre></code>
    <p>&loz; <em>ReferenceCommand resolve a referenced chunk name</em> (86).
      Used by <a href="#pyweb85"><em>ReferenceCommand class for chunk references</em>&nbsp;(85)</a>; <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">ref()</span> method is a request that is delegated by a <span class="code">Chunk</span>;
it resolves the reference this Command makes within the containing Chunk.
When the Chunk iterates through the Commands, it can accumulate a list of 
Chinks to which it refers.
</p>


    <a name="pyweb87"></a>
    <!--line number 2283-->
    <p><em>ReferenceCommand refers to a chunk</em> (87)&nbsp;=</p>
    <code><pre>

def ref( self, aWeb ):
    &quot;&quot;&quot;Find and return the full name for this reference.&quot;&quot;&quot;
    self.resolve( aWeb )
    return self.fullName

    </pre></code>
    <p>&loz; <em>ReferenceCommand refers to a chunk</em> (87).
      Used by <a href="#pyweb85"><em>ReferenceCommand class for chunk references</em>&nbsp;(85)</a>; <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">weave()</span> method inserts a markup reference to a named
chunk.  It uses the <span class="code">Weaver</span> class <span class="code">referenceTo()</span> method to format
this appropriately for the document type being woven.
</p>


    <a name="pyweb88"></a>
    <!--line number 2297-->
    <p><em>ReferenceCommand weave a reference to a chunk</em> (88)&nbsp;=</p>
    <code><pre>

def weave( self, aWeb, aWeaver ):
    &quot;&quot;&quot;Create the nicely formatted reference to a chunk of code.&quot;&quot;&quot;
    self.resolve( aWeb )
    aWeb.weaveChunk( self.fullName, aWeaver )

    </pre></code>
    <p>&loz; <em>ReferenceCommand weave a reference to a chunk</em> (88).
      Used by <a href="#pyweb85"><em>ReferenceCommand class for chunk references</em>&nbsp;(85)</a>; <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">tangle()</span> method inserts the resolved chunk in this
place.  When a chunk is tangled, it sets the indent,
inserts the chunk and resets the indent.
</p>


    <a name="pyweb89"></a>
    <!--line number 2311-->
    <p><em>ReferenceCommand tangle a referenced chunk</em> (89)&nbsp;=</p>
    <code><pre>

def tangle( self, aWeb, aTangler ):
    &quot;&quot;&quot;Create source code.&quot;&quot;&quot;
    self.resolve( aWeb )
    # Update indent based on last line of previous command. 
    if self.chunk is None or self.chunk.previous_command is None:
        logger.error( &quot;Command disconnected from Chunk.&quot; )
        raise Error( &quot;Serious problem in WebReader.&quot; )
    logger.debug( &quot;Indent %s + %r&quot;, aTangler.context, self.chunk.previous_command.indent() )
    aTangler.setIndent( command=self.chunk.previous_command )
    aWeb.tangleChunk( self.fullName, aTangler )
    aTangler.clrIndent()

    </pre></code>
    <p>&loz; <em>ReferenceCommand tangle a referenced chunk</em> (89).
      Used by <a href="#pyweb85"><em>ReferenceCommand class for chunk references</em>&nbsp;(85)</a>; <a href="#pyweb75"><em>Command class hierarchy - used to describe individual commands</em>&nbsp;(75)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h3>Error class</h3>
<h4>Usage</h4>
<p>An <span class="code">Error</span> is raised whenever processing cannot continue.  Since it
is a subclass of Exception, it takes an arbitrary number of arguments.  The
first should be the basic message text.  Subsequent arguments provide 
additional details.  We will try to be sure that
all of our internal exceptions reference a specific chunk, if possible.
This means either including the chunk as an argument, or catching the 
exception and appending the current chunk to the exception's arguments.
<p>The
Python <tt>raise</tt> statement takes an instance of Error and passes it
to the enclosing <tt>try/except</tt> statement for processing.</p>
<p>The typical creation is as follows:</p>
<pre>
raise Error("No full name for %r" % chunk.name, chunk)
</pre> 
<p>A typical exception-handling suite might look like this:</p>
<pre>
try:
    ...something that may raise an Error or Exception...
except Error,e:
    print( e.args ) # this is a pyWeb internal Error
except Exception,w:
    print( w.args ) # this is some other Python Exception
</pre>

<h4>Design</h4>

<p>The <span class="code">Error</span> class is a subclass of <span class="code">Exception</span> used to differentiate 
application-specific
exceptions from other Python exceptions.  It does no additional processing,
but merely creates a distinct class to facilitate writing <tt>except</tt> statements.
</p>

<h4>Implementation</h4>


    <a name="pyweb90"></a>
    <!--line number 2363-->
    <p><em>Error class - defines the errors raised</em> (90)&nbsp;=</p>
    <code><pre>

class Error( Exception ): pass

    </pre></code>
    <p>&loz; <em>Error class - defines the errors raised</em> (90).
      Used by <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h3>The Reference Strategy Hierarchy</h3>
<p>The Reference Strategy has two implementations.  An instance
of this is injected into each Chunk by the Web.  The transitive closure
of references requires walking through the web.  By injecting this
algorithm, we assure that
that (1) each Chunk can produce all relevant information and (2) a
simple configuration change can be applied to the document.
</p>

<h4>Reference Superclass</h4>
<p>The superclass is an abstract class that defines the interface for
this object.
</p>


    <a name="pyweb91"></a>
    <!--line number 2382-->
    <p><em>Reference class hierarchy - references to a chunk</em> (91)&nbsp;=</p>
    <code><pre>

class Reference( object ):
    def __init__( self, aWeb ):
        self.web = aWeb
    def chunkReferencedBy( self, aChunk ):
        &quot;&quot;&quot;Return a list of Chunks.&quot;&quot;&quot;
        pass

    </pre></code>
    <p>&loz; <em>Reference class hierarchy - references to a chunk</em> (91).
      Used by <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>SimpleReference Class</h4>
<p>The SimpleReference subclass does the simplest version of resolution.</p>


    <a name="pyweb92"></a>
    <!--line number 2395-->
    <p><em>Reference class hierarchy - references to a chunk</em> (92)&nbsp;+=</p>
    <code><pre>

class SimpleReference( Reference ):
    def __init__( self, aWeb ):
        self.web = aWeb
    def chunkReferencedBy( self, aChunk ):
        &quot;&quot;&quot;:todo: Return the chunks themselves.&quot;&quot;&quot;
        refBy= aChunk.referencedBy
        return [ (c.fullName, c.seq) for c in refBy ]

    </pre></code>
    <p>&loz; <em>Reference class hierarchy - references to a chunk</em> (92).
      Used by <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>TransitiveReference Class</h4>
<p>The TransitiveReference subclass does a transitive closure of all
references to this Chunkn.</p>


    <a name="pyweb93"></a>
    <!--line number 2410-->
    <p><em>Reference class hierarchy - references to a chunk</em> (93)&nbsp;+=</p>
    <code><pre>

class TransitiveReference( Reference ):
    def __init__( self, aWeb ):
        self.web = aWeb
    def chunkReferencedBy( self, aChunk ):
        &quot;&quot;&quot;:todo: Return the chunks themselves.&quot;&quot;&quot;
        refBy= aChunk.referencedBy
        logger.debug( &quot;References: %r(%d) %r&quot;, aChunk.name, aChunk.seq, refBy )
        closure= self.allParentsOf( refBy )
        return [ (c.fullName, c.seq) for c in closure ]
    def allParentsOf( self, chunkList, depth=0 ):
        &quot;&quot;&quot;Transitive closure of parents.
        :todo: Return the chunks themselves.
        &quot;&quot;&quot;
        final = []
        for c in chunkList:
            final.append( c )
            final.extend( self.allParentsOf( c.referencedBy, depth+1 ) )
        logger.debug( &quot;References: %*s %r&quot;, 2*depth, '--', final )
        return final

    </pre></code>
    <p>&loz; <em>Reference class hierarchy - references to a chunk</em> (93).
      Used by <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



<h3>The Web Class</h3>

<p>The overall web of chunks is carried in a 
single instance of the <span class="code">Web</span> class that drives the weaving and tangling actions.  
Broadly, the functionality of a Web can be separated into several areas.
Fundamentally, a Web is a hybrid list-dictionary.  It's a list of chunks that also offers a 
moderately sophisticated
lookup, including exact match for a chunk name and an approximate match for a chunk name. It's a
dictionary that also retains anonymous chunks in order.
Additionally, there are some methods that can be refactored into the <span class="code">WebReader</span> for 
resolve references among chunks.
</p>
<ul>
<li>construction methods used by <span class="code">Chunks</span> and <span class="code">WebReader</span></li>
<li><span class="code">Chunk</span> name resolution methods</li>
<li>enrichment of the web, once all the Chunks are known; each Chunk is updated
with Chunk references it makes as well as Chunks which reference it.</li>
<li><span class="code">Chunk</span> cross reference methods</li>
<li>miscellaneous access</li>
<li>tangle</li>
<li>weave</li>
</ul>

<p>A web instance has a number of attributes.</p>
<ul>
<li><i>sourceFileName</i>, the name of the original .w file.</li>
<li><i>chunkSeq</i>, the sequence of <span class="code">Chunk</span> instances as seen in the input file.
To support anonymous chunks, and to assure that the original input document order
is preserved, we keep all chunks in a master sequential list.</li>
<li><i>output</i>, the <tt>@o</tt> named <span class="code">OutputChunk</span> chunks.  
Each element of this  dictionary is a sequence of chunks that have the same name. 
The first is the initial definition (marked with "="), all others a second definitions
(marked with "+=").</li>
<li><i>named</i>, the <tt>@d</tt> named <span class="code">NamedChunk</span> chunks.  Each element of this 
dictionary is a sequence of chunks that have the same name.  The first is the
initial definition (marked with "="), all others a second definitions
(marked with "+=").</li>
<li><i>usedBy</i>, the cross reference of chunks referenced by commands in other
chunks.</li>
<li><i>sequence</i>, is used to assign a unique sequence number to each
named chunk.</li>
</ul>


    <a name="pyweb94"></a>
    <!--line number 2477-->
    <p><em>Web class - describes the overall "web" of chunks</em> (94)&nbsp;=</p>
    <code><pre>

class Web( object ):
    &quot;&quot;&quot;The overall Web of chunks.&quot;&quot;&quot;
    def __init__( self, name ):
        self.webFileName= name
        self.chunkSeq= [] 
        self.output= {} # Map filename to Chunk
        self.named= {} # Map chunkname to Chunk
        self.sequence= 0
        self.reference_style = TransitiveReference(self)
    def __str__( self ):
        return &quot;Web %r&quot; % ( self.webFileName, )
    <a href="#pyweb95">&rarr;<em>Web construction methods used by Chunks and WebReader</em> (95)</a>
    <a href="#pyweb100">&rarr;<em>Web Chunk name resolution methods</em> (100)</a><a href="#pyweb101">(101)</a>
    <a href="#pyweb102">&rarr;<em>Web Chunk cross reference methods</em> (102)</a><a href="#pyweb104">(104)</a><a href="#pyweb105">(105)</a><a href="#pyweb106">(106)</a>
    <a href="#pyweb109">&rarr;<em>Web determination of the language from the first chunk</em> (109)</a>
    <a href="#pyweb110">&rarr;<em>Web tangle the output files</em> (110)</a>
    <a href="#pyweb111">&rarr;<em>Web weave the output document</em> (111)</a>

    </pre></code>
    <p>&loz; <em>Web class - describes the overall "web" of chunks</em> (94).
      Used by <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>During web construction, it is convenient to capture
information about the individual <span class="code">Chunk</span> instances being appended to
the web.  This done using a <i>Callback</i> design pattern.
Each subclass of <span class="code">Chunk</span> provides an override for the <span class="code">Chunk</span> class
<span class="code">webAdd()</span> method.  This override calls one of the appropriate
web construction methods.</p>
<p>Also note that the full name for a chunk can be given
either as part of the definition, or as part a reference.
Typically, the first reference has the full name and the definition
has the elided name.  This allows a reference to a chunk
to contain a more complete description of the chunk.
</p>


    <a name="pyweb95"></a>
    <!--line number 2512-->
    <p><em>Web construction methods used by Chunks and WebReader</em> (95)&nbsp;=</p>
    <code><pre>

<a href="#pyweb96">&rarr;<em>Web add full chunk names, ignoring abbreviated names</em> (96)</a>
<a href="#pyweb97">&rarr;<em>Web add an anonymous chunk</em> (97)</a>
<a href="#pyweb98">&rarr;<em>Web add a named macro chunk</em> (98)</a>
<a href="#pyweb99">&rarr;<em>Web add an output file definition chunk</em> (99)</a>

    </pre></code>
    <p>&loz; <em>Web construction methods used by Chunks and WebReader</em> (95).
      Used by <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>A name is only added to the known names when it is
a full name, not an abbreviation ending with <tt>"..."</tt>.
Abbreviated names are quietly skipped until the full name
is seen.
</p>

<p>The algorithm for the <span class="code">addDefName()</span> method, then is as follows:</p>
<ol>
<li>Use the <span class="code">fullNameFor()</span> method to locate the full name.</li>
<li>If no full name was found (the result of <span class="code">fullNameFor()</span> ends
with <tt>'...'</tt>), ignore this name as an abbreviation with no definition.</li>
<li>If this is a full name and the name was not in the 
<i>named</i> mapping, add this full name to the mapping.
</li>
</ol>

<p>This name resolution approach presents a problem when a chunk is
defined before it is referenced and the first definition
uses an abbreviated name.  This is an atypical construction
of an input document, however, since the intent is to provide
high-level summaries that have forward references to supporting
details.
</p>


    <a name="pyweb96"></a>
    <!--line number 2544-->
    <p><em>Web add full chunk names, ignoring abbreviated names</em> (96)&nbsp;=</p>
    <code><pre>

def addDefName( self, name ):
    &quot;&quot;&quot;Reference to or definition of a chunk name.&quot;&quot;&quot;
    nm= self.fullNameFor( name )
    if nm is None: return None
    if nm[-3:] == '...':
        logger.debug( &quot;Abbreviated reference %r&quot;, name )
        return None # first occurance is a forward reference using an abbreviation
    if nm not in self.named:
        self.named[nm]= []
        logger.debug( &quot;Adding empty chunk %r&quot;, name )
    return nm

    </pre></code>
    <p>&loz; <em>Web add full chunk names, ignoring abbreviated names</em> (96).
      Used by <a href="#pyweb95"><em>Web construction methods used by Chunks and WebReader</em>&nbsp;(95)</a>; <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>An anonymous <span class="code">Chunk</span> is kept in a sequence of chunks, used for
tangling.
</p>

    <a name="pyweb97"></a>
    <!--line number 2563-->
    <p><em>Web add an anonymous chunk</em> (97)&nbsp;=</p>
    <code><pre>

def add( self, chunk ):
    &quot;&quot;&quot;Add an anonymous chunk.&quot;&quot;&quot;
    self.chunkSeq.append( chunk )

    </pre></code>
    <p>&loz; <em>Web add an anonymous chunk</em> (97).
      Used by <a href="#pyweb95"><em>Web construction methods used by Chunks and WebReader</em>&nbsp;(95)</a>; <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>A named <span class="code">Chunk</span> is defined with a <tt>@d</tt> command.
It is collected into a mapping of <span class="code">NamedChunk</span> instances.
An entry in the mapping is a sequence of chunks that have the
same name.  This sequence of chunks is used to produce the
weave or tangle output.
</p>
<p>All chunks are also placed in the overall sequence of chunks.
This overall sequence is used for weaving the document.
</p>
<p>The <span class="code">addDefName()</span> method is used to resolve this name if
it is an abbreviation, or add it to the mapping if this
is the first occurance of the name.  If the name cannot be
added, an instance of our <span class="code">Error</span> class is raised.  If the name exists or 
was added, the chunk is appended to the chunk list associated
with this name.
</p>
<p>The web's sequence counter is incremented, and this 
unique sequence number sets the  <i>seq</i> attribute of the <span class="code">Chunk</span>.
If the chunk list was empty, this is the first chunk, the
<i>initial</i> flag is set to True when there's only one element
in the list.  Otherwise, it's false.
</p>


    <a name="pyweb98"></a>
    <!--line number 2594-->
    <p><em>Web add a named macro chunk</em> (98)&nbsp;=</p>
    <code><pre>

def addNamed( self, chunk ):
    &quot;&quot;&quot;Add a named chunk to a sequence with a given name.&quot;&quot;&quot;
    chunk.reference_style= self.reference_style
    self.chunkSeq.append( chunk )
    nm= self.addDefName( chunk.name )
    if nm:
        # We found the full name for this chunk
        self.sequence += 1
        chunk.seq= self.sequence
        chunk.fullName= nm
        self.named[nm].append( chunk )
        chunk.initial= len(self.named[nm]) == 1
        logger.debug( &quot;Extending chunk %r from %r&quot;, nm, chunk.name )
    else:
        raise Error(&quot;No full name for %r&quot; % chunk.name, chunk)

    </pre></code>
    <p>&loz; <em>Web add a named macro chunk</em> (98).
      Used by <a href="#pyweb95"><em>Web construction methods used by Chunks and WebReader</em>&nbsp;(95)</a>; <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>An output file definition <span class="code">Chunk</span> is defined with an <tt>@o</tt>
command.  It is collected into a mapping of <span class="code">OutputChunk</span> instances.
An entry in the mapping is a sequence of chunks that have the
same name.  This sequence of chunks is used to produce the
weave or tangle output.
</p>
<p>Note that file names cannot be abbreviated.</p>
<p>All chunks are also placed in overall sequence of chunks.
This overall sequence is used for weaving the document.
</p>
<p>If the name does not exist in the <i>output</i> mapping,
the name is added with an empty sequence of chunks.
In all cases, the chunk is 
appended to the chunk list associated
with this name.
</p>
<p>The web's sequence counter is incremented, and this 
unique sequence number sets the Chunk's <i>seq</i> attribute.
If the chunk list was empty, this is the first chunk, the
<i>initial</i> flag is True if this is the first chunk.
</p>



    <a name="pyweb99"></a>
    <!--line number 2637-->
    <p><em>Web add an output file definition chunk</em> (99)&nbsp;=</p>
    <code><pre>

def addOutput( self, chunk ):
    &quot;&quot;&quot;Add an output chunk to a sequence with a given name.&quot;&quot;&quot;
    chunk.reference_style= self.reference_style
    self.chunkSeq.append( chunk )
    if chunk.name not in self.output:
        self.output[chunk.name] = []
        logger.debug( &quot;Adding chunk %r&quot;, chunk.name )
    self.sequence += 1
    chunk.seq= self.sequence
    chunk.fullName= chunk.name
    self.output[chunk.name].append( chunk )
    chunk.initial = len(self.output[chunk.name]) == 1

    </pre></code>
    <p>&loz; <em>Web add an output file definition chunk</em> (99).
      Used by <a href="#pyweb95"><em>Web construction methods used by Chunks and WebReader</em>&nbsp;(95)</a>; <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>Web chunk name resolution has three aspects.  The first
is resolving elided names (those ending with <tt>...</tt>) to their
actual full names.  The second is finding the named chunk
in the web structure.  The third is returning a reference
to a specific chunk including the name and sequence number.
</p>
<p>Note that a chunk name actually refers to a sequence
of chunks.  Multiple definitions for a chunk are allowed, and
all of the definitions are concatenated to create the complete
chunk.  This complexity makes it unwise to return the sequence
of same-named chunks; therefore, we put the burden on the Web to 
process all chunks with a given name, in sequence.
</p>

<p>The <span class="code">fullNameFor()</span> method resolves full name for a chunk as follows:</p>
<ol>
<li>If the string is already in the <i>named</i> mapping, this is the full name</li>
<li>If the string ends in <tt>'...'</tt>, visit each key in the dictionary to see if the
key starts with the string up to the trailing <tt>'...'</tt>.  If a match is found, the dictionary
key is the full name.</li>
<li>Otherwise, treat this as a full name.</li>
</ol>


    <a name="pyweb100"></a>
    <!--line number 2677-->
    <p><em>Web Chunk name resolution methods</em> (100)&nbsp;=</p>
    <code><pre>

def fullNameFor( self, name ):
    &quot;&quot;&quot;Resolve &quot;...&quot; names into the full name.&quot;&quot;&quot;
    if name in self.named: return name
    if name[-3:] == '...':
        best= [ n for n in self.named.keys()
            if n.startswith( name[:-3] ) ]
        if len(best) &gt; 1:
            raise Error(&quot;Ambiguous abbreviation %r, matches %r&quot; % ( name, best ) )
        elif len(best) == 1: 
            return best[0]
    return name

    </pre></code>
    <p>&loz; <em>Web Chunk name resolution methods</em> (100).
      Used by <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">getchunk()</span> method locates a named sequence of chunks by first determining the full name
for the identifying string.  If full name is in the <i>named</i> mapping, the sequence
of chunks is returned.  Otherwise, an instance of our <span class="code">Error</span> class is raised because the name
is unresolvable.
</p>
<p>It might be more helpful for debugging to emit this as an error in the
weave and tangle results and keep processing.  This would allow an author to
catch multiple errors in a single run of <em>pyWeb</em>.</p>
 

    <a name="pyweb101"></a>
    <!--line number 2702-->
    <p><em>Web Chunk name resolution methods</em> (101)&nbsp;+=</p>
    <code><pre>

def getchunk( self, name ):
    &quot;&quot;&quot;Locate a named sequence of chunks.&quot;&quot;&quot;
    nm= self.fullNameFor( name )
    if nm in self.named:
        return self.named[nm]
    raise Error( &quot;Cannot resolve %r in %r&quot; % (name,self.named.keys()) )

    </pre></code>
    <p>&loz; <em>Web Chunk name resolution methods</em> (101).
      Used by <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>Cross-reference support includes creating and reporting
on the various cross-references available in a web.  This includes
creating the list of chunks that reference a given chunk;
and returning the file, macro and user identifier cross references.
</p>

<p>Each <span class="code">Chunk</span> has a list <span class="code">Reference</span> commands that shows the chunks
to which a chunk refers.  These relationships must be reversed to show
the chunks that refer to a given chunk.  This is done by traversing
the entire web of named chunks and recording each chunk-to-chunk reference.
This mapping has the referred-to chunk as 
the key, and a sequence of referring chunks as the value.
</p>

<p>The accumulation is initiated by the web's <span class="code">createUsedBy()</span> method.  This
method visits a <span class="code">Chunk</span>, calling the <span class="code">genReferences()</span> method, 
passing in the <span class="code">Web</span> instance
as an argument.  Each <span class="code">Chunk</span> class <span class="code">genReferences()</span> method, in turn, 
invokes the <span class="code">usedBy()</span> method
of each <span class="code">Command</span> instance in the chunk.  Most commands do nothing, 
but a <span class="code">ReferenceCommand</span>
will resolve the name to which it refers.
</p>
<p>When the <span class="code">createUsedBy()</span> method has accumulated the entire cross 
reference, it also assures that all chunks are used exactly once.</p>


    <a name="pyweb102"></a>
    <!--line number 2739-->
    <p><em>Web Chunk cross reference methods</em> (102)&nbsp;=</p>
    <code><pre>

def createUsedBy( self ):
    &quot;&quot;&quot;Update every piece of a Chunk to show how the chunk is referenced.
    Each piece can then report where it's used in the web.
    &quot;&quot;&quot;
    for aChunk in self.chunkSeq:
        #usage = (self.fullNameFor(aChunk.name), aChunk.seq)
        for aRefName in aChunk.genReferences( self ):
            for c in self.getchunk( aRefName ):
                c.referencedBy.append( aChunk )
                c.refCount += 1
    <a href="#pyweb103">&rarr;<em>Web Chunk check reference counts are all one</em> (103)</a>

    </pre></code>
    <p>&loz; <em>Web Chunk cross reference methods</em> (102).
      Used by <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>We verify that the reference count for a
chunk is exactly one.  We don't gracefully tolerate multiple references to
a chunk or unreferenced chunks.</p>

    <a name="pyweb103"></a>
    <!--line number 2758-->
    <p><em>Web Chunk check reference counts are all one</em> (103)&nbsp;=</p>
    <code><pre>

for nm in self.no_reference():
    logger.warn( &quot;No reference to %r&quot;, nm )
for nm in self.multi_reference():
    logger.warn( &quot;Multiple references to %r&quot;, nm )
for nm in self.no_definition():
    logger.warn( &quot;No definition for %r&quot;, nm )

    </pre></code>
    <p>&loz; <em>Web Chunk check reference counts are all one</em> (103).
      Used by <a href="#pyweb102"><em>Web Chunk cross reference methods</em>&nbsp;(102)</a>; <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The one-pass version</p>
<pre>
for nm,cl in self.named.items():
   if len(cl) > 0:
       if cl[0].refCount == 0:
           logger.warn( "No reference to %r", nm )
       elif cl[0].refCount > 1:
           logger.warn( "Multiple references to %r", nm )
   else:
       logger.warn( "No definition for %r", nm )
</pre>

<p>We use three methods to filter chunk names into 
the various warning categories.  The <span class="code">no_reference</span> list
is a list of chunks defined by never referenced.
The <span class="code">multi_reference</span> list
is a list of chunks defined by never referenced.
The <span class="code">no_definition</span> list
is a list of chunks referenced but not defined.
</p>


    <a name="pyweb104"></a>
    <!--line number 2789-->
    <p><em>Web Chunk cross reference methods</em> (104)&nbsp;+=</p>
    <code><pre>

def no_reference( self ):
    return [ nm for nm,cl in self.named.items() if len(cl)&gt;0 and cl[0].refCount == 0 ]
def multi_reference( self ):
    return [ nm for nm,cl in self.named.items() if len(cl)&gt;0 and cl[0].refCount &gt; 1 ]
def no_definition( self ):
    return [ nm for nm,cl in self.named.items() if len(cl) == 0 ] 

    </pre></code>
    <p>&loz; <em>Web Chunk cross reference methods</em> (104).
      Used by <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">fileXref()</span> method visits all named file output chunks in <i>output</i> and
collects the sequence numbers of each section in the sequence of chunks.
</p>
<p>The <span class="code">chunkXref()</span> method uses the same algorithm as a the <span class="code">fileXref()</span> method,
but applies it to the <i>named</i> mapping.
</p>


    <a name="pyweb105"></a>
    <!--line number 2807-->
    <p><em>Web Chunk cross reference methods</em> (105)&nbsp;+=</p>
    <code><pre>

def fileXref( self ):
    fx= {}
    for f,cList in self.output.items():
        fx[f]= [ c.seq for c in cList ]
    return fx
def chunkXref( self ):
    mx= {}
    for n,cList in self.named.items():
        mx[n]= [ c.seq for c in cList ]
    return mx

    </pre></code>
    <p>&loz; <em>Web Chunk cross reference methods</em> (105).
      Used by <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">userNamesXref()</span> method creates a mapping for each
user identifier.  The value for this mapping is a tuple
with the chunk that defined the identifer (via a <tt>@|</tt> command), 
and a sequence of chunks that reference the identifier. 
</p>
<p>For example:
<tt>{ 'Web': ( 87, (88,93,96,101,102,104) ), 'Chunk': ( 53, (54,55,56,60,57,58,59) ) }</tt>, 
shows that the identifier
<tt>'Web'</tt> is defined in chunk with a sequence number of 87, and referenced
in the sequence of chunks that follow.
</p>
<p>This works in two passes:</p>
<ul>
<li><span class="code">_gatherUserId()</span> gathers all user identifiers</li>
<li><span class="code">_updateUserId()</span> searches all text commands for the identifiers and
updates the <span class="code">Web</span> class cross reference information.</li>
</ul>


    <a name="pyweb106"></a>
    <!--line number 2840-->
    <p><em>Web Chunk cross reference methods</em> (106)&nbsp;+=</p>
    <code><pre>

def userNamesXref( self ):
    ux= {}
    self._gatherUserId( self.named, ux )
    self._gatherUserId( self.output, ux )
    self._updateUserId( self.named, ux )
    self._updateUserId( self.output, ux )
    return ux
def _gatherUserId( self, chunkMap, ux ):
    <a href="#pyweb107">&rarr;<em>collect all user identifiers from a given map into ux</em> (107)</a>
def _updateUserId( self, chunkMap, ux ):
    <a href="#pyweb108">&rarr;<em>find user identifier usage and update ux from the given map</em> (108)</a>

    </pre></code>
    <p>&loz; <em>Web Chunk cross reference methods</em> (106).
      Used by <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>User identifiers are collected by visiting each of the sequence of 
<span class="code">Chunks</span> that share the
same name; within each component chunk, if chunk has identifiers assigned
by the <tt>@|</tt> command, these are seeded into the dictionary.
If the chunk does not permit identifiers, it simply returns an empty
list as a default action.
</p>
 

    <a name="pyweb107"></a>
    <!--line number 2864-->
    <p><em>collect all user identifiers from a given map into ux</em> (107)&nbsp;=</p>
    <code><pre>

for n,cList in chunkMap.items():
    for c in cList:
        for id in c.getUserIDRefs():
            ux[id]= ( c.seq, [] )

    </pre></code>
    <p>&loz; <em>collect all user identifiers from a given map into ux</em> (107).
      Used by <a href="#pyweb106"><em>Web Chunk cross reference methods</em>&nbsp;(106)</a>; <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>User identifiers are cross-referenced by visiting 
each of the sequence of <span class="code">Chunks</span> that share the
same name; within each component chunk, visit each user identifier;
if the <span class="code">Chunk</span> class <span class="code">searchForRE()</span> method matches an identifier, 
this is appended to the sequence of chunks that reference the original user identifier.
</p>


    <a name="pyweb108"></a>
    <!--line number 2879-->
    <p><em>find user identifier usage and update ux from the given map</em> (108)&nbsp;=</p>
    <code><pre>

# examine source for occurances of all names in ux.keys()
for id in ux.keys():
    logger.debug( &quot;References to %r&quot;, id )
    idpat= re.compile( r'\W%s\W' % id )
    for n,cList in chunkMap.items():
        for c in cList:
            if c.seq != ux[id][0] and c.searchForRE( idpat ):
                ux[id][1].append( c.seq )

    </pre></code>
    <p>&loz; <em>find user identifier usage and update ux from the given map</em> (108).
      Used by <a href="#pyweb106"><em>Web Chunk cross reference methods</em>&nbsp;(106)</a>; <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">language()</span> method determines the output language.
The determination of the language can be done a variety of ways.
One is to use command line parameters, another is to use the filename
extension on the input file.</p>
<p>We examine the first few characters of input.  A proper HTML, XHTML or
XML file begins with '&lt;!', '&lt;?' or '&lt;H'.  LaTeX files
typically begin with '%' or '\'.
</p>


    <a name="pyweb109"></a>
    <!--line number 2900-->
    <p><em>Web determination of the language from the first chunk</em> (109)&nbsp;=</p>
    <code><pre>

def language( self, preferredWeaverClass=None ):
    &quot;&quot;&quot;Construct a weaver appropriate to the document's language&quot;&quot;&quot;
    if preferredWeaverClass:
        return preferredWeaverClass()
    if self.chunkSeq[0].startswith('&lt;'): return HTML()
    if self.chunkSeq[0].startswith('%') or self.chunkSeq[0].startswith('\\'):  return LaTeX()
    return Weaver()

    </pre></code>
    <p>&loz; <em>Web determination of the language from the first chunk</em> (109).
      Used by <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">tangle()</span> method of the <span class="code">Web</span> class performs 
the <span class="code">tangle()</span> method for each <span class="code">Chunk</span> of each
named output file.  Note that several chunks may share the file name, requiring
the file be composed of material in each chunk.
</p>
<p>During tangling of a chunk, the chunk may reference another
chunk.  This transitive tangling of an individual chunk is handled by the
<span class="code">tangleChunk()</span> method.
</p>


    <a name="pyweb110"></a>
    <!--line number 2922-->
    <p><em>Web tangle the output files</em> (110)&nbsp;=</p>
    <code><pre>

def tangle( self, aTangler ):
    for f,c in self.output.items():
        aTangler.open( f )
        for p in c:
            p.tangle( self, aTangler )
        aTangler.close()
def tangleChunk( self, name, aTangler ):
    logger.debug( &quot;Tangling chunk %r&quot;, name )
    chunkList= self.getchunk(name)
    if len(chunkList) == 0:
        raise Error( &quot;Attempt to tangle an undefined Chunk, %s.&quot; % ( name, ) )
    for p in chunkList:
        p.tangle( self, aTangler )

    </pre></code>
    <p>&loz; <em>Web tangle the output files</em> (110).
      Used by <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">weave()</span> method of the <span class="code">Web</span> class creates the final documentation.
This is done by stepping through each <span class="code">Chunk</span> in sequence
and weaving the chunk into the resulting file via the <span class="code">Chunk</span> class <span class="code">weave()</span> method.
</p>
<p>During weaving of a chunk, the chunk may reference another
chunk.  When weaving a reference to a named chunk (output or ordinary programming
source defined with @{), this does not lead to transitive weaving: only a
reference is put in from one chunk to another.  However, when weaving
a chunk defined with @[, the chunk <i>is</i> expanded when weaving.
The decision is delegated to the referenced chunk.
</p>


    <a name="pyweb111"></a>
    <!--line number 2952-->
    <p><em>Web weave the output document</em> (111)&nbsp;=</p>
    <code><pre>

def weave( self, aWeaver ):
    aWeaver.open( self.webFileName )
    for c in self.chunkSeq:
        c.weave( self, aWeaver )
    aWeaver.close()
def weaveChunk( self, name, aWeaver ):
    logger.debug( &quot;Weaving chunk %r&quot;, name )
    chunkList= self.getchunk(name)
    if not chunkList:
        raise Error( &quot;No Definition for %s&quot;, name )
    chunkList[0].weaveReferenceTo( self, aWeaver )
    for p in chunkList[1:]:
        p.weaveShortReferenceTo( self, aWeaver )

    </pre></code>
    <p>&loz; <em>Web weave the output document</em> (111).
      Used by <a href="#pyweb94"><em>Web class - describes the overall "web" of chunks</em>&nbsp;(94)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h3>The WebReader Class</h3>

<h4>Usage</h4>

<p>There are two forms of the constructor for a <span class="code">WebReader</span>.  The 
initial <span class="code">WebReader</span> instance is created with code like the following:
</p>
<pre>
p= WebReader( aFileName, command=aCommandCharacter )
</pre>
<p>
This will define the initial input file and the command character, both
of which are command-line parameters to the application.
</p>
<p>When processing an include file (with the @i command), a child <span class="code">WebReader</span>
instance is created with code like the following:
</p>
<pre>
c= WebReader( anIncludeName, parent=parentWebReader )
</pre>
<p>
This will define the included file, but will inherit the command 
character from the parent <span class="code">WebReader</span>.  This will also include a 
reference from child to parent so that embedded Python expressions
can view the entire input context.
</p>

<h4>Design</h4>

<p>The <span class="code">WebReader</span> class parses the input file into command blocks.
These are assembled into <span class="code">Chunks</span>, and the <span class="code">Chunks</span> are assembled into the document
<span class="code">Web</span>.  Once this input pass is complete, the resulting <span class="code">Web</span> can be tangled or
woven.
</p>

<p>The parser works by reading the entire file and splitting on <tt>@.</tt> patterns.
The <span class="code">split()</span> method of the Python <span class="code">re</span> module will separate the input
and preserve the actual character sequence on which the input was split.
This breaks the input into blocks of text separated by the <tt>@.</tt> characters.
</p>

<p>"Major" commands partition the input into <span class="code">Chunks</span>.  The major commands 
are <tt>@d</tt> and <tt>@o</tt>, as well as the <tt>@{</tt>, <tt>@}</tt>, <tt>@[</tt>, <tt>@]</tt> brackets, and the <tt>@i</tt> command
to include another file.
</p>
<p>"Minor" commands are inserted into a <span class="code">Chunk</span> as a <span class="code">Command</span>.  Blocks of text
are minor commands, as well as the <tt>@&lt;<i>name</i>@&gt;</tt> references, 
the various cross-reference commands (<tt>@f</tt>, <tt>@m</tt> and <tt>@u</tt>).  
The <tt>@@</tt> escape is also
handled here so that all further processing is independent of any parsing.
</p>

<h4>Implementation</h4>

<p>The class has the following attributes:</p>
<ul>
<li><i>fileName</i> is used to pass the file name to the Web instance.</li>
<li><i>tokenList</i> is the completely tokenized input file.</li>
<li><i>token</i> is the most recently examined token.</li>
<li><i>tokenIndex</i> is an index through the tokenList.</li>
<li><i>lineNumber</i> is the count of <tt>'\n'</tt> characters seen in the tokens.</li>
<li><i>aChunk</i> is the current open Chunk.</li>
<li><i>parent</i> is the outer <span class="code">WebReader</span> when processing a <tt>@i</tt> command.</li>
<li><i>theWeb</i> is the current open Web.</li>
<li><i>permitList</i> is the list of commands that are permitted to fail.  This
is generally an empty list or <tt>('@i',)</tt>.</li>
<li><i>command</i> is the command character; a WebReader will use the parent
command character if the parent is not <tt>None</tt>.
<li><i>parsePat</i> is generated from the command character, and is used to parse
the input into tokens.</li>
</ul>


    <a name="pyweb112"></a>
    <!--line number 3042-->
    <p><em>WebReader class - parses the input file, building the Web structure</em> (112)&nbsp;=</p>
    <code><pre>

class WebReader( object ):
    &quot;&quot;&quot;Parse an input file, creating Commands and Chunks.&quot;&quot;&quot;
    def __init__( self, parent=None, command='@', permit=None ):
        # Configuration of this reader.
        self._source= None
        self.fileName= None
        self.parent= parent
        self.theWeb= None
        if self.parent: 
            self.command= self.parent.command
            self.permitList= self.parent.permitList
        else:
            self.command= command
            self.permitList= [] if permit is None else permit
            
        self.log_reader= logging.getLogger( &quot;pyweb.%s&quot; % self.__class__.__name__ )

        # State of reading and parsing.
        self.tokenList= []
        self.token= &quot;&quot;
        self.tokenIndex= 0
        self.tokenPushback= []
        self.lineNumber= 0
        self.aChunk= None
        self.totalLines= 0
        self.totalFiles= 0
        self.parsePat= '(%s.)' % self.command
        <a href="#pyweb130">&rarr;<em>WebReader command literals</em> (130)</a>
    def __str__( self ):
        return self.__class__.__name__
    <a href="#pyweb113">&rarr;<em>WebReader fluent property-like methods</em> (113)</a>
    <a href="#pyweb114">&rarr;<em>WebReader tokenize the input</em> (114)</a>
    <a href="#pyweb115">&rarr;<em>WebReader location in the input stream</em> (115)</a>
    <a href="#pyweb116">&rarr;<em>WebReader handle a command string</em> (116)</a>
    <a href="#pyweb128">&rarr;<em>WebReader load the web</em> (128)</a>

    </pre></code>
    <p>&loz; <em>WebReader class - parses the input file, building the Web structure</em> (112).
      Used by <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>A few fluent property-like methods help set the attributes of a WebReader.</p>


    <a name="pyweb113"></a>
    <!--line number 3083-->
    <p><em>WebReader fluent property-like methods</em> (113)&nbsp;=</p>
    <code><pre>

def web( self, aWeb ):
    self.theWeb= aWeb
    return self
def source( self, name, source=None ):
    &quot;&quot;&quot;Set a name to display with error messages; also set the actual file-like source.
    if no source is given, the name is treated as a filename and opened.
    &quot;&quot;&quot;
    self.fileName= name
    self._source= source
    return self

    </pre></code>
    <p>&loz; <em>WebReader fluent property-like methods</em> (113).
      Used by <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>

<p>This tokenizer centralizes a single call to <span class="code">nextToken()</span>.  This assures that
every token is examined by <span class="code">nextToken()</span>, which permits accurate 
counting of the <tt>'\n'</tt> characters
and determining the line numbers of the input file.  This line number
information can then be attached to each <span class="code">Command</span>, directing the user back to 
the correct line of the original input file.
</p>
<p>The tokenizer supports lookahead by allowing the parser to examine tokens
and then push them back into a pushBack stack.  Generally this is used for the
special case of parsing the @i command, which has no @-command terminator or
separator.  It ends with the following <tt>'\n'</tt>.
</p>
<p>Python permits a simplified double-ended queue for this kind
of token stream processing.  Ordinary tokens are fetched with a <tt>pop(0)</tt>, and
a pushback is done by prepending the pushback token with a <tt>tokenList = [ token ] + tokenList</tt>.
For this application, however, we need to keep a count of <tt>'\n'</tt>s seen, 
and we want to avoid double-counting <tt>'\n'</tt> pushed back into the token stream.
So we use a queue of tokens and a stack for pushback.
</p>


    <a name="pyweb114"></a>
    <!--line number 3116-->
    <p><em>WebReader tokenize the input</em> (114)&nbsp;=</p>
    <code><pre>

def openSource( self ):
    if self._source is None:
        self._source= open( self.fileName, &quot;r&quot; )
    text= self._source.read()
    self.tokenList= re.split(self.parsePat, text )
    self.lineNumber= 1
    self.totalLines= 0
    self.totalFiles += 1
    self.tokenPushback= []
def nextToken( self ):
    lines=  self.token.count('\n')
    self.lineNumber += lines
    self.totalLines += lines
    if self.tokenPushback:
        self.token= self.tokenPushback.pop()
    else:
        self.token= self.tokenList.pop(0)
    return self.token
def moreTokens( self ):
    return self.tokenList or self.tokenPushback
def pushBack( self, token ):
    self.tokenPushback.append( token )

    </pre></code>
    <p>&loz; <em>WebReader tokenize the input</em> (114).
      Used by <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">location()</span> provides the file name and 
range of lines for a particular command.  This allows error
messages as well as tangled or woven output 
to correctly reference the original input files.
</p>


    <a name="pyweb115"></a>
    <!--line number 3149-->
    <p><em>WebReader location in the input stream</em> (115)&nbsp;=</p>
    <code><pre>

def location( self ):
    return ( self.fileName, self.lineNumber, self.lineNumber+self.token.count(&quot;\n&quot;) )

    </pre></code>
    <p>&loz; <em>WebReader location in the input stream</em> (115).
      Used by <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>Command recognition is done via a <i>Chain of Command</i>-like design.
There are two conditions: the command string is recognized or it is not recognized.</p>
<p>If the command is recognized, <span class="code">handleCommand()</span> either:</p>
<ul>
<li>(for major commands) attaches the current <span class="code">Chunk</span> (<i>self.aChunk</i>) to the 
current <span class="code">Web</span> (<i>self.aWeb</i>), <em>or</em></li>
<li>(for minor commands) create a <span class="code">Command</span>, attach it to the current 
<span class="code">Chunk</span> (<i>self.aChunk</i>)</li>
</ul>
<p><em>and</em> returns a true result.</p>
<p>If the command is not recognized, <span class="code">handleCommand()</span> returns false.</p>
<p>
A subclass can override <span class="code">handleCommand()</span> to (1) call this superclass version;
(2) if the command is unknown to the superclass, 
then the subclass can attempt to process it;
(3) if the command is unknown to both classes, 
then return false.  Either a subclass will handle it, or the default activity taken
by <span class="code">load()</span> is to treat the command a text, but also issue a warning.
</p>


    <a name="pyweb116"></a>
    <!--line number 3176-->
    <p><em>WebReader handle a command string</em> (116)&nbsp;=</p>
    <code><pre>

def handleCommand( self, token ):
    self.log_reader.debug( &quot;Reading %r&quot;, token )
    <a href="#pyweb117">&rarr;<em>major commands segment the input into separate Chunks</em> (117)</a>
    <a href="#pyweb123">&rarr;<em>minor commands add Commands to the current Chunk</em> (123)</a>
    elif token[:2] in (self.cmdlcurl,self.cmdlbrak):
        # These should be consumed as part of @o and @d parsing
        raise Error('Extra %r (possibly missing chunk name)' % token, self.aChunk)
    else:
        return None # did not recogize the command
    return True # did recognize the command

    </pre></code>
    <p>&loz; <em>WebReader handle a command string</em> (116).
      Used by <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The following sequence of <span class="code">if</span>-<span class="code">elif</span> statements identifies
the major commands that partition the input into separate <span class="code">Chunks</span>.
</p>

    <a name="pyweb117"></a>
    <!--line number 3194-->
    <p><em>major commands segment the input into separate Chunks</em> (117)&nbsp;=</p>
    <code><pre>

if token[:2] == self.cmdo:
    <a href="#pyweb119">&rarr;<em>start an OutputChunk, adding it to the web</em> (119)</a>
elif token[:2] == self.cmdd:
    <a href="#pyweb120">&rarr;<em>start a NamedChunk or NamedDocumentChunk, adding it to the web</em> (120)</a>
elif token[:2] == self.cmdi:
    <a href="#pyweb121">&rarr;<em>import another file</em> (121)</a>
elif token[:2] in (self.cmdrcurl,self.cmdrbrak):
    <a href="#pyweb122">&rarr;<em>finish a chunk, start a new Chunk adding it to the web</em> (122)</a>

    </pre></code>
    <p>&loz; <em>major commands segment the input into separate Chunks</em> (117).
      Used by <a href="#pyweb116"><em>WebReader handle a command string</em>&nbsp;(116)</a>; <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>An output chunk has the form <tt>@o <i>name</i> @{ <i>content</i> @}</tt>.
We use the first two tokens to name the <span class="code">OutputChunk</span>.  We simply expect
the <tt>@{</tt> separator.  We then attach all subsequent commands
to this chunk while waiting for the final <tt>@}</tt> token to end the chunk.
</p>

<p><b>TODO</b> The file name information can be split into parts on a <tt>' '</tt>.
We can add escaping (<tt>'\ '</tt>) and quoting to allow more flexibility.
If there's one part, it's the file name.  If there is more than one part, it
will provide comment characters.  The <span class="code">shlex</span> module
will handle the parsing into quoted fields.
</p>


    <a name="pyweb118"></a>
    <!--line number 3219-->
    <p><em>Imports</em> (118)&nbsp;+=</p>
    <code><pre>
import shlex

    </pre></code>
    <p>&loz; <em>Imports</em> (118).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb119"></a>
    <!--line number 3224-->
    <p><em>start an OutputChunk, adding it to the web</em> (119)&nbsp;=</p>
    <code><pre>

args= self.nextToken().strip()
values = shlex.split( args )
if len(values) == 1:
    self.aChunk= OutputChunk( values[0], &quot;&quot;, &quot;&quot; )
elif len(values) == 2:
    self.aChunk= OutputChunk( values[0], values[1], &quot;&quot; )
else:
    self.aChunk= OutputChunk( values[0], values[1], values[2] )
self.aChunk.webAdd( self.theWeb )
self.expect( (self.cmdlcurl,) )
# capture an OutputChunk up to @}

    </pre></code>
    <p>&loz; <em>start an OutputChunk, adding it to the web</em> (119).
      Used by <a href="#pyweb117"><em>major commands segment the input into separate Chunks</em>&nbsp;(117)</a>; <a href="#pyweb116"><em>WebReader handle a command string</em>&nbsp;(116)</a>; <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>An named chunk has the form <tt>@d <i>name</i> @{ <i>content</i> @}</tt> for
code and <tt>@d <i>name</i> @[ <i>content</i> @]</tt> for document source.
We use the first two tokens to name the <span class="code">NamedChunk</span> or <span class="code">NamedDocumentChunk</span>.  
We expect either the <tt>@{</tt> or <tt>@[</tt> separator, and use the actual
token found to choose which subclass of <span class="code">Chunk</span> to create.
We then attach all subsequent commands
to this chunk while waiting for the final <tt>@}</tt> or <tt>@]</tt> token to 
end the chunk.
</p>


    <a name="pyweb120"></a>
    <!--line number 3249-->
    <p><em>start a NamedChunk or NamedDocumentChunk, adding it to the web</em> (120)&nbsp;=</p>
    <code><pre>

name= self.nextToken().strip()
# next token is @{ or @[
brack= self.expect( (self.cmdlcurl,self.cmdlbrak) )
if brack == self.cmdlcurl: 
    self.aChunk= NamedChunk( name )
else: 
    self.aChunk= NamedDocumentChunk( name )
self.aChunk.webAdd( self.theWeb )
# capture a NamedChunk up to @} or @]

    </pre></code>
    <p>&loz; <em>start a NamedChunk or NamedDocumentChunk, adding it to the web</em> (120).
      Used by <a href="#pyweb117"><em>major commands segment the input into separate Chunks</em>&nbsp;(117)</a>; <a href="#pyweb116"><em>WebReader handle a command string</em>&nbsp;(116)</a>; <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>An import command has the unusual form of <tt>@i <i>name</i></tt>, with no trailing
separator.  When we encounter the <tt>@i</tt> token, the next token will start with the
file name, but may continue with an anonymous chunk.  We require that all <tt>@i</tt> commands
occur at the end of a line, and break on the <tt>'\n'</tt> which must occur after the file name.
This permits file names with embedded spaces.
</p>
<p>Once we have split the file name away from the rest of the following anonymous chunk,
we push the following token back into the token stream, so that it will be the 
first token examined at the top of the <span class="code">load()</span> loop.
</p>
<p>We create a child <span class="code">WebReader</span> instance to process the included file.  The entire file 
is loaded into the current <span class="code">Web</span> instance.  A new, empty <span class="code">Chunk</span> is created at the end
of the file so that processing can resume with an anonymous <span class="code">Chunk</span>.
</p>


    <a name="pyweb121"></a>
    <!--line number 3277-->
    <p><em>import another file</em> (121)&nbsp;=</p>
    <code><pre>

# break this token on the '\n' and pushback the new token.
next= self.nextToken().split('\n',1)
self.pushBack('\n')
if len(next) &gt; 1:
    self.pushBack( '\n'.join(next[1:]) )
incFile= next[0].strip()
try:
    with open(incFile,&quot;r&quot;) as source:
        logger.info( &quot;Including %r&quot;, incFile )
        include= WebReader( parent=self )
        include.source( incFile, source ).web( self.theWeb )
        include.load()
    self.totalLines += include.totalLines
    self.totalFiles += include.totalFiles
except (Error,IOError),e:
    logger.error( 
        &quot;Problems with included file %s, output is incomplete.&quot;,
        incFile )
    # Discretionary - sometimes we want total failure
    if self.cmdi in self.permitList: pass
    else: raise
self.aChunk= Chunk()
self.aChunk.webAdd( self.theWeb )

    </pre></code>
    <p>&loz; <em>import another file</em> (121).
      Used by <a href="#pyweb117"><em>major commands segment the input into separate Chunks</em>&nbsp;(117)</a>; <a href="#pyweb116"><em>WebReader handle a command string</em>&nbsp;(116)</a>; <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>When a <tt>@}</tt> or <tt>@]</tt> are found, this finishes a named chunk.  The next
text is therefore part of an anonymous chunk.
</p>
<p>Note that no check is made to assure that the previous <span class="code">Chunk</span> was indeed a named
chunk or output chunk started with <tt>@{</tt> or <tt>@[</tt>.  
To do this, an attribute would be
needed for each <span class="code">Chunk</span> subclass that indicated if a trailing bracket was necessary.
For the base <span class="code">Chunk</span> class, this would be false, but for all other subclasses of
<span class="code">Chunk</span>, this would be true.
</p>


    <a name="pyweb122"></a>
    <!--line number 3315-->
    <p><em>finish a chunk, start a new Chunk adding it to the web</em> (122)&nbsp;=</p>
    <code><pre>

self.aChunk= Chunk()
self.aChunk.webAdd( self.theWeb )

    </pre></code>
    <p>&loz; <em>finish a chunk, start a new Chunk adding it to the web</em> (122).
      Used by <a href="#pyweb117"><em>major commands segment the input into separate Chunks</em>&nbsp;(117)</a>; <a href="#pyweb116"><em>WebReader handle a command string</em>&nbsp;(116)</a>; <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The following sequence of <span class="code">elif</span> statements identifies
the minor commands that add <span class="code">Command</span> instances to the current open <span class="code">Chunk</span>. 
</p>


    <a name="pyweb123"></a>
    <!--line number 3325-->
    <p><em>minor commands add Commands to the current Chunk</em> (123)&nbsp;=</p>
    <code><pre>

elif token[:2] == self.cmdpipe:
    <a href="#pyweb124">&rarr;<em>assign user identifiers to the current chunk</em> (124)</a>
elif token[:2] == self.cmdf:
    self.aChunk.append( FileXrefCommand(self.lineNumber) )
elif token[:2] == self.cmdm:
    self.aChunk.append( MacroXrefCommand(self.lineNumber) )
elif token[:2] == self.cmdu:
    self.aChunk.append( UserIdXrefCommand(self.lineNumber) )
elif token[:2] == self.cmdlangl:
    <a href="#pyweb125">&rarr;<em>add a reference command to the current chunk</em> (125)</a>
elif token[:2] == self.cmdlexpr:
    <a href="#pyweb126">&rarr;<em>add an expression command to the current chunk</em> (126)</a>
elif token[:2] == self.cmdcmd:
    <a href="#pyweb127">&rarr;<em>double at-sign replacement, append this character to previous TextCommand</em> (127)</a>

    </pre></code>
    <p>&loz; <em>minor commands add Commands to the current Chunk</em> (123).
      Used by <a href="#pyweb116"><em>WebReader handle a command string</em>&nbsp;(116)</a>; <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>User identifiers occur after a <tt>@|</tt> in a <span class="code">NamedChunk</span>.
<p>Note that no check is made to assure that the previous <span class="code">Chunk</span> was indeed a named
chunk or output chunk started with <tt>@{</tt>.  
To do this, an attribute would be
needed for each <span class="code">Chunk</span> subclass that indicated if user identifiers are permitted.
For the base <span class="code">Chunk</span> class, this would be false, but for the <span class="code">NamedChunk</span> class and
<span class="code">OutputChunk</span> class, this would be true.
</p>


    <a name="pyweb124"></a>
    <!--line number 3352-->
    <p><em>assign user identifiers to the current chunk</em> (124)&nbsp;=</p>
    <code><pre>

# variable references at the end of a NamedChunk
# aChunk must be subclass of NamedChunk
# These are accumulated and expanded by @u reference
try:
    self.aChunk.setUserIDRefs( self.nextToken().strip() )
except AttributeError:
    # Out of place user identifier command
    raise Error(&quot;Unexpected references near %s: %s&quot; % (self.location(),token) )

    </pre></code>
    <p>&loz; <em>assign user identifiers to the current chunk</em> (124).
      Used by <a href="#pyweb123"><em>minor commands add Commands to the current Chunk</em>&nbsp;(123)</a>; <a href="#pyweb116"><em>WebReader handle a command string</em>&nbsp;(116)</a>; <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>A reference command has the form <tt>@< <i>name</i> @></tt>.  We accept three
tokens from the input, the middle token is the referenced name.
</p>


    <a name="pyweb125"></a>
    <!--line number 3368-->
    <p><em>add a reference command to the current chunk</em> (125)&nbsp;=</p>
    <code><pre>

# get the name, introduce into the named Chunk dictionary
expand= self.nextToken().strip()
self.expect( (self.cmdrangl,) )
self.theWeb.addDefName( expand )
self.aChunk.append( ReferenceCommand( expand, self.lineNumber ) )
self.aChunk.appendText( &quot;&quot;, self.lineNumber ) # to collect following text
self.log_reader.debug( &quot;Reading %r %r&quot;, expand, self.token )

    </pre></code>
    <p>&loz; <em>add a reference command to the current chunk</em> (125).
      Used by <a href="#pyweb123"><em>minor commands add Commands to the current Chunk</em>&nbsp;(123)</a>; <a href="#pyweb116"><em>WebReader handle a command string</em>&nbsp;(116)</a>; <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>An expression command has the form <tt>@( <i>Python Expression</i> @)</tt>.  
We accept three
tokens from the input, the middle token is the expression.
</p>
<p>There are two alternative semantics for an embedded expression.</p>
<ul>
<li>Deferred Execution.  This requires definition of a new subclass of <span class="code">Command</span>, 
<span class="code">ExpressionCommand</span>, and appends it into the current <span class="code">Chunk</span>.  At weave and
tangle time, this expression is evaluated.  The insert might look something like this:
<tt>aChunk.append( ExpressionCommand( expression, self.lineNumber ) )</tt>.
</li>
<li>Immediate Execution.  This simply creates a context and evaluates
the Python expression.  The output from the expression becomes a TextCommand, and
is append to the current <span class="code">Chunk</span>.</li>
</ul>
<p>We use the Immediate Execution semantics.</p>


    <a name="pyweb126"></a>
    <!--line number 3396-->
    <p><em>add an expression command to the current chunk</em> (126)&nbsp;=</p>
    <code><pre>

# get the Python expression, create the expression command
expression= self.nextToken()
self.expect( (self.cmdrexpr,) )
try:
    theLocation= self.location()
    theWebReader= self
    theFile= self.theWeb.webFileName
    thisApplication= sys.argv[0]
    result= str(eval( expression ))
except Exception,e:
    result= '!!!Exception: %s' % e
    logger.exception( 'Failure to process %r: result is %s', expression, e )
self.aChunk.appendText( result, self.lineNumber )

    </pre></code>
    <p>&loz; <em>add an expression command to the current chunk</em> (126).
      Used by <a href="#pyweb123"><em>minor commands add Commands to the current Chunk</em>&nbsp;(123)</a>; <a href="#pyweb116"><em>WebReader handle a command string</em>&nbsp;(116)</a>; <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>A double command sequence (<tt>'@@'</tt>, when the command is an <tt>'@'</tt>) has the
usual meaning of <tt>'@'</tt> in the input stream.  We do this via 
the <span class="code">appendText()</span> method of the current <span class="code">Chunk</span>.  This will append the 
character on the end of the most recent <span class="code">TextCommand</span>; if this fails, it will
create a new, empty <span class="code">TextCommand</span>.
</p>

    <a name="pyweb127"></a>
    <!--line number 3419-->
    <p><em>double at-sign replacement, append this character to previous TextCommand</em> (127)&nbsp;=</p>
    <code><pre>

# replace with '@' here and now!
# Put this at the end of the previous chunk
# AND make sure the next chunk is appended to this.
self.aChunk.appendText( self.command, self.lineNumber )

    </pre></code>
    <p>&loz; <em>double at-sign replacement, append this character to previous TextCommand</em> (127).
      Used by <a href="#pyweb123"><em>minor commands add Commands to the current Chunk</em>&nbsp;(123)</a>; <a href="#pyweb116"><em>WebReader handle a command string</em>&nbsp;(116)</a>; <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">expect()</span> method examines the 
next token to see if it is the expected string.  If this is not found, a
standard type of error message is written.
</p>
<p>The <span class="code">load()</span> method reads the entire input file as a sequence
of tokens, split up by the <span class="code">openSource()</span> method.  Each token that appears
to be a command is passed to the <span class="code">handleCommand()</span> method.  If
the <span class="code">handleCommand()</span> method returns a true result, the command was recognized
and placed in the <span class="code">Web</span>.  if <i>handleCommand()</i> returns a false result, the command
was unknown, and some default behavior is used.
</p>
<p>The <span class="code">load()</span> method takes an optional <tt>permit</tt> variable.
This encodes commands where failure is permitted.  Currently, only the @i command
can be set to permit failure.  This allows including a file that does not yet 
exist.  The primary application of this option is when weaving test output.
The first pass of <em>pyWeb</em> tangles the program source files; they are
then run to create test output; the second pass of <em>pyWeb</em> weaves this
test output into the final document via the @i command.
</p>


    <a name="pyweb128"></a>
    <!--line number 3447-->
    <p><em>WebReader load the web</em> (128)&nbsp;=</p>
    <code><pre>

def expect( self, tokens ):
    if not self.moreTokens():
        raise Error(&quot;At %r: end of input, %r not found&quot; % (self.location(),tokens) )
    t= self.nextToken()
    if t not in tokens:
        raise Error(&quot;At %r: expected %r, found %r&quot; % (self.location(),tokens,t) )
    return t
    
def load( self ):
    self.aChunk= Chunk() # Initial anonymous chunk of text.
    self.aChunk.webAdd( self.theWeb )
    self.openSource()
    while self.moreTokens():
        token= self.nextToken()
        if len(token) &gt;= 2 and token.startswith(self.command):
            if self.handleCommand( token ):
                continue
            else:
                <a href="#pyweb129">&rarr;<em>other command-like sequences are appended as a TextCommand</em> (129)</a>
        elif token:
            # accumulate non-empty block of text in the current chunk
            self.aChunk.appendText( token, self.lineNumber )

    </pre></code>
    <p>&loz; <em>WebReader load the web</em> (128).
      Used by <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb129"></a>
    <!--line number 3474-->
    <p><em>other command-like sequences are appended as a TextCommand</em> (129)&nbsp;=</p>
    <code><pre>

logger.warn( 'Unknown @-command in input: %r', token )
self.aChunk.appendText( token, self.lineNumber )

    </pre></code>
    <p>&loz; <em>other command-like sequences are appended as a TextCommand</em> (129).
      Used by <a href="#pyweb128"><em>WebReader load the web</em>&nbsp;(128)</a>; <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



<p>The command character can be changed to permit
some flexibility when working with languages that make extensive
use of the <tt>@</tt> symbol, <em>i.e.</em>, PERL.
The initialization of the <span class="code">WebReader</span> is based on the selected 
command character.
</p>


    <a name="pyweb130"></a>
    <!--line number 3488-->
    <p><em>WebReader command literals</em> (130)&nbsp;=</p>
    <code><pre>

# major commands
self.cmdo= self.command+'o'
self.cmdd= self.command+'d'
self.cmdlcurl= self.command+'{'
self.cmdrcurl= self.command+'}'
self.cmdlbrak= self.command+'['
self.cmdrbrak= self.command+']'
self.cmdi= self.command+'i'
# minor commands
self.cmdlangl= self.command+'&lt;'
self.cmdrangl= self.command+'&gt;'
self.cmdpipe= self.command+'|'
self.cmdlexpr= self.command+'('
self.cmdrexpr= self.command+')'
self.cmdf= self.command+'f'
self.cmdm= self.command+'m'
self.cmdu= self.command+'u'
self.cmdcmd= self.command+self.command

    </pre></code>
    <p>&loz; <em>WebReader command literals</em> (130).
      Used by <a href="#pyweb112"><em>WebReader class - parses the input file, building the Web structure</em>&nbsp;(112)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h3>Action Class Hierarchy</h3>
<p>This application performs three major actions: loading the document web, 
weaving and tangling.  Generally,
the use case is to perform a load, weave and tangle.  However, a less common use case
is to first load and tangle output files, run a regression test and then 
load and weave a result that includes the test output file.
</p>
<p>The <tt>-x</tt> option excludes one of the two output actions.  The <tt>-xw</tt> 
excludes the weave pass, doing only the tangle action.  The <tt>-xt</tt> excludes
the tangle pass, doing the weave action.
</p>
<p>This two pass action might be embedded in the following type of Python program.</p>
<pre>
import pyweb, os
pyweb.tangle( "source.w" )
os.system( "python source.py >source.log" )
pyweb.weave( "source.w" )
</pre>
<p>The first step runs <em>pyWeb</em>, excluding the final weaving pass.  The second
step runs the tangled program, <tt>source.py</tt>, and produces test results in
a log file, <tt>source.log</tt>.  The third step runs <em>pyWeb</em> excluding the
tangle pass.  This produces a final document that includes the <tt>source.log</tt> 
test results.
</p>
<p>To accomplish this, we provide a class hierarchy that defines the various
actions of the <em>pyWeb</em> application.  This class hierarchy defines an extensible set of 
fundamental actions.  This gives us the flexibility to create a simple sequence
of actions and execute any combination of these.  It eliminates the need for a 
forest of <tt>if</tt>-statements to determine precisely what will be done.
</p>
<p>Each action has the potential to update the state of the overall
application.   A partner with this command hierarchy is the Application class
that defines the application options, inputs and results.</p> 


    <a name="pyweb131"></a>
    <!--line number 3544-->
    <p><em>Action class hierarchy - used to describe basic actions of the application</em> (131)&nbsp;=</p>
    <code><pre>

<a href="#pyweb132">&rarr;<em>Action superclass has common features of all actions</em> (132)</a>
<a href="#pyweb135">&rarr;<em>ActionSequence subclass that holds a sequence of other actions</em> (135)</a>
<a href="#pyweb139">&rarr;<em>WeaveAction subclass initiates the weave action</em> (139)</a>
<a href="#pyweb142">&rarr;<em>TangleAction subclass initiates the tangle action</em> (142)</a>
<a href="#pyweb145">&rarr;<em>LoadAction subclass loads the document web</em> (145)</a>

    </pre></code>
    <p>&loz; <em>Action class hierarchy - used to describe basic actions of the application</em> (131).
      Used by <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>Action Class</h4>
<p>The <span class="code">Action</span> class embodies the basic operations of <em>pyWeb</em>.
The intent of this hierarchy is to both provide an easily expanded method of
adding new actions, but an easily specified list of actions for a particular
run of <em>pyWeb</em>.

<h5>Usage</h5>
<p>The overall process of the application is defined by an instance of <span class="code">Action</span>.
This instance may be the <span class="code">WeaveAction</span> instance, the <span class="code">TangleAction</span> instance
or a <span class="code">ActionSequence</span> instance.
</p>
<p>The instance is constructed during parsing of the input parameters.  Then the 
<span class="code">Action</span> class <span class="code">perform()</span> method is called to actually perform the
action.  There are three standard <span class="code">Action</span> instances available: an instance
that is a macro and does both tangling and weaving, an instance that excludes tangling,
and an instance that excludes weaving.  These correspond to the command-line options.
</p>
<pre>
anOp= SomeAction( <i>parameters</i> )
anOp.options= <i>parsed options</i>
anOp.web = <i>Current web</i>
anOp()
</pre>

<h5>Design</h5>
<p>The <span class="code">Action</span> is the superclass for all actions.</p>
<p>An <span class="code">Action</span> has a number of common attributes.</p>
<ul>
<li><span class="code">name</span> A name for this action.</li>
<li><span class="code">Options</span> The <span class="code">optparse</span> options object.</li>
<li><span class="code">web</span> The current web that's being processed.</li>
<li><span class="code">start</span> The time at which the action started.</li>
</ul>

<h5>Implementation</h5>


    <a name="pyweb132"></a>
    <!--line number 3589-->
    <p><em>Action superclass has common features of all actions</em> (132)&nbsp;=</p>
    <code><pre>

class Action( object ):
    &quot;&quot;&quot;An action performed by pyWeb.&quot;&quot;&quot;
    def __init__( self, name ):
        self.name= name
        self.web= None
        self.start= None
    def __str__( self ):
        return &quot;%s [%s]&quot; % ( self.name, self.web )
    <a href="#pyweb133">&rarr;<em>Action call method actually performs the action</em> (133)</a>
    <a href="#pyweb134">&rarr;<em>Action final summary method</em> (134)</a>

    </pre></code>
    <p>&loz; <em>Action superclass has common features of all actions</em> (132).
      Used by <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">__call__()</span> method does the real work of the action.
For the superclass, it merely logs a message.  This is overridden 
by a subclass.</p>

    <a name="pyweb133"></a>
    <!--line number 3607-->
    <p><em>Action call method actually performs the action</em> (133)&nbsp;=</p>
    <code><pre>

def __call__( self ):
    logger.info( &quot;Starting %s&quot;, self )
    self.start= time.clock()

    </pre></code>
    <p>&loz; <em>Action call method actually performs the action</em> (133).
      Used by <a href="#pyweb132"><em>Action superclass has common features of all actions</em>&nbsp;(132)</a>; <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">summary()</span> method returns some basic processing
statistics for this action.
</p>

    <a name="pyweb134"></a>
    <!--line number 3617-->
    <p><em>Action final summary method</em> (134)&nbsp;=</p>
    <code><pre>

def duration( self ):
    &quot;&quot;&quot;Return duration of the action.&quot;&quot;&quot;
    return (self.start and time.clock()-self.start) or 0
def summary( self, *args ):
    return &quot;%s in %0.1f sec.&quot; % ( self.name, self.duration() )

    </pre></code>
    <p>&loz; <em>Action final summary method</em> (134).
      Used by <a href="#pyweb132"><em>Action superclass has common features of all actions</em>&nbsp;(132)</a>; <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>ActionSequence Class</h4>
<p>A <span class="code">ActionSequence</span> defines a composite action; it is a sequence of
other actions.  When the macro is performed, it delegates to the 
sub-actions.</p>

<h5>Usage</h5>
<p>The instance is created during parsing of input parameters.  An instance of
this class is one of
the three standard actions available; it generally is the default, "do everything" 
action.</p>

<h5>Design</h5>
<p>This class overrides the <span class="code">perform()</span> method of the superclass.  It also adds
an <span class="code">append()</span> method that is used to construct the sequence of actions.
</p>
<h5>Implementation</h5>


    <a name="pyweb135"></a>
    <!--line number 3644-->
    <p><em>ActionSequence subclass that holds a sequence of other actions</em> (135)&nbsp;=</p>
    <code><pre>

class ActionSequence( Action ):
    &quot;&quot;&quot;An action composed of a sequence of other actions.&quot;&quot;&quot;
    def __init__( self, name, opSequence=None ):
        super( ActionSequence, self ).__init__( name )
        if opSequence: self.opSequence= opSequence
        else: self.opSequence= []
    def __str__( self ):
        return &quot;; &quot;.join( [ str(x) for x in self.opSequence ] )
    <a href="#pyweb136">&rarr;<em>ActionSequence call method delegates the sequence of ations</em> (136)</a>
    <a href="#pyweb137">&rarr;<em>ActionSequence append adds a new action to the sequence</em> (137)</a>
    <a href="#pyweb138">&rarr;<em>ActionSequence summary summarizes each step</em> (138)</a>

    </pre></code>
    <p>&loz; <em>ActionSequence subclass that holds a sequence of other actions</em> (135).
      Used by <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>Since the macro <span class="code">__call__()</span> method delegates to other Actions,
it is possible to short-cut argument processing by using the Python
<tt>*args</tt> construct to accept all arguments and pass them to each
sub-action.</p>


    <a name="pyweb136"></a>
    <!--line number 3665-->
    <p><em>ActionSequence call method delegates the sequence of ations</em> (136)&nbsp;=</p>
    <code><pre>

def __call__( self ):
    for o in self.opSequence:
        o.web= self.web
        o()

    </pre></code>
    <p>&loz; <em>ActionSequence call method delegates the sequence of ations</em> (136).
      Used by <a href="#pyweb135"><em>ActionSequence subclass that holds a sequence of other actions</em>&nbsp;(135)</a>; <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>Since this class is essentially a wrapper around the built-in sequence type, 
we delegate sequence related actions directly to the underlying sequence.</p>


    <a name="pyweb137"></a>
    <!--line number 3676-->
    <p><em>ActionSequence append adds a new action to the sequence</em> (137)&nbsp;=</p>
    <code><pre>

def append( self, anAction ):
    self.opSequence.append( anAction )

    </pre></code>
    <p>&loz; <em>ActionSequence append adds a new action to the sequence</em> (137).
      Used by <a href="#pyweb135"><em>ActionSequence subclass that holds a sequence of other actions</em>&nbsp;(135)</a>; <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">summary()</span> method returns some basic processing
statistics for each step of this action.
</p>

    <a name="pyweb138"></a>
    <!--line number 3685-->
    <p><em>ActionSequence summary summarizes each step</em> (138)&nbsp;=</p>
    <code><pre>

def summary( self, *args ):
    return &quot;, &quot;.join( [ x.summary(*args) for x in self.opSequence ] )

    </pre></code>
    <p>&loz; <em>ActionSequence summary summarizes each step</em> (138).
      Used by <a href="#pyweb135"><em>ActionSequence subclass that holds a sequence of other actions</em>&nbsp;(135)</a>; <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>WeaveAction Class</h4>
<p>The <span class="code">WeaveAction</span> defines the action of weaving.  This action
logs a message, and invokes the <span class="code">weave()</span> method of the <span class="code">Web</span> instance.
This method also includes the basic decision on which weaver to use.  If a <span class="code">Weaver</span> was
specified on the command line, this instance is used.  Otherwise, the first few characters
are examined and a weaver is selected.
</p>

<h5>Usage</h5>
<p>An instance is created during parsing of input parameters.  The instance of this 
class is one of
the standard actions available; it is the "exclude tangling" option and it is
also an element of the "do everything" macro.</p>

<h5>Design</h5>
<p>This class overrides the <span class="code">perform()</span> method of the superclass.
</p>
<h5>Implementation</h5>


    <a name="pyweb139"></a>
    <!--line number 3710-->
    <p><em>WeaveAction subclass initiates the weave action</em> (139)&nbsp;=</p>
    <code><pre>

class WeaveAction( Action ):
    &quot;&quot;&quot;An action that weaves a document.&quot;&quot;&quot;
    def __init__( self ):
        super(WeaveAction, self).__init__( &quot;Weave&quot; )
        self.theWeaver= None
    def __str__( self ):
        return &quot;%s [%s, %s]&quot; % ( self.name, self.web, self.theWeaver )

    <a href="#pyweb140">&rarr;<em>WeaveAction call method does weaving of the document file</em> (140)</a>
    <a href="#pyweb141">&rarr;<em>WeaveAction summary method provides line counts</em> (141)</a>

    </pre></code>
    <p>&loz; <em>WeaveAction subclass initiates the weave action</em> (139).
      Used by <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<a name="pick_language"></a>
<p>The language is picked just prior to weaving.  It is either (1) the language
specified on the command line, or, (2) if no language was specified, a language
is selected based on the first few characters of the input.</p>
<p>Weaving can only raise an exception when there is a reference to a chunk that
is never defined.</p>


    <a name="pyweb140"></a>
    <!--line number 3731-->
    <p><em>WeaveAction call method does weaving of the document file</em> (140)&nbsp;=</p>
    <code><pre>

def __call__( self ):
    super( WeaveAction, self ).__call__()
    if not self.theWeaver: 
        # Examine first few chars of first chunk of web to determine language
        self.theWeaver= self.web.language() 
    try:
        self.web.weave( self.theWeaver )
    except Error,e:
        logger.error(
            &quot;Problems weaving document from %s (weave file is faulty).&quot;,
            self.web.webFileName )
        raise

    </pre></code>
    <p>&loz; <em>WeaveAction call method does weaving of the document file</em> (140).
      Used by <a href="#pyweb139"><em>WeaveAction subclass initiates the weave action</em>&nbsp;(139)</a>; <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">summary()</span> method returns some basic processing
statistics for the weave action.
</p>

    <a name="pyweb141"></a>
    <!--line number 3750-->
    <p><em>WeaveAction summary method provides line counts</em> (141)&nbsp;=</p>
    <code><pre>

def summary( self, *args ):
    if self.theWeaver and self.theWeaver.linesWritten &gt; 0:
        return &quot;%s %d lines in %0.1f sec.&quot; % ( self.name, self.theWeaver.linesWritten, self.duration() )
    return &quot;did not %s&quot; % ( self.name, )

    </pre></code>
    <p>&loz; <em>WeaveAction summary method provides line counts</em> (141).
      Used by <a href="#pyweb139"><em>WeaveAction subclass initiates the weave action</em>&nbsp;(139)</a>; <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>TangleAction Class</h4>
<p>The <span class="code">TangleAction</span> defines the action of tangling.  This operation
logs a message, and invokes the <span class="code">weave()</span> method of the <span class="code">Web</span> instance.
This method also includes the basic decision on which weaver to use.  If a <span class="code">Weaver</span> was
specified on the command line, this instance is used.  Otherwise, the first few characters
are examined and a weaver is selected.
</p>

<h5>Usage</h5>
<p>An instance is created during parsing of input parameters.  The instance of this 
class is one of
the standard actions available; it is the "exclude weaving" option, and it is
also an element of the "do everything" macro.</p>

<h5>Design</h5>
<p>This class overrides the <span class="code">perform()</span> method of the superclass.
</p>
<h5>Implementation</h5>


    <a name="pyweb142"></a>
    <!--line number 3777-->
    <p><em>TangleAction subclass initiates the tangle action</em> (142)&nbsp;=</p>
    <code><pre>

class TangleAction( Action ):
    &quot;&quot;&quot;An action that weaves a document.&quot;&quot;&quot;
    def __init__( self ):
        super( TangleAction, self ).__init__( &quot;Tangle&quot; )
        self.theTangler= None
    <a href="#pyweb143">&rarr;<em>TangleAction call method does tangling of the output files</em> (143)</a>
    <a href="#pyweb144">&rarr;<em>TangleAction summary method provides total lines tangled</em> (144)</a>

    </pre></code>
    <p>&loz; <em>TangleAction subclass initiates the tangle action</em> (142).
      Used by <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>Tangling can only raise an exception when a cross reference request (<tt>@f</tt>, <tt>@m</tt> or <tt>@u</tt>)
occurs in a program code chunk.  Program code chunks are defined 
with any of <tt>@d</tt> or <tt>@o</tt>  and use <tt>@{</tt> <tt>@}</tt> brackets.
</p>


    <a name="pyweb143"></a>
    <!--line number 3793-->
    <p><em>TangleAction call method does tangling of the output files</em> (143)&nbsp;=</p>
    <code><pre>

def __call__( self ):
    super( TangleAction, self ).__call__()
    try:
        self.web.tangle( self.theTangler )
    except Error,e:
        logger.error( 
            &quot;Problems tangling outputs from %s (tangle files are faulty).&quot;,
            self.web.webFileName )
        raise

    </pre></code>
    <p>&loz; <em>TangleAction call method does tangling of the output files</em> (143).
      Used by <a href="#pyweb142"><em>TangleAction subclass initiates the tangle action</em>&nbsp;(142)</a>; <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">summary()</span> method returns some basic processing
statistics for the tangle action.
</p>

    <a name="pyweb144"></a>
    <!--line number 3809-->
    <p><em>TangleAction summary method provides total lines tangled</em> (144)&nbsp;=</p>
    <code><pre>

def summary( self, *args ):
    if self.theTangler and self.theTangler.linesWritten &gt; 0:
        return &quot;%s %d lines in %0.1f sec.&quot; % ( self.name, self.theTangler.linesWritten, self.duration() )
    return &quot;did not %s&quot; % ( self.name, )

    </pre></code>
    <p>&loz; <em>TangleAction summary method provides total lines tangled</em> (144).
      Used by <a href="#pyweb142"><em>TangleAction subclass initiates the tangle action</em>&nbsp;(142)</a>; <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



<h4>LoadAction Class</h4>
<p>The <span class="code">LoadAction</span> defines the action of loading the web structure.  This action
uses the application's <tt>webReader</tt> to actually do the load.
</p>

<h5>Usage</h5>
<p>An instance is created during parsing of the input parameters.  An instance of
this class is part of any of the weave, tangle and "do everything" action.</p>

<h5>Design</h5>
<p>This class overrides the <span class="code">perform()</span> method of the superclass.
</p>
<h5>Implementation</h5>


    <a name="pyweb145"></a>
    <!--line number 3832-->
    <p><em>LoadAction subclass loads the document web</em> (145)&nbsp;=</p>
    <code><pre>

class LoadAction( Action ):
    &quot;&quot;&quot;An action that loads the source web for a document.&quot;&quot;&quot;
    def __init__( self ):
        super( LoadAction, self ).__init__( &quot;Load&quot; )
        self.web= None
        self.webReader= None
    def __str__( self ):
        return &quot;Load [%s, %s]&quot; % ( self.webReader, self.web )
    <a href="#pyweb146">&rarr;<em>LoadAction call method loads the input files</em> (146)</a>
    <a href="#pyweb147">&rarr;<em>LoadAction summary provides lines read</em> (147)</a>

    </pre></code>
    <p>&loz; <em>LoadAction subclass loads the document web</em> (145).
      Used by <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>Trying to load the web involves two steps, either of which can raise 
exceptions due to incorrect inputs.</p>
<ul>
<li>The <span class="code">WebReader</span> class <span class="code">load()</span> method can raise exceptions for a number of 
syntax errors.
    <ul>
    <li>Missing closing brackets (<tt>@}</tt>, @] or <tt>@&gt;</tt>).</li>
    <li>Missing opening bracket (<tt>@{</tt> or <tt>@[</tt>) after a chunk name (<tt>@d</tt> or <tt>@o</tt>).</li>
    <li>Extra brackets (<tt>@{</tt>, <tt>@[</tt>, <tt>@}</tt>, <tt>@]</tt>).</li>
    <li>Extra <tt>@|</tt>.</li>
    <li>The input file does not exist or is not readable.</li>
    </ul></li>
<li>The <span class="code">Web</span> class <span class="code">createUsedBy()</span> method can raise an exception when a 
chunk reference cannot be resolved to a named chunk.</li>
</ul>


    <a name="pyweb146"></a>
    <!--line number 3862-->
    <p><em>LoadAction call method loads the input files</em> (146)&nbsp;=</p>
    <code><pre>

def __call__( self ):
    super( LoadAction, self ).__call__()
    try:
        self.webReader.web(self.web).load()
        self.web.createUsedBy()
    except (Error,IOError),e:
        logger.error(
            &quot;Problems with source file %s, no output produced.&quot;,
            self.web.webFileName )
        raise

    </pre></code>
    <p>&loz; <em>LoadAction call method loads the input files</em> (146).
      Used by <a href="#pyweb145"><em>LoadAction subclass loads the document web</em>&nbsp;(145)</a>; <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">summary()</span> method returns some basic processing
statistics for the load action.
</p>

    <a name="pyweb147"></a>
    <!--line number 3879-->
    <p><em>LoadAction summary provides lines read</em> (147)&nbsp;=</p>
    <code><pre>

def summary( self, *args ):
    return &quot;%s %d lines from %d files in %01.f sec.&quot; % ( 
        self.name, self.webReader.totalLines, 
        self.webReader.totalFiles, self.duration() )

    </pre></code>
    <p>&loz; <em>LoadAction summary provides lines read</em> (147).
      Used by <a href="#pyweb145"><em>LoadAction subclass loads the document web</em>&nbsp;(145)</a>; <a href="#pyweb131"><em>Action class hierarchy - used to describe basic actions of the application</em>&nbsp;(131)</a>; <a href="#pyweb1"><em>Base Class Definitions</em>&nbsp;(1)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



<a name="module"></a><h2>Module Components</h2>

<h3>Globals</h3>
<p>It's convenient for a module, as a whole, to have a master logger.
Individual classes may also have loggers, but it's helpful to have 
a global, default, logger.
</p>


    <a name="pyweb148"></a>
    <!--line number 3897-->
    <p><em>Module Initialization of global variables</em> (148)&nbsp;=</p>
    <code><pre>

import logging
logger= logging.getLogger( &quot;pyweb&quot; )

    </pre></code>
    <p>&loz; <em>Module Initialization of global variables</em> (148).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>Additionally, the global list of weavers will be used by the
Application.
</p>


    <a name="pyweb149"></a>
    <!--line number 3907-->
    <p><em>Module Initialization of global variables</em> (149)&nbsp;+=</p>
    <code><pre>

# Module global list of available weavers.
weavers = {
    'html':  HTML(),
    'htmls': HTMLShort(),
    'latex': LaTeX(),
    'rst': Weaver(), # Generic Weaver produces RST.
}

    </pre></code>
    <p>&loz; <em>Module Initialization of global variables</em> (149).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



<a name="mod"></a><h3><em>pyWeb</em> Module File</h3>

<p>The <em>pyWeb</em> application file is shown below:</p>

<a name="pyweb150"></a>
    <!--line number 3923-->
    <p><tt>pyweb.py</tt> (150)&nbsp;=</p>
    <code><pre>
<a href="#pyweb152">&rarr;<em>Overheads</em> (152)</a><a href="#pyweb153">(153)</a><a href="#pyweb154">(154)</a><a href="#pyweb155">(155)</a>
<a href="#pyweb12">&rarr;<em>Imports</em> (12)</a><a href="#pyweb47">(47)</a><a href="#pyweb118">(118)</a><a href="#pyweb151">(151)</a><a href="#pyweb156">(156)</a>
<a href="#pyweb1">&rarr;<em>Base Class Definitions</em> (1)</a>
<a href="#pyweb157">&rarr;<em>Application Class</em> (157)</a>
<a href="#pyweb148">&rarr;<em>Module Initialization of global variables</em> (148)</a><a href="#pyweb149">(149)</a>
<a href="#pyweb161">&rarr;<em>Interface Functions</em> (161)</a>
</pre></code>
    <p>&loz; <tt>pyweb.py</tt> (150).
    
    </p>


<p>The overhead elements are described in separate sub sections as follows:</p>
<ul>
<li>shell escape</li>
<li>from future imports</li>
<li>doc string</li>
<li>CVS cruft</li>
<li>imports</li>
</ul>
<p>The more important elements are described in separate sections:</p>
<ul>
<li>Base Class Definitions</li>
<li>Application Class and Main Functions</li>
<li>Module Initialization</li>
<li>Interface Functions</li>
</ul>

<h4>Python Library Imports</h4>

<p>The following Python library modules are used by this application.</p>
<ul>
<li>The <span class="code">sys</span> module provides access to the command line arguments.</li>
<li>The <span class="code">os</span> module provide os-specific file and path manipulations; it is used
to transform the input file name into the output file name as well as track down file modification
times.</li>
<li>The <span class="code">re</span> module provides regular expressions; these are used to 
parse the input file.</li>
<li>The <span class="code">time</span> module provides a handy current-time string; this is used
to by the HTML Weaver to write a closing timestamp on generated HTML files, 
as well as log messages.</li>
</ul>


    <a name="pyweb151"></a>
    <!--line number 3963-->
    <p><em>Imports</em> (151)&nbsp;+=</p>
    <code><pre>
import sys
import os
import re
import time

    </pre></code>
    <p>&loz; <em>Imports</em> (151).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<h4>Overheads</h4>

<p>The shell escape is provided so that the user can define this
file as executable, and launch it directly from their shell.
The shell reads the first line of a file; when it finds the <tt>'#!'</tt> shell
escape, the remainder of the line is taken as the path to the binary program
that should be run.  The shell runs this binary, providing the 
file as standard input.
</p>


    <a name="pyweb152"></a>
    <!--line number 3981-->
    <p><em>Overheads</em> (152)&nbsp;=</p>
    <code><pre>
#!/usr/bin/env python

    </pre></code>
    <p>&loz; <em>Overheads</em> (152).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The from-future imports allow us to get ready for Python 3.0 compatibility.
They also limit us to version of Python that support these <tt>__future__</tt>
modules.  That means at least Python 2.6.</p>


    <a name="pyweb153"></a>
    <!--line number 3989-->
    <p><em>Overheads</em> (153)&nbsp;+=</p>
    <code><pre>
from __future__ import print_function

    </pre></code>
    <p>&loz; <em>Overheads</em> (153).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>A Python <tt>__doc__</tt> string provides a standard vehicle for documenting
the module or the application program.  The usual style is to provide
a one-sentence summary on the first line.  This is followed by more 
detailed usage information.
</p>


    <a name="pyweb154"></a>
    <!--line number 3999-->
    <p><em>Overheads</em> (154)&nbsp;+=</p>
    <code><pre>
&quot;&quot;&quot;pyWeb Literate Programming - tangle and weave tool.

Yet another simple literate programming tool derived from nuweb, 
implemented entirely in Python.  
This produces any markup for any programming language.

Usage:
    pyweb.py [-dvs] [-c x] [-w format] file.w

Options:
    -v           verbose output (the default)
    -s           silent output
    -d           debugging output
    -c x         change the command character from '@' to x
    -w format    Use the given weaver for the final document.
                 The default is based on the input file, a leading '&lt;'
                 indicates HTML, otherwise LaTeX.
                 choices are 'html', 'latex', 'rst'.
    -xw          Exclude weaving
    -xt          Exclude tangling
    -pi          Permit include-command errors
    
    file.w       The input file, with @o, @d, @i, @[, @{, @|, @&lt;, @f, @m, @u commands.
&quot;&quot;&quot;

    </pre></code>
    <p>&loz; <em>Overheads</em> (154).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The keyword cruft is a standard way of placing version control information into
a Python module so it is preserved.  See PEP (Python Enhancement Proposal) #8 for information
on recommended styles.
</p>

<p>We also sneak in a "DO NOT EDIT" warning that belongs in all generated application 
source files.</p>


    <a name="pyweb155"></a>
    <!--line number 4034-->
    <p><em>Overheads</em> (155)&nbsp;+=</p>
    <code><pre>
__version__ = &quot;&quot;&quot;$Revision$&quot;&quot;&quot;

### DO NOT EDIT THIS FILE!
### It was created by /Users/slott/Documents/Projects/pyWeb-2.1/pyweb/pyweb.py, __version__='$Revision$'.
### From source pyweb.w modified Sat Feb 27 07:18:21 2010.
### In working directory '/Users/slott/Documents/Projects/pyWeb-2.1/pyweb'.

    </pre></code>
    <p>&loz; <em>Overheads</em> (155).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



<a name="app"></a><h3>The Application Class</h3>

<h4>Design</h4>

<p>The <span class="code">Application</span> class is provided so that the <span class="code">Action</span> instances
have an overall application to update.  This allows the <span class="code">WeaveAction</span> to 
provide the selected <span class="code">Weaver</span> instance to the application.  It also provides a
central location for the various options and alternatives that might be accepted from
the command line.
</p>

<p>The constructor sets the default options for weaving and tangling.</p>

<p>The <span class="code">parseArgs()</span> method uses the <tt>sys.argv</tt> sequence to 
parse the command line arguments and update the options.  This allows a
program to pre-process the arguments, passing other arguments to this module.
</p>

<p>The <span class="code">process()</span> method processes a list of files.  This is either
the list of files passed as an argument, or it is the list of files
parsed by the <span class="code">parseArgs()</span> method.
</p>

<p>The <span class="code">parseArgs()</span> and </b>process()</b> functions are separated so that
another application can <tt>import pyweb</tt>, bypass command-line parsing, yet still perform
the basic actionss simply and consistently.</p>
<p>For example:</p>
<pre>
import pyweb, optparse
p= optparse.OptionParser()
<i>option definition</i>
options, args = p.parse_args()
a= pyweb.Application( <i>My Emitter Factory</i> )
<i>Configure the Application based on options</i>
a.process( args )
</pre>

<p>The <span class="code">main()</span> function creates an <span class="code">Application</span> instance and
calls the <span class="code">parseArgs()</span> and <span class="code">process()</span> methods to provide the
expected default behavior for this module when it is used as the main program.
</p>

<h4>Implementation</h4>


    <a name="pyweb156"></a>
    <!--line number 4088-->
    <p><em>Imports</em> (156)&nbsp;+=</p>
    <code><pre>
import optparse

    </pre></code>
    <p>&loz; <em>Imports</em> (156).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>



    <a name="pyweb157"></a>
    <!--line number 4093-->
    <p><em>Application Class</em> (157)&nbsp;=</p>
    <code><pre>

class Application( object ):
    def __init__( self ):
        <a href="#pyweb158">&rarr;<em>Application default options</em> (158)</a>
    <a href="#pyweb159">&rarr;<em>Application parse command line</em> (159)</a>
    <a href="#pyweb160">&rarr;<em>Application class process all files</em> (160)</a>

    </pre></code>
    <p>&loz; <em>Application Class</em> (157).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p><a name="log_setting"></a>
The first part of parsing the command line is 
setting default values that apply when parameters are omitted.
The default values are set as follows:
</p>
<ul>
<li><i>theTangler</i> is set to a <span class="code">TanglerMake</span> instance 
to create the output files.</li>
<li><i>theWeaver</i> is set to <span class="code">None</span> so that the input
language will be used to select an appropriate weaver.</li>
<li><i>commandChar</i> is set to <b><tt>@</tt></b> as the 
default command introducer.</li>
<li><i>doWeave</i> and </i>doTangle</i> are instances of <span class="code">Action</span>
that describe two use cases: Tangle only and Weave only.</li>
<li><i>theAction</i> is an instance of <span class="code">Action</span> that describes
the default overall action: load, tangle and weave.  This is the default unless
overridden by an option.</li>
<li><i>permitList</i> provides a list of commands that are permitted
to fail.  Typically this is empty, or contains @i to allow the include
command to fail.</li>
<li><i>files</i> is the final list of argument files from the command line; 
these will be processed unless overridden in the call to <span class="code">process()</span>.</li>
<li><i>webReader</i> is the <span class="code">WebReader</span> instance created for the current
input file.</i>
</ul>


    <a name="pyweb158"></a>
    <!--line number 4129-->
    <p><em>Application default options</em> (158)&nbsp;=</p>
    <code><pre>

self.theTangler= TanglerMake()
self.theWeaver= None
self.permitList= []
self.commandChar= '@'
self.loadOp= LoadAction()
self.weaveOp= WeaveAction()
self.tangleOp= TangleAction()
self.doWeave= ActionSequence( &quot;load and weave&quot;, [self.loadOp, self.weaveOp] )
self.doTangle= ActionSequence( &quot;load and tangle&quot;, [self.loadOp, self.tangleOp] )
self.theAction= ActionSequence( &quot;load, tangle and weave&quot;, [self.loadOp, self.tangleOp, self.weaveOp] )
self.files= []

    </pre></code>
    <p>&loz; <em>Application default options</em> (158).
      Used by <a href="#pyweb157"><em>Application Class</em>&nbsp;(157)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The algorithm for parsing the command line parameters uses the built in
<span class="code">optparse</span> module.  We have to build a parser, define the options,
provide default values, and the parse the command-line arguments.
</p>

    <a name="pyweb159"></a>
    <!--line number 4148-->
    <p><em>Application parse command line</em> (159)&nbsp;=</p>
    <code><pre>

def parseArgs( self ):
    p = optparse.OptionParser()
    p.add_option( &quot;-v&quot;, &quot;--verbose&quot;, dest=&quot;verbosity&quot;, action=&quot;store_const&quot;, const=logging.INFO )
    p.add_option( &quot;-s&quot;, &quot;--silent&quot;, dest=&quot;verbosity&quot;, action=&quot;store_const&quot;, const=logging.WARN )
    p.add_option( &quot;-d&quot;, &quot;--debug&quot;, dest=&quot;verbosity&quot;, action=&quot;store_const&quot;, const=logging.DEBUG )
    p.add_option( &quot;-c&quot;, &quot;--command&quot;, dest=&quot;command&quot;, action=&quot;store&quot; )
    p.add_option( &quot;-w&quot;, &quot;--weaver&quot;, dest=&quot;weaver&quot;, action=&quot;store&quot; )
    p.add_option( &quot;-x&quot;, &quot;--except&quot;, dest=&quot;skip&quot;, action=&quot;store&quot; )
    p.add_option( &quot;-p&quot;, &quot;--permit&quot;, dest=&quot;permit&quot;, action=&quot;store&quot; )
    opts, self.files= p.parse_args()
    if opts.command:
        logger.info( &quot;Setting command character to %r&quot;, opts.command )
        self.commandChar= opts.command
    if opts.weaver:
        self.theWeaver= weavers[ opts.weaver ]
        logger.info( &quot;Setting weaver to %s&quot;, self.theWeaver )
    if opts.skip:
        if opts.skip.lower().startswith('w'): # skip weaving
            self.theAction= self.doTangle
        elif opts.skip.lower().startswith('t'): # skip tangling
            self.theAction= self.doWeave
        else:
            raise Exception( &quot;Unknown -x option %r&quot; % opts.skip )
    if opts.permit:
        # save permitted errors, usual case is -pi to permit include errors
        self.permitList= [ '%s%s' % ( commandChar, c ) for c in opts.permit ]
    if opts.verbosity:
        logger.setLevel( opts.verbosity )
    self.options= opts


    </pre></code>
    <p>&loz; <em>Application parse command line</em> (159).
      Used by <a href="#pyweb157"><em>Application Class</em>&nbsp;(157)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>The <span class="code">process()</span> function uses the current <span class="code">Application</span> settings
to process each file as follows:</p>
<ol>
<li>Create a new <span class="code">WebReader</span> for the <span class="code">Application</span>, providing
the parameters required to process the input file.</li>
<li>Create a <span class="code">Web</span> instance, <i>w</i> 
and set the Web's <i>sourceFileName</i> from the WebReader's <i>fileName</i>.</i>
<li>Perform the given command, typically a <span class="code">ActionSequence</span>, 
which does some combination of load, tangle the output files and
weave the final document in the target language; if
necessary, examine the <span class="code">Web</span> to determine the documentation language.</li>
<li>Print a performance summary line that shows lines processed per second.</li>
</ol>

<p>In the event of failure in any of the major processing steps, 
a summary message is produced, to clarify the state of 
the output files, and the exception is reraised.
The re-raising is done so that all exceptions are handled by the 
outermost main program.</p>


    <a name="pyweb160"></a>
    <!--line number 4203-->
    <p><em>Application class process all files</em> (160)&nbsp;=</p>
    <code><pre>

def process( self, theFiles=None ):
    self.weaveOp.theWeaver= self.theWeaver
    self.tangleOp.theTangler= self.theTangler
    for f in theFiles or self.files:
        w= Web( f ) # A web to work on.
        try:
            with open(f,&quot;r&quot;) as source:
                logger.info( &quot;Reading %r&quot;, f )
                webReader= WebReader( command=self.commandChar, permit=self.permitList )
                webReader.source( f, source ).web( w )
                self.loadOp.webReader= webReader
                self.theAction.web= w
                self.theAction()
        except Error,e:
            logger.exception( e )
        except IOError,e:
            logger.exception( e )
        logger.info( 'pyWeb: %s', self.theAction.summary(w,self) )

    </pre></code>
    <p>&loz; <em>Application class process all files</em> (160).
      Used by <a href="#pyweb157"><em>Application Class</em>&nbsp;(157)</a>; <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<a name="interface"></a><h3>The Main Function</h3>

<p>The top-level interface is the <span class="code">main()</span> function.
This function creates an <span class="code">Application</span> instance.
</p>
<p>The <span class="code">Application</span> object parses the command-line arguments.
Then the <span class="code">Application</span> object does the requested processing.
This two-step process allows for some dependency injection to customize argument processing.
</p>


    <a name="pyweb161"></a>
    <!--line number 4236-->
    <p><em>Interface Functions</em> (161)&nbsp;=</p>
    <code><pre>

def main():
    logging.basicConfig( stream=sys.stderr, level=logging.INFO )
    logging.getLogger( &quot;pyweb.TanglerMake&quot; ).setLevel( logging.WARN )
    logging.getLogger( &quot;pyweb.WebReader&quot; ).setLevel( logging.WARN )
    a= Application()
    a.parseArgs()
    a.process()
    logging.shutdown()

if __name__ == &quot;__main__&quot;:
    main( )

    </pre></code>
    <p>&loz; <em>Interface Functions</em> (161).
      Used by <a href="#pyweb150"><em>pyweb.py</em>&nbsp;(150)</a>.
    </p>


<p>This can be extended by doing something like the following.</p>

<ul>
<li>Subclass <span class="code">Weaver</span> create a subclass with different templates.</li>
<li>Update the <tt>pyweb.weavers</tt> dictionary.</li>
<li>Call <tt>pyweb.main()</tt> to run the existing
main program with extra classes available to it.</li>
</ul>
<code><pre>
import pyweb
class MyWeaver( HTML ):
     <i>Any template changes</i>
     
pyweb.weavers['myweaver']= MyWeaver()
pyweb.main()
</pre></code>

<p>This will create a variant on <i>pyWeb</i> that will handle a different
weaver via the command-line option <tt>-w myweaver</tt>.</p>

<a name="scripts"></a><h2>Additional Scripts</h2>
<p>Two aditional scripts are provided as examples 
which an be customized.</p>

<h3><tt>tangle.py</tt> Script</h3>
<p>This script shows a simple version of Tangling.  This has a permitted 
error for '@i' commands to allow an include file (for example test results)
to be omitted from the tangle operation.
</p>

<a name="pyweb162"></a>
    <!--line number 4281-->
    <p><tt>tangle.py</tt> (162)&nbsp;=</p>
    <code><pre>
#!/usr/bin/env python
&quot;&quot;&quot;Sample tangle.py script.&quot;&quot;&quot;
import pyweb
import logging, sys

logging.basicConfig( stream=sys.stderr, level=logging.INFO )
logger= logging.getLogger(__file__)

w= pyweb.Web( &quot;pyweb.w&quot; ) # The web we'll work on.

permitList= ['@i']
commandChar= '@'
load= pyweb.LoadAction()
load.webReader= pyweb.WebReader( command=commandChar, permit=permitList )
load.webReader.web( w ).source( &quot;pyweb.w&quot; )
load.web= w
load()
logger.info( load.summary() )

tangle= pyweb.TangleAction()
tangle.theTangler= pyweb.TanglerMake()
tangle.web= w
tangle()
logger.info( tangle.summary() )
</pre></code>
    <p>&loz; <tt>tangle.py</tt> (162).
    
    </p>


<h3><tt>weave.py</tt> Script</h3>
<p>This script shows a simple version of Weaving.  This shows how
to define a customized set of templates for a different markup language.
</p>

<p>A customized weaver generally has three parts.</p>

<a name="pyweb163"></a>
    <!--line number 4315-->
    <p><tt>weave.py</tt> (163)&nbsp;=</p>
    <code><pre>
<a href="#pyweb164">&rarr;<em>weave.py overheads for correct operation of a script</em> (164)</a>
<a href="#pyweb165">&rarr;<em>weave.py weaver definition to customize the Weaver being used</em> (165)</a>
<a href="#pyweb166">&rarr;<em>weaver.py actions to load and weave the document</em> (166)</a>
</pre></code>
    <p>&loz; <tt>weave.py</tt> (163).
    
    </p>



    <a name="pyweb164"></a>
    <!--line number 4321-->
    <p><em>weave.py overheads for correct operation of a script</em> (164)&nbsp;=</p>
    <code><pre>
#!/usr/bin/env python
&quot;&quot;&quot;Sample weave.py script.&quot;&quot;&quot;
import pyweb
import logging, sys, string

logging.basicConfig( stream=sys.stderr, level=logging.INFO )
logger= logging.getLogger(__file__)

    </pre></code>
    <p>&loz; <em>weave.py overheads for correct operation of a script</em> (164).
      Used by <a href="#pyweb163"><em>weave.py</em>&nbsp;(163)</a>.
    </p>



    <a name="pyweb165"></a>
    <!--line number 4331-->
    <p><em>weave.py weaver definition to customize the Weaver being used</em> (165)&nbsp;=</p>
    <code><pre>

class MyHTML( pyweb.HTML ):
    &quot;&quot;&quot;HTML formatting templates.&quot;&quot;&quot;
    extension= &quot;.html&quot;
    
    cb_template= string.Template(&quot;&quot;&quot;&lt;a name=&quot;pyweb${seq}&quot;&gt;&lt;/a&gt;
    &lt;!--line number ${lineNumber}--&gt;
    &lt;p&gt;&lt;em&gt;${fullName}&lt;/em&gt; (${seq})&amp;nbsp;${concat}&lt;/p&gt;
    &lt;code&gt;&lt;pre&gt;\n&quot;&quot;&quot;)

    ce_template= string.Template(&quot;&quot;&quot;
    &lt;/pre&gt;&lt;/code&gt;
    &lt;p&gt;&amp;loz; &lt;em&gt;${fullName}&lt;/em&gt; (${seq}).
    ${references}
    &lt;/p&gt;\n&quot;&quot;&quot;)
        
    fb_template= string.Template(&quot;&quot;&quot;&lt;a name=&quot;pyweb${seq}&quot;&gt;&lt;/a&gt;
    &lt;!--line number ${lineNumber}--&gt;
    &lt;p&gt;&lt;tt&gt;${fullName}&lt;/tt&gt; (${seq})&amp;nbsp;${concat}&lt;/p&gt;
    &lt;code&gt;&lt;pre&gt;\n&quot;&quot;&quot;) # Prevent indent
        
    fe_template= string.Template( &quot;&quot;&quot;&lt;/pre&gt;&lt;/code&gt;
    &lt;p&gt;&amp;loz; &lt;tt&gt;${fullName}&lt;/tt&gt; (${seq}).
    ${references}
    &lt;/p&gt;\n&quot;&quot;&quot;)
        
    ref_item_template = string.Template(
    '&lt;a href=&quot;#pyweb${seq}&quot;&gt;&lt;em&gt;${fullName}&lt;/em&gt;&amp;nbsp;(${seq})&lt;/a&gt;'
    )
    
    ref_template = string.Template( '  Used by ${refList}.'  )
            
    refto_name_template = string.Template(
    '&lt;a href=&quot;#pyweb${seq}&quot;&gt;&amp;rarr;&lt;em&gt;${fullName}&lt;/em&gt;&amp;nbsp;(${seq})&lt;/a&gt;'
    )
    refto_seq_template = string.Template( '&lt;a href=&quot;#pyweb${seq}&quot;&gt;(${seq})&lt;/a&gt;' )
 
    xref_head_template = string.Template( &quot;&lt;dl&gt;\n&quot; )
    xref_foot_template = string.Template( &quot;&lt;/dl&gt;\n&quot; )
    xref_item_template = string.Template( &quot;&lt;dt&gt;${fullName}&lt;/dt&gt;&lt;dd&gt;${refList}&lt;/dd&gt;\n&quot; )
    
    name_def_template = string.Template( '&lt;a href=&quot;#pyweb${seq}&quot;&gt;&lt;b&gt;&amp;bull;${seq}&lt;/b&gt;&lt;/a&gt;' )
    name_ref_template = string.Template( '&lt;a href=&quot;#pyweb${seq}&quot;&gt;${seq}&lt;/a&gt;' )

    </pre></code>
    <p>&loz; <em>weave.py weaver definition to customize the Weaver being used</em> (165).
      Used by <a href="#pyweb163"><em>weave.py</em>&nbsp;(163)</a>.
    </p>



    <a name="pyweb166"></a>
    <!--line number 4377-->
    <p><em>weaver.py actions to load and weave the document</em> (166)&nbsp;=</p>
    <code><pre>

w= pyweb.Web( &quot;pyweb.w&quot; ) # The web we'll work on.

permitList= []
commandChar= '@'
load= pyweb.LoadAction()
load.webReader=  pyweb.WebReader( command=commandChar, permit=permitList )
load.webReader.web( w ).source( &quot;pyweb.w&quot; )
load.web= w
load()
logger.info( load.summary() )

weave= pyweb.WeaveAction()
weave.theWeaver= MyHTML()
weave.web= w
weave()
logger.info( weave.summary() )

    </pre></code>
    <p>&loz; <em>weaver.py actions to load and weave the document</em> (166).
      Used by <a href="#pyweb163"><em>weave.py</em>&nbsp;(163)</a>.
    </p>


<a name="admin"></a><h2>Administrative Elements</h2>
<p>In order to support a pleasant installation, the <tt>setup.py</tt> file is helpful.</p>

<a name="pyweb167"></a>
    <!--line number 4400-->
    <p><tt>setup.py</tt> (167)&nbsp;=</p>
    <code><pre>
#!/usr/bin/env python
&quot;&quot;&quot;Setup for pyWeb.&quot;&quot;&quot;

from distutils.core import setup

setup(name='pyweb',
      version='2.1',
      description='pyWeb 2.1: In Python, Yet Another Literate Programming Tool',
      author='S. Lott',
      author_email='s_lott@yahoo.com',
      url='http://slott-softwarearchitect.blogspot.com/',
      py_modules=['pyweb'],
      classifiers=[
      'Intended Audience :: Developers',
      'Topic :: Documentation',
      'Topic :: Software Development :: Documentation', 
      'Topic :: Text Processing :: Markup',
      ]
   )
</pre></code>
    <p>&loz; <tt>setup.py</tt> (167).
    
    </p>


<p>In order build a source distribution kit the <tt>setup.py sdist</tt> requires a
<tt>MANIFEST</tt>.  We can either list all files or provide a   <tt>MANIFEST.in</tt>
that specifies additional rules.
We use a simple inclusion to augment the default manifest rules.
</p>

<a name="pyweb168"></a>
    <!--line number 4428-->
    <p><tt>MANIFEST.in</tt> (168)&nbsp;=</p>
    <code><pre>
include *.w *.css *.html
include test/*.w test/*.css test/*.html test/*.py
</pre></code>
    <p>&loz; <tt>MANIFEST.in</tt> (168).
    
    </p>


<p>Generally, a <tt>README</tt> is also considered to be good form.</p>

<a name="pyweb169"></a>
    <!--line number 4435-->
    <p><tt>README</tt> (169)&nbsp;=</p>
    <code><pre>
pyWeb 2.1: In Python, Yet Another Literate Programming Tool

Literate programming is an attempt to reconcile the opposing needs
of clear presentation to people with the technical issues of 
creating code that will work with our current set of tools.

Presentation to people requires extensive and sophisticated typesetting
techniques.  Further, the &quot;narrative arc&quot; of a presentation may not 
follow the source code as layed out for the compiler.

pyWeb is a literate programming tool that combines the actions
of weaving a document with tangling source files.
It is independent of any particular document markup or source language.
Is uses a simple set of markup tags to define chunks of code and 
documentation.

The pyweb.w file is the source for the various pyweb module and script files, plus
the pyweb.html file.  The various source code files are created by applying a 
tangle operation to the .w file.  The final documentation is created by
applying a weave operation to the .w file.

Installation
-------------

::

    python setup.py install

This will install the pyweb module.  

Authoring
---------

The pyweb document describes the simple markup used to define code chunks
and assemble those code chunks into a coherent document as well as working code.

Operation
---------

You can then run pyweb with

::

    python -m pyweb pyweb.w 

This will create the various output files from the source .w file.

-   pyweb.html is the final woven document.

-   pyweb.py, tangle.py, weave.py, readme, setup.py and MANIFEST.in are tangled output files.

Testing
-------

The test directory includes pyweb_test.w, which will create a 
complete test suite.

This weaves a pyweb_test.html file.

This tangles several test modules:  test.py, test_tangler.py, test_weaver.py,
test_loader.py and test_unit.py.  Running the test.py module will include and
execute all 71 tests.

</pre></code>
    <p>&loz; <tt>README</tt> (169).
    
    </p>
</div>

<a name="ix"></a><h1>Indices</h1>
<div class="chapter">
<h2>Files</h2>

<dl>
<dt>MANIFEST.in</dt><dd><a href="#pyweb168">(168)</a></dd>
<dt>README</dt><dd><a href="#pyweb169">(169)</a></dd>
<dt>pyweb.py</dt><dd><a href="#pyweb150">(150)</a></dd>
<dt>setup.py</dt><dd><a href="#pyweb167">(167)</a></dd>
<dt>tangle.py</dt><dd><a href="#pyweb162">(162)</a></dd>
<dt>weave.py</dt><dd><a href="#pyweb163">(163)</a></dd>
</dl>

<h2>Macros</h2>
<dl>
<dt>Action call method actually performs the action</dt><dd><a href="#pyweb133">(133)</a></dd>
<dt>Action class hierarchy - used to describe basic actions of the application</dt><dd><a href="#pyweb131">(131)</a></dd>
<dt>Action final summary method</dt><dd><a href="#pyweb134">(134)</a></dd>
<dt>Action superclass has common features of all actions</dt><dd><a href="#pyweb132">(132)</a></dd>
<dt>ActionSequence append adds a new action to the sequence</dt><dd><a href="#pyweb137">(137)</a></dd>
<dt>ActionSequence call method delegates the sequence of ations</dt><dd><a href="#pyweb136">(136)</a></dd>
<dt>ActionSequence subclass that holds a sequence of other actions</dt><dd><a href="#pyweb135">(135)</a></dd>
<dt>ActionSequence summary summarizes each step</dt><dd><a href="#pyweb138">(138)</a></dd>
<dt>Application Class</dt><dd><a href="#pyweb157">(157)</a></dd>
<dt>Application class process all files</dt><dd><a href="#pyweb160">(160)</a></dd>
<dt>Application default options</dt><dd><a href="#pyweb158">(158)</a></dd>
<dt>Application parse command line</dt><dd><a href="#pyweb159">(159)</a></dd>
<dt>Base Class Definitions</dt><dd><a href="#pyweb1">(1)</a></dd>
<dt>Chunk add to the web</dt><dd><a href="#pyweb55">(55)</a></dd>
<dt>Chunk append a command</dt><dd><a href="#pyweb53">(53)</a></dd>
<dt>Chunk append text</dt><dd><a href="#pyweb54">(54)</a></dd>
<dt>Chunk class</dt><dd><a href="#pyweb52">(52)</a></dd>
<dt>Chunk class hierarchy - used to describe input chunks</dt><dd><a href="#pyweb51">(51)</a></dd>
<dt>Chunk examination: starts with, matches pattern</dt><dd><a href="#pyweb57">(57)</a></dd>
<dt>Chunk generate references from this Chunk</dt><dd><a href="#pyweb59">(59)</a></dd>
<dt>Chunk references to this Chunk</dt><dd><a href="#pyweb60">(60)</a></dd>
<dt>Chunk search for user identifiers in each child command</dt><dd><a href="#pyweb58">(58)</a></dd>
<dt>Chunk superclass make Content definition</dt><dd><a href="#pyweb56">(56)</a></dd>
<dt>Chunk tangle this Chunk into a code file</dt><dd><a href="#pyweb62">(62)</a></dd>
<dt>Chunk weave this Chunk into the documentation</dt><dd><a href="#pyweb61">(61)</a></dd>
<dt>CodeCommand class to contain a program source code block</dt><dd><a href="#pyweb80">(80)</a></dd>
<dt>Command analysis features: starts-with and Regular Expression search</dt><dd><a href="#pyweb77">(77)</a></dd>
<dt>Command class hierarchy - used to describe individual commands</dt><dd><a href="#pyweb75">(75)</a></dd>
<dt>Command superclass</dt><dd><a href="#pyweb76">(76)</a></dd>
<dt>Command tangle and weave functions</dt><dd><a href="#pyweb78">(78)</a></dd>
<dt>Emitter class hierarchy - used to control output files</dt><dd><a href="#pyweb2">(2)</a></dd>
<dt>Emitter core open, close and write</dt><dd><a href="#pyweb4">(4)</a></dd>
<dt>Emitter doClose, to be overridden by subclasses</dt><dd><a href="#pyweb6">(6)</a></dd>
<dt>Emitter doOpen, to be overridden by subclasses</dt><dd><a href="#pyweb5">(5)</a></dd>
<dt>Emitter doWrite, to be overridden by subclasses</dt><dd><a href="#pyweb7">(7)</a></dd>
<dt>Emitter indent control: set, clear and reset</dt><dd><a href="#pyweb11">(11)</a></dd>
<dt>Emitter superclass</dt><dd><a href="#pyweb3">(3)</a></dd>
<dt>Emitter write a block of code</dt><dd><a href="#pyweb8">(8)</a> <a href="#pyweb9">(9)</a> <a href="#pyweb10">(10)</a></dd>
<dt>Error class - defines the errors raised</dt><dd><a href="#pyweb90">(90)</a></dd>
<dt>FileXrefCommand class for an output file cross-reference</dt><dd><a href="#pyweb82">(82)</a></dd>
<dt>HTML code chunk begin</dt><dd><a href="#pyweb33">(33)</a></dd>
<dt>HTML code chunk end</dt><dd><a href="#pyweb34">(34)</a></dd>
<dt>HTML output file begin</dt><dd><a href="#pyweb35">(35)</a></dd>
<dt>HTML output file end</dt><dd><a href="#pyweb36">(36)</a></dd>
<dt>HTML reference to a chunk</dt><dd><a href="#pyweb39">(39)</a></dd>
<dt>HTML references summary at the end of a chunk</dt><dd><a href="#pyweb37">(37)</a></dd>
<dt>HTML short references summary at the end of a chunk</dt><dd><a href="#pyweb42">(42)</a></dd>
<dt>HTML simple cross reference markup</dt><dd><a href="#pyweb40">(40)</a></dd>
<dt>HTML subclass of Weaver</dt><dd><a href="#pyweb31">(31)</a> <a href="#pyweb32">(32)</a></dd>
<dt>HTML write a line of code</dt><dd><a href="#pyweb38">(38)</a></dd>
<dt>HTML write user id cross reference line</dt><dd><a href="#pyweb41">(41)</a></dd>
<dt>Imports</dt><dd><a href="#pyweb12">(12)</a> <a href="#pyweb47">(47)</a> <a href="#pyweb118">(118)</a> <a href="#pyweb151">(151)</a> <a href="#pyweb156">(156)</a></dd>
<dt>Interface Functions</dt><dd><a href="#pyweb161">(161)</a></dd>
<dt>LaTeX code chunk begin</dt><dd><a href="#pyweb24">(24)</a></dd>
<dt>LaTeX code chunk end</dt><dd><a href="#pyweb25">(25)</a></dd>
<dt>LaTeX file output begin</dt><dd><a href="#pyweb26">(26)</a></dd>
<dt>LaTeX file output end</dt><dd><a href="#pyweb27">(27)</a></dd>
<dt>LaTeX reference to a chunk</dt><dd><a href="#pyweb30">(30)</a></dd>
<dt>LaTeX references summary at the end of a chunk</dt><dd><a href="#pyweb28">(28)</a></dd>
<dt>LaTeX subclass of Weaver</dt><dd><a href="#pyweb23">(23)</a></dd>
<dt>LaTeX write a line of code</dt><dd><a href="#pyweb29">(29)</a></dd>
<dt>LoadAction call method loads the input files</dt><dd><a href="#pyweb146">(146)</a></dd>
<dt>LoadAction subclass loads the document web</dt><dd><a href="#pyweb145">(145)</a></dd>
<dt>LoadAction summary provides lines read</dt><dd><a href="#pyweb147">(147)</a></dd>
<dt>MacroXrefCommand class for a named chunk cross-reference</dt><dd><a href="#pyweb83">(83)</a></dd>
<dt>Module Initialization of global variables</dt><dd><a href="#pyweb148">(148)</a> <a href="#pyweb149">(149)</a></dd>
<dt>NamedChunk add to the web</dt><dd><a href="#pyweb65">(65)</a></dd>
<dt>NamedChunk class</dt><dd><a href="#pyweb63">(63)</a></dd>
<dt>NamedChunk tangle into the source file</dt><dd><a href="#pyweb67">(67)</a></dd>
<dt>NamedChunk user identifiers set and get</dt><dd><a href="#pyweb64">(64)</a></dd>
<dt>NamedChunk weave</dt><dd><a href="#pyweb66">(66)</a></dd>
<dt>NamedDocumentChunk class</dt><dd><a href="#pyweb72">(72)</a></dd>
<dt>NamedDocumentChunk tangle</dt><dd><a href="#pyweb74">(74)</a></dd>
<dt>NamedDocumentChunk weave</dt><dd><a href="#pyweb73">(73)</a></dd>
<dt>OutputChunk add to the web</dt><dd><a href="#pyweb69">(69)</a></dd>
<dt>OutputChunk class</dt><dd><a href="#pyweb68">(68)</a></dd>
<dt>OutputChunk tangle</dt><dd><a href="#pyweb71">(71)</a></dd>
<dt>OutputChunk weave</dt><dd><a href="#pyweb70">(70)</a></dd>
<dt>Overheads</dt><dd><a href="#pyweb152">(152)</a> <a href="#pyweb153">(153)</a> <a href="#pyweb154">(154)</a> <a href="#pyweb155">(155)</a></dd>
<dt>Reference class hierarchy - references to a chunk</dt><dd><a href="#pyweb91">(91)</a> <a href="#pyweb92">(92)</a> <a href="#pyweb93">(93)</a></dd>
<dt>ReferenceCommand class for chunk references</dt><dd><a href="#pyweb85">(85)</a></dd>
<dt>ReferenceCommand refers to a chunk</dt><dd><a href="#pyweb87">(87)</a></dd>
<dt>ReferenceCommand resolve a referenced chunk name</dt><dd><a href="#pyweb86">(86)</a></dd>
<dt>ReferenceCommand tangle a referenced chunk</dt><dd><a href="#pyweb89">(89)</a></dd>
<dt>ReferenceCommand weave a reference to a chunk</dt><dd><a href="#pyweb88">(88)</a></dd>
<dt>TangleAction call method does tangling of the output files</dt><dd><a href="#pyweb143">(143)</a></dd>
<dt>TangleAction subclass initiates the tangle action</dt><dd><a href="#pyweb142">(142)</a></dd>
<dt>TangleAction summary method provides total lines tangled</dt><dd><a href="#pyweb144">(144)</a></dd>
<dt>Tangler code chunk begin</dt><dd><a href="#pyweb45">(45)</a></dd>
<dt>Tangler code chunk end</dt><dd><a href="#pyweb46">(46)</a></dd>
<dt>Tangler doOpen, doClose and doWrite overrides</dt><dd><a href="#pyweb44">(44)</a></dd>
<dt>Tangler subclass of Emitter to create source files with no markup</dt><dd><a href="#pyweb43">(43)</a></dd>
<dt>Tangler subclass which is make-sensitive</dt><dd><a href="#pyweb48">(48)</a></dd>
<dt>TanglerMake doClose override, comparing temporary to original</dt><dd><a href="#pyweb50">(50)</a></dd>
<dt>TanglerMake doOpen override, using a temporary file</dt><dd><a href="#pyweb49">(49)</a></dd>
<dt>TextCommand class to contain a document text block</dt><dd><a href="#pyweb79">(79)</a></dd>
<dt>UserIdXrefCommand class for a user identifier cross-reference</dt><dd><a href="#pyweb84">(84)</a></dd>
<dt>WeaveAction call method does weaving of the document file</dt><dd><a href="#pyweb140">(140)</a></dd>
<dt>WeaveAction subclass initiates the weave action</dt><dd><a href="#pyweb139">(139)</a></dd>
<dt>WeaveAction summary method provides line counts</dt><dd><a href="#pyweb141">(141)</a></dd>
<dt>Weaver code chunk begin-end</dt><dd><a href="#pyweb18">(18)</a></dd>
<dt>Weaver cross reference output methods</dt><dd><a href="#pyweb21">(21)</a> <a href="#pyweb22">(22)</a></dd>
<dt>Weaver doOpen, doClose and doWrite overrides</dt><dd><a href="#pyweb14">(14)</a></dd>
<dt>Weaver document chunk begin-end</dt><dd><a href="#pyweb16">(16)</a></dd>
<dt>Weaver file chunk begin-end</dt><dd><a href="#pyweb19">(19)</a></dd>
<dt>Weaver quoted characters</dt><dd><a href="#pyweb15">(15)</a></dd>
<dt>Weaver reference command output</dt><dd><a href="#pyweb20">(20)</a></dd>
<dt>Weaver reference summary, used by code chunk and file chunk</dt><dd><a href="#pyweb17">(17)</a></dd>
<dt>Weaver subclass of Emitter to create documentation with fancy markup and escapes</dt><dd><a href="#pyweb13">(13)</a></dd>
<dt>Web Chunk check reference counts are all one</dt><dd><a href="#pyweb103">(103)</a></dd>
<dt>Web Chunk cross reference methods</dt><dd><a href="#pyweb102">(102)</a> <a href="#pyweb104">(104)</a> <a href="#pyweb105">(105)</a> <a href="#pyweb106">(106)</a></dd>
<dt>Web Chunk name resolution methods</dt><dd><a href="#pyweb100">(100)</a> <a href="#pyweb101">(101)</a></dd>
<dt>Web add a named macro chunk</dt><dd><a href="#pyweb98">(98)</a></dd>
<dt>Web add an anonymous chunk</dt><dd><a href="#pyweb97">(97)</a></dd>
<dt>Web add an output file definition chunk</dt><dd><a href="#pyweb99">(99)</a></dd>
<dt>Web add full chunk names, ignoring abbreviated names</dt><dd><a href="#pyweb96">(96)</a></dd>
<dt>Web class - describes the overall "web" of chunks</dt><dd><a href="#pyweb94">(94)</a></dd>
<dt>Web construction methods used by Chunks and WebReader</dt><dd><a href="#pyweb95">(95)</a></dd>
<dt>Web determination of the language from the first chunk</dt><dd><a href="#pyweb109">(109)</a></dd>
<dt>Web tangle the output files</dt><dd><a href="#pyweb110">(110)</a></dd>
<dt>Web weave the output document</dt><dd><a href="#pyweb111">(111)</a></dd>
<dt>WebReader class - parses the input file, building the Web structure</dt><dd><a href="#pyweb112">(112)</a></dd>
<dt>WebReader command literals</dt><dd><a href="#pyweb130">(130)</a></dd>
<dt>WebReader fluent property-like methods</dt><dd><a href="#pyweb113">(113)</a></dd>
<dt>WebReader handle a command string</dt><dd><a href="#pyweb116">(116)</a></dd>
<dt>WebReader load the web</dt><dd><a href="#pyweb128">(128)</a></dd>
<dt>WebReader location in the input stream</dt><dd><a href="#pyweb115">(115)</a></dd>
<dt>WebReader tokenize the input</dt><dd><a href="#pyweb114">(114)</a></dd>
<dt>XrefCommand superclass for all cross-reference commands</dt><dd><a href="#pyweb81">(81)</a></dd>
<dt>add a reference command to the current chunk</dt><dd><a href="#pyweb125">(125)</a></dd>
<dt>add an expression command to the current chunk</dt><dd><a href="#pyweb126">(126)</a></dd>
<dt>assign user identifiers to the current chunk</dt><dd><a href="#pyweb124">(124)</a></dd>
<dt>collect all user identifiers from a given map into ux</dt><dd><a href="#pyweb107">(107)</a></dd>
<dt>double at-sign replacement, append this character to previous TextCommand</dt><dd><a href="#pyweb127">(127)</a></dd>
<dt>find user identifier usage and update ux from the given map</dt><dd><a href="#pyweb108">(108)</a></dd>
<dt>finish a chunk, start a new Chunk adding it to the web</dt><dd><a href="#pyweb122">(122)</a></dd>
<dt>import another file</dt><dd><a href="#pyweb121">(121)</a></dd>
<dt>major commands segment the input into separate Chunks</dt><dd><a href="#pyweb117">(117)</a></dd>
<dt>minor commands add Commands to the current Chunk</dt><dd><a href="#pyweb123">(123)</a></dd>
<dt>other command-like sequences are appended as a TextCommand</dt><dd><a href="#pyweb129">(129)</a></dd>
<dt>start a NamedChunk or NamedDocumentChunk, adding it to the web</dt><dd><a href="#pyweb120">(120)</a></dd>
<dt>start an OutputChunk, adding it to the web</dt><dd><a href="#pyweb119">(119)</a></dd>
<dt>weave.py overheads for correct operation of a script</dt><dd><a href="#pyweb164">(164)</a></dd>
<dt>weave.py weaver definition to customize the Weaver being used</dt><dd><a href="#pyweb165">(165)</a></dd>
<dt>weaver.py actions to load and weave the document</dt><dd><a href="#pyweb166">(166)</a></dd>
</dl>

<h2>User Identifiers</h2>
<dl>
<dt>Action</dt><dd><a href="#pyweb132"><b>&bull;132</b></a> <a href="#pyweb135">135</a> <a href="#pyweb139">139</a> <a href="#pyweb142">142</a> <a href="#pyweb145">145</a></dd>
<dt>ActionSequence</dt><dd><a href="#pyweb135"><b>&bull;135</b></a> <a href="#pyweb158">158</a></dd>
<dt>Application</dt><dd><a href="#pyweb157"><b>&bull;157</b></a> <a href="#pyweb161">161</a></dd>
<dt>Chunk</dt><dd><a href="#pyweb52"><b>&bull;52</b></a> <a href="#pyweb59">59</a> <a href="#pyweb63">63</a> <a href="#pyweb89">89</a> <a href="#pyweb94">94</a> <a href="#pyweb102">102</a> <a href="#pyweb110">110</a> <a href="#pyweb121">121</a> <a href="#pyweb122">122</a> <a href="#pyweb125">125</a> <a href="#pyweb128">128</a></dd>
<dt>CodeCommand</dt><dd><a href="#pyweb63">63</a> <a href="#pyweb80"><b>&bull;80</b></a></dd>
<dt>Command</dt><dd><a href="#pyweb53">53</a> <a href="#pyweb76"><b>&bull;76</b></a> <a href="#pyweb79">79</a> <a href="#pyweb81">81</a> <a href="#pyweb85">85</a> <a href="#pyweb89">89</a></dd>
<dt>Emitter</dt><dd><a href="#pyweb3"><b>&bull;3</b></a> <a href="#pyweb13">13</a> <a href="#pyweb43">43</a></dd>
<dt>Error</dt><dd><a href="#pyweb59">59</a> <a href="#pyweb61">61</a> <a href="#pyweb62">62</a> <a href="#pyweb66">66</a> <a href="#pyweb67">67</a> <a href="#pyweb70">70</a> <a href="#pyweb73">73</a> <a href="#pyweb74">74</a> <a href="#pyweb81">81</a> <a href="#pyweb89">89</a> <a href="#pyweb90"><b>&bull;90</b></a> <a href="#pyweb98">98</a> <a href="#pyweb100">100</a> <a href="#pyweb101">101</a> <a href="#pyweb110">110</a> <a href="#pyweb111">111</a> <a href="#pyweb116">116</a> <a href="#pyweb121">121</a> <a href="#pyweb124">124</a> <a href="#pyweb128">128</a> <a href="#pyweb140">140</a> <a href="#pyweb143">143</a> <a href="#pyweb146">146</a> <a href="#pyweb160">160</a></dd>
<dt>FileXrefCommand</dt><dd><a href="#pyweb82"><b>&bull;82</b></a> <a href="#pyweb123">123</a></dd>
<dt>HTML</dt><dd><a href="#pyweb17">17</a> <a href="#pyweb19">19</a> <a href="#pyweb21">21</a> <a href="#pyweb22">22</a> <a href="#pyweb31">31</a> <a href="#pyweb32"><b>&bull;32</b></a> <a href="#pyweb109">109</a> <a href="#pyweb149">149</a> <a href="#pyweb154">154</a> <a href="#pyweb165">165</a></dd>
<dt>LaTeX</dt><dd><a href="#pyweb18">18</a> <a href="#pyweb23"><b>&bull;23</b></a> <a href="#pyweb109">109</a> <a href="#pyweb149">149</a> <a href="#pyweb154">154</a></dd>
<dt>LoadAction</dt><dd><a href="#pyweb145"><b>&bull;145</b></a> <a href="#pyweb146">146</a> <a href="#pyweb158">158</a> <a href="#pyweb162">162</a> <a href="#pyweb166">166</a></dd>
<dt>MacroXrefCommand</dt><dd><a href="#pyweb83"><b>&bull;83</b></a> <a href="#pyweb123">123</a></dd>
<dt>NamedChunk</dt><dd><a href="#pyweb63"><b>&bull;63</b></a> <a href="#pyweb68">68</a> <a href="#pyweb72">72</a> <a href="#pyweb120">120</a> <a href="#pyweb124">124</a></dd>
<dt>NamedDocumentChunk</dt><dd><a href="#pyweb72"><b>&bull;72</b></a> <a href="#pyweb120">120</a></dd>
<dt>OutputChunk</dt><dd><a href="#pyweb68"><b>&bull;68</b></a> <a href="#pyweb71">71</a> <a href="#pyweb119">119</a></dd>
<dt>ReferenceCommand</dt><dd><a href="#pyweb85"><b>&bull;85</b></a> <a href="#pyweb125">125</a></dd>
<dt>TangleAction</dt><dd><a href="#pyweb142"><b>&bull;142</b></a> <a href="#pyweb143">143</a> <a href="#pyweb158">158</a> <a href="#pyweb162">162</a></dd>
<dt>Tangler</dt><dd><a href="#pyweb43"><b>&bull;43</b></a> <a href="#pyweb48">48</a></dd>
<dt>TanglerMake</dt><dd><a href="#pyweb48"><b>&bull;48</b></a> <a href="#pyweb158">158</a> <a href="#pyweb161">161</a> <a href="#pyweb162">162</a></dd>
<dt>TextCommand</dt><dd><a href="#pyweb54">54</a> <a href="#pyweb56">56</a> <a href="#pyweb67">67</a> <a href="#pyweb72">72</a> <a href="#pyweb79"><b>&bull;79</b></a> <a href="#pyweb80">80</a></dd>
<dt>UserIdXrefCommand</dt><dd><a href="#pyweb84"><b>&bull;84</b></a> <a href="#pyweb123">123</a></dd>
<dt>WeaveAction</dt><dd><a href="#pyweb139"><b>&bull;139</b></a> <a href="#pyweb140">140</a> <a href="#pyweb158">158</a> <a href="#pyweb166">166</a></dd>
<dt>Weaver</dt><dd><a href="#pyweb13"><b>&bull;13</b></a> <a href="#pyweb23">23</a> <a href="#pyweb31">31</a> <a href="#pyweb109">109</a> <a href="#pyweb149">149</a></dd>
<dt>Web</dt><dd><a href="#pyweb55">55</a> <a href="#pyweb65">65</a> <a href="#pyweb69">69</a> <a href="#pyweb94"><b>&bull;94</b></a> <a href="#pyweb160">160</a> <a href="#pyweb162">162</a> <a href="#pyweb166">166</a></dd>
<dt>WebReader</dt><dd><a href="#pyweb89">89</a> <a href="#pyweb112"><b>&bull;112</b></a> <a href="#pyweb121">121</a> <a href="#pyweb160">160</a> <a href="#pyweb161">161</a> <a href="#pyweb162">162</a> <a href="#pyweb166">166</a></dd>
<dt>XrefCommand</dt><dd><a href="#pyweb81"><b>&bull;81</b></a> <a href="#pyweb82">82</a> <a href="#pyweb83">83</a> <a href="#pyweb84">84</a></dd>
<dt>__version__</dt><dd><a href="#pyweb155"><b>&bull;155</b></a></dd>
<dt>_gatherUserId</dt><dd><a href="#pyweb106"><b>&bull;106</b></a></dd>
<dt>_updateUserId</dt><dd><a href="#pyweb106"><b>&bull;106</b></a></dd>
<dt>add</dt><dd><a href="#pyweb55">55</a> <a href="#pyweb97"><b>&bull;97</b></a></dd>
<dt>addDefName</dt><dd><a href="#pyweb96"><b>&bull;96</b></a> <a href="#pyweb98">98</a> <a href="#pyweb125">125</a></dd>
<dt>addNamed</dt><dd><a href="#pyweb65">65</a> <a href="#pyweb98"><b>&bull;98</b></a></dd>
<dt>addOutput</dt><dd><a href="#pyweb69">69</a> <a href="#pyweb99"><b>&bull;99</b></a></dd>
<dt>append</dt><dd><a href="#pyweb11">11</a> <a href="#pyweb53">53</a> <a href="#pyweb54">54</a> <a href="#pyweb93">93</a> <a href="#pyweb97">97</a> <a href="#pyweb98">98</a> <a href="#pyweb99">99</a> <a href="#pyweb102">102</a> <a href="#pyweb108">108</a> <a href="#pyweb114">114</a> <a href="#pyweb123">123</a> <a href="#pyweb125">125</a> <a href="#pyweb137"><b>&bull;137</b></a></dd>
<dt>appendText</dt><dd><a href="#pyweb54"><b>&bull;54</b></a> <a href="#pyweb125">125</a> <a href="#pyweb126">126</a> <a href="#pyweb127">127</a> <a href="#pyweb128">128</a> <a href="#pyweb129">129</a></dd>
<dt>chunkXref</dt><dd><a href="#pyweb83">83</a> <a href="#pyweb105"><b>&bull;105</b></a></dd>
<dt>close</dt><dd><a href="#pyweb4"><b>&bull;4</b></a> <a href="#pyweb14">14</a> <a href="#pyweb44">44</a> <a href="#pyweb50">50</a> <a href="#pyweb110">110</a> <a href="#pyweb111">111</a></dd>
<dt>clrIndent</dt><dd><a href="#pyweb11"><b>&bull;11</b></a> <a href="#pyweb66">66</a> <a href="#pyweb89">89</a></dd>
<dt>codeBegin</dt><dd><a href="#pyweb18"><b>&bull;18</b></a> <a href="#pyweb45">45</a> <a href="#pyweb66">66</a> <a href="#pyweb67">67</a></dd>
<dt>codeBlock</dt><dd><a href="#pyweb8"><b>&bull;8</b></a> <a href="#pyweb66">66</a> <a href="#pyweb80">80</a></dd>
<dt>codeEnd</dt><dd><a href="#pyweb18"><b>&bull;18</b></a> <a href="#pyweb46">46</a> <a href="#pyweb66">66</a> <a href="#pyweb67">67</a></dd>
<dt>codeFinish</dt><dd><a href="#pyweb4">4</a> <a href="#pyweb10"><b>&bull;10</b></a></dd>
<dt>codeLine</dt><dd><a href="#pyweb9"><b>&bull;9</b></a></dd>
<dt>createUsedBy</dt><dd><a href="#pyweb102"><b>&bull;102</b></a> <a href="#pyweb146">146</a></dd>
<dt>doClose</dt><dd><a href="#pyweb4">4</a> <a href="#pyweb6">6</a> <a href="#pyweb14">14</a> <a href="#pyweb44"><b>&bull;44</b></a> <a href="#pyweb50">50</a></dd>
<dt>doOpen</dt><dd><a href="#pyweb4">4</a> <a href="#pyweb5">5</a> <a href="#pyweb14">14</a> <a href="#pyweb44"><b>&bull;44</b></a> <a href="#pyweb49">49</a></dd>
<dt>doWrite</dt><dd><a href="#pyweb4">4</a> <a href="#pyweb7">7</a> <a href="#pyweb14">14</a> <a href="#pyweb44"><b>&bull;44</b></a></dd>
<dt>docBegin</dt><dd><a href="#pyweb16"><b>&bull;16</b></a> <a href="#pyweb61">61</a></dd>
<dt>docEnd</dt><dd><a href="#pyweb16"><b>&bull;16</b></a> <a href="#pyweb61">61</a></dd>
<dt>duration</dt><dd><a href="#pyweb134"><b>&bull;134</b></a> <a href="#pyweb141">141</a> <a href="#pyweb144">144</a> <a href="#pyweb147">147</a></dd>
<dt>expect</dt><dd><a href="#pyweb119">119</a> <a href="#pyweb120">120</a> <a href="#pyweb125">125</a> <a href="#pyweb126">126</a> <a href="#pyweb128"><b>&bull;128</b></a></dd>
<dt>fileBegin</dt><dd><a href="#pyweb19">19</a> <a href="#pyweb26"><b>&bull;26</b></a> <a href="#pyweb70">70</a></dd>
<dt>fileEnd</dt><dd><a href="#pyweb19">19</a> <a href="#pyweb36"><b>&bull;36</b></a> <a href="#pyweb70">70</a></dd>
<dt>fileXref</dt><dd><a href="#pyweb82">82</a> <a href="#pyweb105"><b>&bull;105</b></a></dd>
<dt>filecmp</dt><dd><a href="#pyweb47"><b>&bull;47</b></a> <a href="#pyweb50">50</a></dd>
<dt>formatXref</dt><dd><a href="#pyweb81"><b>&bull;81</b></a> <a href="#pyweb82">82</a> <a href="#pyweb83">83</a></dd>
<dt>fullNameFor</dt><dd><a href="#pyweb66">66</a> <a href="#pyweb70">70</a> <a href="#pyweb86">86</a> <a href="#pyweb96">96</a> <a href="#pyweb100"><b>&bull;100</b></a> <a href="#pyweb101">101</a> <a href="#pyweb102">102</a></dd>
<dt>genReferences</dt><dd><a href="#pyweb59"><b>&bull;59</b></a> <a href="#pyweb102">102</a></dd>
<dt>getUserIDRefs</dt><dd><a href="#pyweb57"><b>&bull;57</b></a> <a href="#pyweb64">64</a> <a href="#pyweb107">107</a></dd>
<dt>getchunk</dt><dd><a href="#pyweb86">86</a> <a href="#pyweb101"><b>&bull;101</b></a> <a href="#pyweb102">102</a> <a href="#pyweb110">110</a> <a href="#pyweb111">111</a></dd>
<dt>handleCommand</dt><dd><a href="#pyweb116"><b>&bull;116</b></a> <a href="#pyweb128">128</a></dd>
<dt>language</dt><dd><a href="#pyweb109"><b>&bull;109</b></a> <a href="#pyweb140">140</a> <a href="#pyweb154">154</a> <a href="#pyweb169">169</a></dd>
<dt>lineNumber</dt><dd><a href="#pyweb18">18</a> <a href="#pyweb19">19</a> <a href="#pyweb33">33</a> <a href="#pyweb35">35</a> <a href="#pyweb45">45</a> <a href="#pyweb54">54</a> <a href="#pyweb56">56</a> <a href="#pyweb57"><b>&bull;57</b></a> <a href="#pyweb63">63</a> <a href="#pyweb67">67</a> <a href="#pyweb72">72</a> <a href="#pyweb76">76</a> <a href="#pyweb79">79</a> <a href="#pyweb81">81</a> <a href="#pyweb85">85</a> <a href="#pyweb112">112</a> <a href="#pyweb114">114</a> <a href="#pyweb115">115</a> <a href="#pyweb123">123</a> <a href="#pyweb125">125</a> <a href="#pyweb126">126</a> <a href="#pyweb127">127</a> <a href="#pyweb128">128</a> <a href="#pyweb129">129</a> <a href="#pyweb165">165</a></dd>
<dt>load</dt><dd><a href="#pyweb121">121</a> <a href="#pyweb128"><b>&bull;128</b></a> <a href="#pyweb146">146</a> <a href="#pyweb158">158</a> <a href="#pyweb162">162</a> <a href="#pyweb166">166</a></dd>
<dt>location</dt><dd><a href="#pyweb115"><b>&bull;115</b></a> <a href="#pyweb124">124</a> <a href="#pyweb126">126</a> <a href="#pyweb128">128</a></dd>
<dt>main</dt><dd><a href="#pyweb161"><b>&bull;161</b></a></dd>
<dt>makeContent</dt><dd><a href="#pyweb54">54</a> <a href="#pyweb56">56</a> <a href="#pyweb63"><b>&bull;63</b></a> <a href="#pyweb72">72</a></dd>
<dt>moreTokens</dt><dd><a href="#pyweb114"><b>&bull;114</b></a> <a href="#pyweb128">128</a></dd>
<dt>multi_reference</dt><dd><a href="#pyweb103">103</a> <a href="#pyweb104"><b>&bull;104</b></a></dd>
<dt>nextToken</dt><dd><a href="#pyweb114"><b>&bull;114</b></a> <a href="#pyweb119">119</a> <a href="#pyweb120">120</a> <a href="#pyweb121">121</a> <a href="#pyweb124">124</a> <a href="#pyweb125">125</a> <a href="#pyweb126">126</a> <a href="#pyweb128">128</a></dd>
<dt>no_definition</dt><dd><a href="#pyweb103">103</a> <a href="#pyweb104"><b>&bull;104</b></a></dd>
<dt>no_reference</dt><dd><a href="#pyweb103">103</a> <a href="#pyweb104"><b>&bull;104</b></a></dd>
<dt>open</dt><dd><a href="#pyweb4"><b>&bull;4</b></a> <a href="#pyweb14">14</a> <a href="#pyweb44">44</a> <a href="#pyweb49">49</a> <a href="#pyweb110">110</a> <a href="#pyweb111">111</a> <a href="#pyweb114">114</a> <a href="#pyweb121">121</a> <a href="#pyweb160">160</a></dd>
<dt>openSource</dt><dd><a href="#pyweb114"><b>&bull;114</b></a> <a href="#pyweb128">128</a></dd>
<dt>optparse</dt><dd><a href="#pyweb156"><b>&bull;156</b></a> <a href="#pyweb159">159</a></dd>
<dt>os</dt><dd><a href="#pyweb14">14</a> <a href="#pyweb50">50</a> <a href="#pyweb151"><b>&bull;151</b></a></dd>
<dt>parseArgs</dt><dd><a href="#pyweb159"><b>&bull;159</b></a> <a href="#pyweb161">161</a></dd>
<dt>perform</dt><dd><a href="#pyweb146"><b>&bull;146</b></a></dd>
<dt>process</dt><dd><a href="#pyweb126">126</a> <a href="#pyweb160"><b>&bull;160</b></a> <a href="#pyweb161">161</a></dd>
<dt>pushBack</dt><dd><a href="#pyweb114"><b>&bull;114</b></a> <a href="#pyweb121">121</a></dd>
<dt>quoted_chars</dt><dd><a href="#pyweb9">9</a> <a href="#pyweb15">15</a> <a href="#pyweb29">29</a> <a href="#pyweb38"><b>&bull;38</b></a></dd>
<dt>re</dt><dd><a href="#pyweb108">108</a> <a href="#pyweb114">114</a> <a href="#pyweb151"><b>&bull;151</b></a></dd>
<dt>ref</dt><dd><a href="#pyweb28">28</a> <a href="#pyweb59">59</a> <a href="#pyweb78"><b>&bull;78</b></a> <a href="#pyweb87">87</a></dd>
<dt>referenceTo</dt><dd><a href="#pyweb20">20</a> <a href="#pyweb21">21</a> <a href="#pyweb39"><b>&bull;39</b></a> <a href="#pyweb66">66</a></dd>
<dt>references</dt><dd><a href="#pyweb17"><b>&bull;17</b></a> <a href="#pyweb18">18</a> <a href="#pyweb19">19</a> <a href="#pyweb25">25</a> <a href="#pyweb32">32</a> <a href="#pyweb34">34</a> <a href="#pyweb36">36</a> <a href="#pyweb52">52</a> <a href="#pyweb59">59</a> <a href="#pyweb103">103</a> <a href="#pyweb124">124</a> <a href="#pyweb165">165</a></dd>
<dt>resetIndent</dt><dd><a href="#pyweb11"><b>&bull;11</b></a></dd>
<dt>resolve</dt><dd><a href="#pyweb67">67</a> <a href="#pyweb86"><b>&bull;86</b></a> <a href="#pyweb87">87</a> <a href="#pyweb88">88</a> <a href="#pyweb89">89</a> <a href="#pyweb101">101</a></dd>
<dt>searchForRE</dt><dd><a href="#pyweb57">57</a> <a href="#pyweb58">58</a> <a href="#pyweb77"><b>&bull;77</b></a> <a href="#pyweb79">79</a> <a href="#pyweb108">108</a></dd>
<dt>setIndent</dt><dd><a href="#pyweb11"><b>&bull;11</b></a> <a href="#pyweb66">66</a> <a href="#pyweb89">89</a></dd>
<dt>setUserIDRefs</dt><dd><a href="#pyweb64"><b>&bull;64</b></a> <a href="#pyweb124">124</a></dd>
<dt>shlex</dt><dd><a href="#pyweb118"><b>&bull;118</b></a> <a href="#pyweb119">119</a></dd>
<dt>startswith</dt><dd><a href="#pyweb57">57</a> <a href="#pyweb77"><b>&bull;77</b></a> <a href="#pyweb79">79</a> <a href="#pyweb100">100</a> <a href="#pyweb109">109</a> <a href="#pyweb128">128</a> <a href="#pyweb159">159</a></dd>
<dt>string</dt><dd><a href="#pyweb12"><b>&bull;12</b></a> <a href="#pyweb17">17</a> <a href="#pyweb18">18</a> <a href="#pyweb19">19</a> <a href="#pyweb20">20</a> <a href="#pyweb21">21</a> <a href="#pyweb22">22</a> <a href="#pyweb24">24</a> <a href="#pyweb25">25</a> <a href="#pyweb28">28</a> <a href="#pyweb30">30</a> <a href="#pyweb33">33</a> <a href="#pyweb34">34</a> <a href="#pyweb35">35</a> <a href="#pyweb36">36</a> <a href="#pyweb37">37</a> <a href="#pyweb39">39</a> <a href="#pyweb40">40</a> <a href="#pyweb41">41</a> <a href="#pyweb42">42</a> <a href="#pyweb164">164</a> <a href="#pyweb165">165</a></dd>
<dt>summary</dt><dd><a href="#pyweb134">134</a> <a href="#pyweb138">138</a> <a href="#pyweb141">141</a> <a href="#pyweb144">144</a> <a href="#pyweb147"><b>&bull;147</b></a> <a href="#pyweb160">160</a> <a href="#pyweb162">162</a> <a href="#pyweb166">166</a></dd>
<dt>sys</dt><dd><a href="#pyweb126">126</a> <a href="#pyweb151"><b>&bull;151</b></a> <a href="#pyweb161">161</a> <a href="#pyweb162">162</a> <a href="#pyweb164">164</a></dd>
<dt>tangle</dt><dd><a href="#pyweb45">45</a> <a href="#pyweb62">62</a> <a href="#pyweb67">67</a> <a href="#pyweb68">68</a> <a href="#pyweb71">71</a> <a href="#pyweb72">72</a> <a href="#pyweb74">74</a> <a href="#pyweb78"><b>&bull;78</b></a> <a href="#pyweb79">79</a> <a href="#pyweb80">80</a> <a href="#pyweb81">81</a> <a href="#pyweb89">89</a> <a href="#pyweb110">110</a> <a href="#pyweb143">143</a> <a href="#pyweb154">154</a> <a href="#pyweb158">158</a> <a href="#pyweb162">162</a> <a href="#pyweb169">169</a></dd>
<dt>tangleChunk</dt><dd><a href="#pyweb89">89</a> <a href="#pyweb110"><b>&bull;110</b></a></dd>
<dt>tempfile</dt><dd><a href="#pyweb47"><b>&bull;47</b></a> <a href="#pyweb49">49</a></dd>
<dt>time</dt><dd><a href="#pyweb133">133</a> <a href="#pyweb134">134</a> <a href="#pyweb151"><b>&bull;151</b></a></dd>
<dt>totalLines</dt><dd><a href="#pyweb3">3</a> <a href="#pyweb4">4</a> <a href="#pyweb112">112</a> <a href="#pyweb114"><b>&bull;114</b></a> <a href="#pyweb121">121</a> <a href="#pyweb147">147</a></dd>
<dt>usedBy</dt><dd><a href="#pyweb87"><b>&bull;87</b></a></dd>
<dt>userNamesXref</dt><dd><a href="#pyweb84">84</a> <a href="#pyweb106"><b>&bull;106</b></a></dd>
<dt>weave</dt><dd><a href="#pyweb61">61</a> <a href="#pyweb66">66</a> <a href="#pyweb70">70</a> <a href="#pyweb73">73</a> <a href="#pyweb78"><b>&bull;78</b></a> <a href="#pyweb79">79</a> <a href="#pyweb80">80</a> <a href="#pyweb82">82</a> <a href="#pyweb83">83</a> <a href="#pyweb84">84</a> <a href="#pyweb88">88</a> <a href="#pyweb111">111</a> <a href="#pyweb140">140</a> <a href="#pyweb154">154</a> <a href="#pyweb158">158</a> <a href="#pyweb164">164</a> <a href="#pyweb166">166</a> <a href="#pyweb169">169</a></dd>
<dt>weaveChunk</dt><dd><a href="#pyweb88">88</a> <a href="#pyweb111"><b>&bull;111</b></a></dd>
<dt>weaveReferenceTo</dt><dd><a href="#pyweb61"><b>&bull;61</b></a> <a href="#pyweb66">66</a> <a href="#pyweb73">73</a> <a href="#pyweb111">111</a></dd>
<dt>weaveShortReferenceTo</dt><dd><a href="#pyweb61"><b>&bull;61</b></a> <a href="#pyweb66">66</a> <a href="#pyweb73">73</a> <a href="#pyweb111">111</a></dd>
<dt>webAdd</dt><dd><a href="#pyweb55">55</a> <a href="#pyweb65">65</a> <a href="#pyweb69"><b>&bull;69</b></a> <a href="#pyweb119">119</a> <a href="#pyweb120">120</a> <a href="#pyweb121">121</a> <a href="#pyweb122">122</a> <a href="#pyweb128">128</a></dd>
<dt>write</dt><dd><a href="#pyweb4"><b>&bull;4</b></a> <a href="#pyweb8">8</a> <a href="#pyweb10">10</a> <a href="#pyweb14">14</a> <a href="#pyweb18">18</a> <a href="#pyweb19">19</a> <a href="#pyweb21">21</a> <a href="#pyweb22">22</a> <a href="#pyweb44">44</a> <a href="#pyweb45">45</a> <a href="#pyweb79">79</a></dd>
<dt>xrefDefLine</dt><dd><a href="#pyweb22">22</a> <a href="#pyweb41"><b>&bull;41</b></a> <a href="#pyweb84">84</a></dd>
<dt>xrefFoot</dt><dd><a href="#pyweb21">21</a> <a href="#pyweb40"><b>&bull;40</b></a> <a href="#pyweb81">81</a> <a href="#pyweb84">84</a></dd>
<dt>xrefHead</dt><dd><a href="#pyweb21">21</a> <a href="#pyweb40"><b>&bull;40</b></a> <a href="#pyweb81">81</a> <a href="#pyweb84">84</a></dd>
<dt>xrefLine</dt><dd><a href="#pyweb21">21</a> <a href="#pyweb40"><b>&bull;40</b></a> <a href="#pyweb81">81</a></dd>
</dl>

</div>

<hr />
<p><small>Created by /Users/slott/Documents/Projects/pyWeb-2.1/pyweb/pyweb.py at Mon Mar  1 07:58:19 2010.</small></p>
<p><small>pyweb.__version__ '$Revision$'.</small></p>
<p><small>Source pyweb.w modified Sat Feb 27 07:18:21 2010.
</small></p>
<p><small>Working directory '/Users/slott/Documents/Projects/pyWeb-2.1/pyweb'.</small></p>

</div>
</body>
</html>
