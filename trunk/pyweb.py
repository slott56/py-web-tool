#!/usr/bin/env python
from __future__ import print_function
"""pyWeb Literate Programming - tangle and weave tool.

Yet another simple literate programming tool derived from nuweb, 
implemented entirely in Python.  
This produces any markup for any programming language.

Usage:
    pyweb.py [-dvs] [-c x] [-w format] file.w

Options:
    -v           verbose output (the default)
    -s           silent output
    -d           debugging output
    -c x         change the command character from '@' to x
    -w format    Use the given weaver for the final document.
                 The default is based on the input file, a leading '<'
                 indicates HTML, otherwise LaTeX.
                 choices are 'html', 'latex', 'rst'.
    -xw          Exclude weaving
    -xt          Exclude tangling
    -pi          Permit include-command errors
    
    file.w       The input file, with @o, @d, @i, @[, @{, @|, @<, @f, @m, @u commands.
"""
__version__ = """$Revision$"""

### DO NOT EDIT THIS FILE!
### It was created by /Users/slott/Documents/Projects/pyWeb-2.1/pyweb/pyweb.py, __version__='$Revision$'.
### From source pyweb.w modified Sat Feb 27 07:18:21 2010.
### In working directory '/Users/slott/Documents/Projects/pyWeb-2.1/pyweb'.

import string
import tempfile
import filecmp
import shlex
import sys
import os
import re
import time
import optparse



class Error( Exception ): pass



class Command( object ):
    """A Command is the lowest level of granularity in the input stream."""
    def __init__( self, fromLine=0 ):
        self.lineNumber= fromLine
        self.chunk= None
    def __str__( self ):
        return "at %r" % self.lineNumber
        
    def startswith( self, prefix ):
        return None
    def searchForRE( self, rePat ):
        return None
    def indent( self ):
        return None

        
    def ref( self, aWeb ):
        return None
    def weave( self, aWeb, aWeaver ):
        pass
    def tangle( self, aWeb, aTangler ):
        pass



class TextCommand( Command ):
    """A piece of document source text."""
    def __init__( self, text, fromLine=0 ):
        super( TextCommand, self ).__init__( fromLine )
        self.text= text
    def __str__( self ):
        return "at %r: %r..." % (self.lineNumber,self.text[:32])
    def startswith( self, prefix ):
        return self.text.startswith( prefix )
    def searchForRE( self, rePat ):
        return rePat.search( self.text )
    def indent( self ):
        if self.text.endswith('\n'):
            return 0
        try:
            last_line = self.text.splitlines()[-1]
            return len(last_line)
        except IndexError:
            return 0
    def weave( self, aWeb, aWeaver ):
        aWeaver.write( self.text )
    def tangle( self, aWeb, aTangler ):
        aTangler.write( self.text )


class CodeCommand( TextCommand ):
    """A piece of program source code."""
    def weave( self, aWeb, aWeaver ):
        aWeaver.codeBlock( aWeaver.quote( self.text ) )
    def tangle( self, aWeb, aTangler ):
        aTangler.codeBlock( self.text )


class XrefCommand( Command ):
    """Any of the Xref-goes-here commands in the input."""
    def __str__( self ):
        return "at %r: cross reference" % (self.lineNumber)
    def formatXref( self, xref, aWeaver ):
        aWeaver.xrefHead()
        for n in sorted(xref):
            aWeaver.xrefLine( n, xref[n] )
        aWeaver.xrefFoot()
    def tangle( self, aWeb, aTangler ):
        raise Error('Illegal tangling of a cross reference command.')


class FileXrefCommand( XrefCommand ):
    """A FileXref command."""
    def weave( self, aWeb, aWeaver ):
        """Weave a File Xref from @o commands."""
        self.formatXref( aWeb.fileXref(), aWeaver )


class MacroXrefCommand( XrefCommand ):
    """A MacroXref command."""
    def weave( self, aWeb, aWeaver ):
        """Weave the Macro Xref from @d commands."""
        self.formatXref( aWeb.chunkXref(), aWeaver )


class UserIdXrefCommand( XrefCommand ):
    """A UserIdXref command."""
    def weave( self, aWeb, aWeaver ):
        """Weave a user identifier Xref from @d commands."""
        ux= aWeb.userNamesXref()
        aWeaver.xrefHead()
        for u in sorted(ux):
            defn, refList= ux[u]
            aWeaver.xrefDefLine( u, defn, refList )
        aWeaver.xrefFoot()


class ReferenceCommand( Command ):
    """A reference to a named chunk, via @<name@>."""
    def __init__( self, refTo, fromLine=0 ):
        Command.__init__( self, fromLine )
        self.refTo= refTo
        self.fullname= None
        self.sequenceList= None
        self.chunkList= []
    def __str__( self ):
        return "at %r: reference to chunk %r" % (self.lineNumber,self.refTo)
        
    def resolve( self, aWeb ):
        """Expand the referenced chunk name into a full name and list of parts"""
        self.fullName= aWeb.fullNameFor( self.refTo )
        self.chunkList= [ c.seq for c in aWeb.getchunk( self.refTo ) ]

        
    def ref( self, aWeb ):
        """Find and return the full name for this reference."""
        self.resolve( aWeb )
        return self.fullName

        
    def weave( self, aWeb, aWeaver ):
        """Create the nicely formatted reference to a chunk of code."""
        self.resolve( aWeb )
        aWeb.weaveChunk( self.fullName, aWeaver )

        
    def tangle( self, aWeb, aTangler ):
        """Create source code."""
        self.resolve( aWeb )
        # Update indent based on last line of previous command. 
        if self.chunk is None or self.chunk.previous_command is None:
            logger.error( "Command disconnected from Chunk." )
            raise Error( "Serious problem in WebReader." )
        logger.debug( "Indent %s + %r", aTangler.context, self.chunk.previous_command.indent() )
        aTangler.setIndent( command=self.chunk.previous_command )
        aWeb.tangleChunk( self.fullName, aTangler )
        aTangler.clrIndent()





class Chunk( object ):
    """Anonymous piece of input file: will be output through the weaver only."""
    # construction and insertion into the web
    def __init__( self ):
        self.commands= [ ] # The list of children of this chunk
        self.user_id_list= None
        self.initial= None
        self.name= ''
        self.fullName= None
        self.seq= None
        self.referencedBy= [] # Chunks which reference this chunk.  Ideally just one.
        self.references= [] # Names that this chunk references
        
        self.reference_style= None # Instance of Reference 
        
        self._lastCommand= None
    def __str__( self ):
        return "\n".join( map( str, self.commands ) )
    def __repr__( self ):
        return "%s('%s')" % ( self.__class__.__name__, self.name )
        
    def append( self, command ):
        """Add another Command to this chunk."""
        self.commands.append( command )
        command.chunk= self

        
    def appendText( self, text, lineNumber=0 ):
        """Append a single character to the most recent TextCommand."""
        try:
            # Works for TextCommand, otherwise breaks
            self.commands[-1].text += text
        except IndexError, e:
            # First command?  Then the list will have been empty.
            self.commands.append( self.makeContent(text,lineNumber) )
        except AttributeError, e:
            # Not a TextCommand?  Then there won't be a text attribute.
            self.commands.append( self.makeContent(text,lineNumber) )
        self._lastCommand= self.commands[-1]

        
    def webAdd( self, web ):
        """Add self to a Web as anonymous chunk."""
        web.add( self )

        
    def genReferences( self, aWeb ):
        """Generate references from this Chunk."""
        try:
            for t in self.commands:
                ref= t.ref( aWeb )
                if ref is not None:
                    yield ref
        except Error,e:
            raise Error,e.args+(self,)

        
    def makeContent( self, text, lineNumber=0 ):
        return TextCommand( text, lineNumber )

        
    def startswith( self, prefix ):
        """Examine the first command's starting text."""
        return len(self.commands) >= 1 and self.commands[0].startswith( prefix )
    def searchForRE( self, rePat ):
        """Visit each command, applying the pattern."""
                
        for c in self.commands:
            if c.searchForRE( rePat ):
                return self
        return None
    
    @property
    def lineNumber( self ):
        """Return the first command's line number or None."""
        return self.commands[0].lineNumber if len(self.commands) >= 1 else None
    def getUserIDRefs( self ):
        return []

        
    @property
    def references_list( self ):
        """This should return chunks themselves, not (name,seq) pairs."""
        return self.reference_style.chunkReferencedBy( self )

        
    def weave( self, aWeb, aWeaver ):
        """Create the nicely formatted document from an anonymous chunk."""
        aWeaver.docBegin( self )
        try:
            for t in self.commands:
                t.weave( aWeb, aWeaver )
        except Error, e:
            raise Error,e.args+(self,)
        aWeaver.docEnd( self )
    def weaveReferenceTo( self, aWeb, aWeaver ):
        """Create a reference to this chunk -- except for anonymous chunks."""
        raise Exception( "Cannot reference an anonymous chunk.""")
    def weaveShortReferenceTo( self, aWeb, aWeaver ):
        """Create a short reference to this chunk -- except for anonymous chunks."""
        raise Exception( "Cannot reference an anonymous chunk.""")

        
    def tangle( self, aWeb, aTangler ):
        """Create source code -- except anonymous chunks should not be tangled"""
        raise Error( 'Cannot tangle an anonymous chunk', self )



class NamedChunk( Chunk ):
    """Named piece of input file: will be output as both tangler and weaver."""
    def __init__( self, name ):
        Chunk.__init__( self )
        self.name= name
        self.user_id_list= []
        self.refCount= 0
    def __str__( self ):
        return "%r: %s" % ( self.name, Chunk.__str__(self) )
    def makeContent( self, text, lineNumber=0 ):
        return CodeCommand( text, lineNumber )
        
    def setUserIDRefs( self, text ):
        """Save user ID's associated with this chunk."""
        self.user_id_list= text.split()
    def getUserIDRefs( self ):
        return self.user_id_list

        
    def webAdd( self, web ):
        """Add self to a Web as named chunk, update xrefs."""
        web.addNamed( self )

        
    def weave( self, aWeb, aWeaver ):
        """Create the nicely formatted document from a chunk of code."""
        # format as <pre> in a different-colored box
        self.fullName= aWeb.fullNameFor( self.name )
        aWeaver.codeBegin( self )
        aWeaver.setIndent( aWeaver.code_indent )
        for t in self.commands:
            try:
                t.weave( aWeb, aWeaver )
            except Error,e:
                raise Error,e.args+(self,)
        aWeaver.clrIndent( )
        aWeaver.codeEnd( self )
    def weaveReferenceTo( self, aWeb, aWeaver ):
        """Create a reference to this chunk."""
        self.fullName= aWeb.fullNameFor( self.name )
        txt= aWeaver.referenceTo( self.fullName, self.seq )
        aWeaver.codeBlock( txt )
    def weaveShortReferenceTo( self, aWeb, aWeaver ):
        """Create a shortened reference to this chunk."""
        txt= aWeaver.referenceTo( None, self.seq )
        aWeaver.codeBlock( txt )

        
    def tangle( self, aWeb, aTangler ):
        """Create source code."""
        # use aWeb to resolve @<namedChunk@>
        # format as correctly indented source text
        self.previous_command= TextCommand( "", self.commands[0].lineNumber )
        aTangler.codeBegin( self )
        for t in self.commands:
            try:
                t.tangle( aWeb, aTangler )
            except Error,e:
                raise Error,e.args+(self,)
            self.previous_command= t
        aTangler.codeEnd( self )



class OutputChunk( NamedChunk ):
    """Named piece of input file, defines an output tangle."""
    def __init__( self, name, comment_start="", comment_end="" ):
        super( OutputChunk, self ).__init__( name )
        self.comment_start= comment_start
        self.comment_end= comment_end
        
    def webAdd( self, web ):
        """Add self to a Web as output chunk, update xrefs."""
        web.addOutput( self )

        
    def weave( self, aWeb, aWeaver ):
        """Create the nicely formatted document from a chunk of code."""
        # format as <pre> in a different-colored box
        self.fullName= aWeb.fullNameFor( self.name )
        aWeaver.fileBegin( self )
        try:
            for t in self.commands:
                t.weave( aWeb, aWeaver )
        except Error,e:
            raise Error,e.args+(self,)
        aWeaver.fileEnd( self )

        
    def tangle( self, aWeb, aTangler ):
        aTangler.comment_start= self.comment_start
        aTangler.comment_end= self.comment_end
        super( OutputChunk, self ).tangle( aWeb, aTangler )



class NamedDocumentChunk( NamedChunk ):
    """Named piece of input file with document source, defines an output tangle."""
    def makeContent( self, text, lineNumber=0 ):
        return TextCommand( text, lineNumber )
        
    def weave( self, aWeb, aWeaver ):
        """Ignore this when producing the document."""
        pass
    def weaveReferenceTo( self, aWeb, aWeaver ):
        """On a reference to this chunk, expand the body in place."""
        try:
            for t in self.commands:
                t.weave( aWeb, aWeaver )
        except Error,e:
            raise Error,e.args+(self,)
    def weaveShortReferenceTo( self, aWeb, aWeaver ):
        """On a reference to this chunk, expand the body in place."""
        self.weaveReferenceTo( aWeb, aWeaver )

        
    def tangle( self, aWeb, aTangler ):
        """Raise an exception on an attempt to tangle."""
        raise Error( "Cannot tangle a chunk defined with @[.""" )




class Web( object ):
    """The overall Web of chunks."""
    def __init__( self, name ):
        self.webFileName= name
        self.chunkSeq= [] 
        self.output= {} # Map filename to Chunk
        self.named= {} # Map chunkname to Chunk
        self.sequence= 0
        self.reference_style = TransitiveReference(self)
    def __str__( self ):
        return "Web %r" % ( self.webFileName, )
        
    
    def addDefName( self, name ):
        """Reference to or definition of a chunk name."""
        nm= self.fullNameFor( name )
        if nm is None: return None
        if nm[-3:] == '...':
            logger.debug( "Abbreviated reference %r", name )
            return None # first occurance is a forward reference using an abbreviation
        if nm not in self.named:
            self.named[nm]= []
            logger.debug( "Adding empty chunk %r", name )
        return nm
    
    
    def add( self, chunk ):
        """Add an anonymous chunk."""
        self.chunkSeq.append( chunk )
    
    
    def addNamed( self, chunk ):
        """Add a named chunk to a sequence with a given name."""
        chunk.reference_style= self.reference_style
        self.chunkSeq.append( chunk )
        nm= self.addDefName( chunk.name )
        if nm:
            # We found the full name for this chunk
            self.sequence += 1
            chunk.seq= self.sequence
            chunk.fullName= nm
            self.named[nm].append( chunk )
            chunk.initial= len(self.named[nm]) == 1
            logger.debug( "Extending chunk %r from %r", nm, chunk.name )
        else:
            raise Error("No full name for %r" % chunk.name, chunk)
    
    
    def addOutput( self, chunk ):
        """Add an output chunk to a sequence with a given name."""
        chunk.reference_style= self.reference_style
        self.chunkSeq.append( chunk )
        if chunk.name not in self.output:
            self.output[chunk.name] = []
            logger.debug( "Adding chunk %r", chunk.name )
        self.sequence += 1
        chunk.seq= self.sequence
        chunk.fullName= chunk.name
        self.output[chunk.name].append( chunk )
        chunk.initial = len(self.output[chunk.name]) == 1
    

        
    def fullNameFor( self, name ):
        """Resolve "..." names into the full name."""
        if name in self.named: return name
        if name[-3:] == '...':
            best= [ n for n in self.named.keys()
                if n.startswith( name[:-3] ) ]
            if len(best) > 1:
                raise Error("Ambiguous abbreviation %r, matches %r" % ( name, best ) )
            elif len(best) == 1: 
                return best[0]
        return name
    
    def getchunk( self, name ):
        """Locate a named sequence of chunks."""
        nm= self.fullNameFor( name )
        if nm in self.named:
            return self.named[nm]
        raise Error( "Cannot resolve %r in %r" % (name,self.named.keys()) )

        
    def createUsedBy( self ):
        """Update every piece of a Chunk to show how the chunk is referenced.
        Each piece can then report where it's used in the web.
        """
        for aChunk in self.chunkSeq:
            #usage = (self.fullNameFor(aChunk.name), aChunk.seq)
            for aRefName in aChunk.genReferences( self ):
                for c in self.getchunk( aRefName ):
                    c.referencedBy.append( aChunk )
                    c.refCount += 1
                
        for nm in self.no_reference():
            logger.warn( "No reference to %r", nm )
        for nm in self.multi_reference():
            logger.warn( "Multiple references to %r", nm )
        for nm in self.no_definition():
            logger.warn( "No definition for %r", nm )
    
    
    def no_reference( self ):
        return [ nm for nm,cl in self.named.items() if len(cl)>0 and cl[0].refCount == 0 ]
    def multi_reference( self ):
        return [ nm for nm,cl in self.named.items() if len(cl)>0 and cl[0].refCount > 1 ]
    def no_definition( self ):
        return [ nm for nm,cl in self.named.items() if len(cl) == 0 ] 
    
    def fileXref( self ):
        fx= {}
        for f,cList in self.output.items():
            fx[f]= [ c.seq for c in cList ]
        return fx
    def chunkXref( self ):
        mx= {}
        for n,cList in self.named.items():
            mx[n]= [ c.seq for c in cList ]
        return mx
    
    def userNamesXref( self ):
        ux= {}
        self._gatherUserId( self.named, ux )
        self._gatherUserId( self.output, ux )
        self._updateUserId( self.named, ux )
        self._updateUserId( self.output, ux )
        return ux
    def _gatherUserId( self, chunkMap, ux ):
                
        for n,cList in chunkMap.items():
            for c in cList:
                for id in c.getUserIDRefs():
                    ux[id]= ( c.seq, [] )
    
    def _updateUserId( self, chunkMap, ux ):
                
        # examine source for occurances of all names in ux.keys()
        for id in ux.keys():
            logger.debug( "References to %r", id )
            idpat= re.compile( r'\W%s\W' % id )
            for n,cList in chunkMap.items():
                for c in cList:
                    if c.seq != ux[id][0] and c.searchForRE( idpat ):
                        ux[id][1].append( c.seq )
    

        
    def language( self, preferredWeaverClass=None ):
        """Construct a weaver appropriate to the document's language"""
        if preferredWeaverClass:
            return preferredWeaverClass()
        if self.chunkSeq[0].startswith('<'): return HTML()
        if self.chunkSeq[0].startswith('%') or self.chunkSeq[0].startswith('\\'):  return LaTeX()
        return Weaver()

        
    def tangle( self, aTangler ):
        for f,c in self.output.items():
            aTangler.open( f )
            for p in c:
                p.tangle( self, aTangler )
            aTangler.close()
    def tangleChunk( self, name, aTangler ):
        logger.debug( "Tangling chunk %r", name )
        chunkList= self.getchunk(name)
        if len(chunkList) == 0:
            raise Error( "Attempt to tangle an undefined Chunk, %s." % ( name, ) )
        for p in chunkList:
            p.tangle( self, aTangler )

        
    def weave( self, aWeaver ):
        aWeaver.open( self.webFileName )
        for c in self.chunkSeq:
            c.weave( self, aWeaver )
        aWeaver.close()
    def weaveChunk( self, name, aWeaver ):
        logger.debug( "Weaving chunk %r", name )
        chunkList= self.getchunk(name)
        if not chunkList:
            raise Error( "No Definition for %s", name )
        chunkList[0].weaveReferenceTo( self, aWeaver )
        for p in chunkList[1:]:
            p.weaveShortReferenceTo( self, aWeaver )




class Emitter( object ):
    """Emit an output file; handling indentation context."""
    def __init__( self ):
        self.fileName= ""
        self.theFile= None
        self.context= [0]
        self.indent= 0
        self.lastIndent= 0
        self.linesWritten= 0
        self.totalFiles= 0
        self.totalLines= 0
        self.log_indent= logging.getLogger( "pyweb.%s.indent" % self.__class__.__name__ )
    def __str__( self ):
        return self.__class__.__name__
        
    def open( self, aFile ):
        """Open a file."""
        self.fileName= aFile
        self.doOpen( aFile )
        self.linesWritten= 0
    
    def doOpen( self, aFile ):
        self.fileName= aFile
        logger.debug( "creating %r", self.fileName )
    
    def close( self ):
        self.codeFinish()
        self.doClose()
        self.totalFiles += 1
        self.totalLines += self.linesWritten
    
    def doClose( self ):
        logger.debug( "wrote %d lines to %s",
            self.linesWritten, self.fileName )
    
    def write( self, text ):
        if text is None: return
        self.linesWritten += text.count('\n')
        self.doWrite( text )
    
    def doWrite( self, text ):
        print( text, end=None )
    

        
    def codeBlock( self, text ):
        """Indented write of a block of code."""
        self.indent= self.context[-1]
        lines= text.split( '\n' )
        for l in lines[:-1]:
            self.write( '%s%s\n' % (self.indent*' ',l) )
        if lines[-1]:
            self.write( '%s%s' % (self.indent*' ',lines[-1]) )
        self.lastIndent= len(lines[-1]) + self.indent
    
    quoted_chars = [
        # Must be empty for tangling to work.
    ]
    
    def quote( self, aLine ):
        """Each individual line of code; often overridden by weavers to quote the code."""
        clean= aLine
        for from_, to_ in self.quoted_chars:
            clean= clean.replace( from_, to_ )
        return clean
    
    def codeFinish( self ):
        if self.lastIndent > 0:
            self.write('\n')

        
    def setIndent( self, fixed=None, command=None ):
        """Either use a fixed indent (for weaving) or the previous command (for tangling)."""
        self.context.append( self.context[-1]+command.indent() if fixed is None else fixed )
        self.log_indent.debug( "setIndent %s: %r", fixed, self.context )
    def clrIndent( self ):
        if len(self.context) > 1:
            self.context.pop()
        self.indent= self.context[-1]
        self.log_indent.debug( "clrIndent %r", self.context )
    def resetIndent( self ):
        self.context= [0]
        self.log_indent.debug( "resetIndent %r", self.context )



class Weaver( Emitter ):
    """Format various types of XRef's and code blocks when weaving."""
    extension= ".rst" # A subclass will provide their preferred extension
    code_indent= 4
        
    def doOpen( self, aFile ):
        src, _ = os.path.splitext( aFile )
        self.fileName= src + self.extension
        self.theFile= open( self.fileName, "w" )
        logger.info( "Weaving %r", self.fileName )
    def doClose( self ):
        self.theFile.close()
        logger.info( "Wrote %d lines to %r", 
            self.linesWritten, self.fileName )
    def doWrite( self, text ):
        self.theFile.write( text )

    
    # Template Expansions.
        
    quoted_chars = [
        # prevent some RST markup from being recognized
        ('`',r'\`'),
        ('_',r'\_'), 
        ('*',r'\*'),
        ('|',r'\|'),
    ]

        
    def docBegin( self, aChunk ):
        pass
    def docEnd( self, aChunk ):
        pass

        
    ref_template = string.Template( "\nUsed by: ${refList}\n" )
    ref_item_template = string.Template( "$fullName (`${seq}`_)" )
    def references( self, aChunk ):
        if aChunk.references_list:
            refList= [ 
                self.ref_item_template.substitute( seq=s, fullName=n )
                for n,s in aChunk.references_list ]
            return self.ref_template.substitute( refList="; ".join( refList ) ) # HTML Separator
        return ""

        
    cb_template = string.Template( "\n..  _`${seq}`:\n..  rubric:: ${fullName} (${seq})\n..  parsed-literal::\n    " )
    def codeBegin( self, aChunk ):
        tex = self.cb_template.substitute( 
            seq= aChunk.seq,
            lineNumber= aChunk.lineNumber, 
            fullName= aChunk.fullName,
            concat= "=" if aChunk.initial else "+=", # LaTeX Separator
        )
        self.write( tex )
    ce_template = string.Template( "\n${references}\n" )
    def codeEnd( self, aChunk ):
        tex = self.ce_template.substitute( 
            seq= aChunk.seq,
            lineNumber= aChunk.lineNumber, 
            fullName= aChunk.fullName,
            references= self.references( aChunk ),
        )
        self.write(tex)

        
    fb_template = string.Template( "\n..  _`${seq}`:\n..  rubric:: ${fullName} (${seq})\n..  parsed-literal::\n    " )
    def fileBegin( self, aChunk ):
        txt= self.fb_template.substitute(
            seq= aChunk.seq, 
            lineNumber= aChunk.lineNumber, 
            fullName= aChunk.fullName,
            concat= "=" if aChunk.initial else "+=", # HTML Separator
        )
        self.write( txt )
    fe_template= string.Template( "\n${references}\n" )
    def fileEnd( self, aChunk ):
        txt= self.fe_template.substitute(
            seq= aChunk.seq, 
            lineNumber= aChunk.lineNumber, 
            fullName= aChunk.fullName,
            references= self.references( aChunk ) )
        self.write( txt )

        
    refto_name_template= string.Template("""|srarr| ${fullName} (`${seq}`_)""")
    refto_seq_template= string.Template("""|srarr| (`${seq}`_)""")
    def referenceTo( self, aName, seq ):
        """Weave a reference to a chunk."""
        # Provide name to get a full reference.
        # Omit name to get a short reference.
        if aName:
            return self.refto_name_template.substitute( fullName= aName, seq= seq )
        else:
            return self.refto_seq_template.substitute( seq= seq )

        
    xref_head_template = string.Template( "\n" )
    xref_foot_template = string.Template( "\n" )
    xref_item_template = string.Template( ":${fullName}:\n    ${refList}\n" )
    def xrefHead( self ):
        txt = self.xref_head_template.substitute()
        self.write( txt )
    def xrefFoot( self ):
        txt = self.xref_foot_template.substitute()
        self.write( txt )
    def xrefLine( self, name, refList ):
        refList= [ self.referenceTo( None, r ) for r in refList ]
        txt= self.xref_item_template.substitute( fullName= name, refList = " ".join(refList) ) # HTML Separator
        self.write( txt )
    
    name_def_template = string.Template( '[`${seq}`_]' )
    name_ref_template = string.Template( '`${seq}`_' )
    def xrefDefLine( self, name, defn, refList ):
        templates = { defn: self.name_def_template }
        refTxt= [ templates.get(r,self.name_ref_template).substitute( seq= r )
            for r in sorted( refList + [defn] ) 
            ]
        txt= self.xref_item_template.substitute( fullName= name, refList = " ".join(refTxt) ) # HTML Separator
        self.write( txt )



class LaTeX( Weaver ):
    """LaTeX formatting for XRef's and code blocks when weaving.
    Requires \\usepackage{fancyvrb}
    """
    extension= ".tex"
    code_indent= 0
        
    cb_template = string.Template( """\\label{pyweb${seq}}
    \\begin{flushleft}
    \\textit{Code example ${fullName} (${seq})}
    \\begin{Verbatim}[commandchars=\\\\\\{\\},codes={\\catcode`$$=3\\catcode`^=7},frame=single]\n""") # Prevent indent

        
    ce_template= string.Template("""
    \\end{Verbatim}
    ${references}
    \\end{flushleft}\n""") # Prevent indentation

        
    fb_template= cb_template

        
    fe_template= ce_template

        
    ref_item_template = string.Template( """
    \\item Code example ${fullName} (${seq}) (Sect. \\ref{pyweb${seq}}, p. \\pageref{pyweb${seq}})\n""")
    ref_template = string.Template( """
    \\footnotesize
    Used by:
    \\begin{list}{}{}
    ${refList}
    \\end{list}
    \\normalsize\n""")

        
    quoted_chars = [
        ("\\end{Verbatim}", "\\end\,{Verbatim}"), # Allow \end{Verbatim}
        ("\\{","\\\,{"), # Prevent unexpected commands in Verbatim
        ("$","\\$"), # Prevent unexpected math in Verbatim
    ]

        
    refto_name_template= string.Template("""$$\\triangleright$$ Code Example ${fullName} (${seq})""")
    refto_seq_template= string.Template("""(${seq})""")



class HTML( Weaver ):
    """HTML formatting for XRef's and code blocks when weaving."""
    extension= ".html"
    code_indent= 0
        
    cb_template= string.Template("""
    <a name="pyweb${seq}"></a>
    <!--line number ${lineNumber}-->
    <p><em>${fullName}</em> (${seq})&nbsp;${concat}</p>
    <code><pre>\n""")

        
    ce_template= string.Template("""
    </pre></code>
    <p>&loz; <em>${fullName}</em> (${seq}).
    ${references}
    </p>\n""")

        
    fb_template= string.Template("""<a name="pyweb${seq}"></a>
    <!--line number ${lineNumber}-->
    <p><tt>${fullName}</tt> (${seq})&nbsp;${concat}</p>
    <code><pre>\n""") # Prevent indent

        
    fe_template= string.Template( """</pre></code>
    <p>&loz; <tt>${fullName}</tt> (${seq}).
    ${references}
    </p>\n""")

        
    ref_item_template = string.Template(
    '<a href="#pyweb${seq}"><em>${fullName}</em>&nbsp;(${seq})</a>'
    )
    ref_template = string.Template( '  Used by ${refList}.'  )

        
    quoted_chars = [
        ("&", "&amp;"), # Must be first
        ("<", "&lt;"),
        (">", "&gt;"),
        ('"', "&quot;"),
    ]

        
    refto_name_template = string.Template(
    '<a href="#pyweb${seq}">&rarr;<em>${fullName}</em> (${seq})</a>'
    )
    refto_seq_template = string.Template(
    '<a href="#pyweb${seq}">(${seq})</a>'
    )

        
    xref_head_template = string.Template( "<dl>\n" )
    xref_foot_template = string.Template( "</dl>\n" )
    xref_item_template = string.Template( "<dt>${fullName}</dt><dd>${refList}</dd>\n" )
    
    name_def_template = string.Template( '<a href="#pyweb${seq}"><b>&bull;${seq}</b></a>' )
    name_ref_template = string.Template( '<a href="#pyweb${seq}">${seq}</a>' )
    


class HTMLShort( HTML ):
    """HTML formatting for XRef's and code blocks when weaving with short references."""
        
    ref_item_template = string.Template( '<a href="#pyweb${seq}">(${seq})</a>' )



class Tangler( Emitter ):
    """Tangle output files."""
    def __init__( self ):
        super( Tangler, self ).__init__()
        self.comment_start= ""
        self.comment_end= ""
        self.debug= False
        
    def doOpen( self, aFile ):
        self.fileName= aFile
        self.theFile= open( aFile, "w" )
        logger.info( "Tangling %r", aFile )
    def doClose( self ):
        self.theFile.close()
        logger.info( "Wrote %d lines to %r",
            self.linesWritten, self.fileName )
    def doWrite( self, text ):
        self.theFile.write( text )

        
    def codeBegin( self, aChunk ):
        self.log_indent.debug( "<tangle %s:", aChunk.fullName )
        if self.debug:
            self.write( "\n%s %s (%d) -- %s %s\n" % ( 
                self.comment_start, aChunk.fullName, aChunk.seq, aChunk.lineNumber, self.comment_end ) )

        
    def codeEnd( self, aChunk ):
        self.log_indent.debug( ">%s", aChunk.fullName )



class TanglerMake( Tangler ):
    """Tangle output files, leaving files untouched if there are no changes."""
    def __init__( self ):
        Tangler.__init__( self )
        self.tempname= None
        
    def doOpen( self, aFile ):
        self.tempname= tempfile.mktemp()
        self.theFile= open( self.tempname, "w" )
        logger.info( "Tangling %r", aFile )

        
    def doClose( self ):
        self.theFile.close()
        try:
            same= filecmp.cmp( self.tempname, self.fileName )
        except OSError,e:
            same= 0
        if same:
            logger.info( "No change to %r", self.fileName )
            os.remove( self.tempname )
        else:
            # note the Windows requires the original file name be removed first
            try: 
                os.remove( self.fileName )
            except OSError,e:
                pass
            os.rename( self.tempname, self.fileName )
            logger.info( "Wrote %d lines to %r",
                self.linesWritten, self.fileName )




class Reference( object ):
    def __init__( self, aWeb ):
        self.web = aWeb
    def chunkReferencedBy( self, aChunk ):
        """Return a list of Chunks."""
        pass

class SimpleReference( Reference ):
    def __init__( self, aWeb ):
        self.web = aWeb
    def chunkReferencedBy( self, aChunk ):
        """:todo: Return the chunks themselves."""
        refBy= aChunk.referencedBy
        return [ (c.fullName, c.seq) for c in refBy ]

class TransitiveReference( Reference ):
    def __init__( self, aWeb ):
        self.web = aWeb
    def chunkReferencedBy( self, aChunk ):
        """:todo: Return the chunks themselves."""
        refBy= aChunk.referencedBy
        logger.debug( "References: %r(%d) %r", aChunk.name, aChunk.seq, refBy )
        closure= self.allParentsOf( refBy )
        return [ (c.fullName, c.seq) for c in closure ]
    def allParentsOf( self, chunkList, depth=0 ):
        """Transitive closure of parents.
        :todo: Return the chunks themselves.
        """
        final = []
        for c in chunkList:
            final.append( c )
            final.extend( self.allParentsOf( c.referencedBy, depth+1 ) )
        logger.debug( "References: %*s %r", 2*depth, '--', final )
        return final
 

class WebReader( object ):
    """Parse an input file, creating Commands and Chunks."""
    def __init__( self, parent=None, command='@', permit=None ):
        # Configuration of this reader.
        self._source= None
        self.fileName= None
        self.parent= parent
        self.theWeb= None
        if self.parent: 
            self.command= self.parent.command
            self.permitList= self.parent.permitList
        else:
            self.command= command
            self.permitList= [] if permit is None else permit
            
        self.log_reader= logging.getLogger( "pyweb.%s" % self.__class__.__name__ )

        # State of reading and parsing.
        self.tokenList= []
        self.token= ""
        self.tokenIndex= 0
        self.tokenPushback= []
        self.lineNumber= 0
        self.aChunk= None
        self.totalLines= 0
        self.totalFiles= 0
        self.parsePat= '(%s.)' % self.command
                
        # major commands
        self.cmdo= self.command+'o'
        self.cmdd= self.command+'d'
        self.cmdlcurl= self.command+'{'
        self.cmdrcurl= self.command+'}'
        self.cmdlbrak= self.command+'['
        self.cmdrbrak= self.command+']'
        self.cmdi= self.command+'i'
        # minor commands
        self.cmdlangl= self.command+'<'
        self.cmdrangl= self.command+'>'
        self.cmdpipe= self.command+'|'
        self.cmdlexpr= self.command+'('
        self.cmdrexpr= self.command+')'
        self.cmdf= self.command+'f'
        self.cmdm= self.command+'m'
        self.cmdu= self.command+'u'
        self.cmdcmd= self.command+self.command

    def __str__( self ):
        return self.__class__.__name__
        
    def web( self, aWeb ):
        self.theWeb= aWeb
        return self
    def source( self, name, source=None ):
        """Set a name to display with error messages; also set the actual file-like source.
        if no source is given, the name is treated as a filename and opened.
        """
        self.fileName= name
        self._source= source
        return self

        
    def openSource( self ):
        if self._source is None:
            self._source= open( self.fileName, "r" )
        text= self._source.read()
        self.tokenList= re.split(self.parsePat, text )
        self.lineNumber= 1
        self.totalLines= 0
        self.totalFiles += 1
        self.tokenPushback= []
    def nextToken( self ):
        lines=  self.token.count('\n')
        self.lineNumber += lines
        self.totalLines += lines
        if self.tokenPushback:
            self.token= self.tokenPushback.pop()
        else:
            self.token= self.tokenList.pop(0)
        return self.token
    def moreTokens( self ):
        return self.tokenList or self.tokenPushback
    def pushBack( self, token ):
        self.tokenPushback.append( token )

        
    def location( self ):
        return ( self.fileName, self.lineNumber, self.lineNumber+self.token.count("\n") )

        
    def handleCommand( self, token ):
        self.log_reader.debug( "Reading %r", token )
                
        if token[:2] == self.cmdo:
                        
            args= self.nextToken().strip()
            values = shlex.split( args )
            if len(values) == 1:
                self.aChunk= OutputChunk( values[0], "", "" )
            elif len(values) == 2:
                self.aChunk= OutputChunk( values[0], values[1], "" )
            else:
                self.aChunk= OutputChunk( values[0], values[1], values[2] )
            self.aChunk.webAdd( self.theWeb )
            self.expect( (self.cmdlcurl,) )
            # capture an OutputChunk up to @}
        
        elif token[:2] == self.cmdd:
                        
            name= self.nextToken().strip()
            # next token is @{ or @[
            brack= self.expect( (self.cmdlcurl,self.cmdlbrak) )
            if brack == self.cmdlcurl: 
                self.aChunk= NamedChunk( name )
            else: 
                self.aChunk= NamedDocumentChunk( name )
            self.aChunk.webAdd( self.theWeb )
            # capture a NamedChunk up to @} or @]
        
        elif token[:2] == self.cmdi:
                        
            # break this token on the '\n' and pushback the new token.
            next= self.nextToken().split('\n',1)
            self.pushBack('\n')
            if len(next) > 1:
                self.pushBack( '\n'.join(next[1:]) )
            incFile= next[0].strip()
            try:
                with open(incFile,"r") as source:
                    logger.info( "Including %r", incFile )
                    include= WebReader( parent=self )
                    include.source( incFile, source ).web( self.theWeb )
                    include.load()
                self.totalLines += include.totalLines
                self.totalFiles += include.totalFiles
            except (Error,IOError),e:
                logger.error( 
                    "Problems with included file %s, output is incomplete.",
                    incFile )
                # Discretionary - sometimes we want total failure
                if self.cmdi in self.permitList: pass
                else: raise
            self.aChunk= Chunk()
            self.aChunk.webAdd( self.theWeb )
        
        elif token[:2] in (self.cmdrcurl,self.cmdrbrak):
                        
            self.aChunk= Chunk()
            self.aChunk.webAdd( self.theWeb )
        
    
                
        elif token[:2] == self.cmdpipe:
                        
            # variable references at the end of a NamedChunk
            # aChunk must be subclass of NamedChunk
            # These are accumulated and expanded by @u reference
            try:
                self.aChunk.setUserIDRefs( self.nextToken().strip() )
            except AttributeError:
                # Out of place user identifier command
                raise Error("Unexpected references near %s: %s" % (self.location(),token) )
        
        elif token[:2] == self.cmdf:
            self.aChunk.append( FileXrefCommand(self.lineNumber) )
        elif token[:2] == self.cmdm:
            self.aChunk.append( MacroXrefCommand(self.lineNumber) )
        elif token[:2] == self.cmdu:
            self.aChunk.append( UserIdXrefCommand(self.lineNumber) )
        elif token[:2] == self.cmdlangl:
                        
            # get the name, introduce into the named Chunk dictionary
            expand= self.nextToken().strip()
            self.expect( (self.cmdrangl,) )
            self.theWeb.addDefName( expand )
            self.aChunk.append( ReferenceCommand( expand, self.lineNumber ) )
            self.aChunk.appendText( "", self.lineNumber ) # to collect following text
            self.log_reader.debug( "Reading %r %r", expand, self.token )
        
        elif token[:2] == self.cmdlexpr:
                        
            # get the Python expression, create the expression command
            expression= self.nextToken()
            self.expect( (self.cmdrexpr,) )
            try:
                theLocation= self.location()
                theWebReader= self
                theFile= self.theWeb.webFileName
                thisApplication= sys.argv[0]
                result= str(eval( expression ))
            except Exception,e:
                result= '!!!Exception: %s' % e
                logger.exception( 'Failure to process %r: result is %s', expression, e )
            self.aChunk.appendText( result, self.lineNumber )
        
        elif token[:2] == self.cmdcmd:
                        
            # replace with '@' here and now!
            # Put this at the end of the previous chunk
            # AND make sure the next chunk is appended to this.
            self.aChunk.appendText( self.command, self.lineNumber )
        
    
        elif token[:2] in (self.cmdlcurl,self.cmdlbrak):
            # These should be consumed as part of @o and @d parsing
            raise Error('Extra %r (possibly missing chunk name)' % token, self.aChunk)
        else:
            return None # did not recogize the command
        return True # did recognize the command

        
    def expect( self, tokens ):
        if not self.moreTokens():
            raise Error("At %r: end of input, %r not found" % (self.location(),tokens) )
        t= self.nextToken()
        if t not in tokens:
            raise Error("At %r: expected %r, found %r" % (self.location(),tokens,t) )
        return t
        
    def load( self ):
        self.aChunk= Chunk() # Initial anonymous chunk of text.
        self.aChunk.webAdd( self.theWeb )
        self.openSource()
        while self.moreTokens():
            token= self.nextToken()
            if len(token) >= 2 and token.startswith(self.command):
                if self.handleCommand( token ):
                    continue
                else:
                                        
                    logger.warn( 'Unknown @-command in input: %r', token )
                    self.aChunk.appendText( token, self.lineNumber )
    
            elif token:
                # accumulate non-empty block of text in the current chunk
                self.aChunk.appendText( token, self.lineNumber )




class Action( object ):
    """An action performed by pyWeb."""
    def __init__( self, name ):
        self.name= name
        self.web= None
        self.start= None
    def __str__( self ):
        return "%s [%s]" % ( self.name, self.web )
        
    def __call__( self ):
        logger.info( "Starting %s", self )
        self.start= time.clock()

        
    def duration( self ):
        """Return duration of the action."""
        return (self.start and time.clock()-self.start) or 0
    def summary( self, *args ):
        return "%s in %0.1f sec." % ( self.name, self.duration() )



class ActionSequence( Action ):
    """An action composed of a sequence of other actions."""
    def __init__( self, name, opSequence=None ):
        super( ActionSequence, self ).__init__( name )
        if opSequence: self.opSequence= opSequence
        else: self.opSequence= []
    def __str__( self ):
        return "; ".join( [ str(x) for x in self.opSequence ] )
        
    def __call__( self ):
        for o in self.opSequence:
            o.web= self.web
            o()

        
    def append( self, anAction ):
        self.opSequence.append( anAction )

        
    def summary( self, *args ):
        return ", ".join( [ x.summary(*args) for x in self.opSequence ] )



class WeaveAction( Action ):
    """An action that weaves a document."""
    def __init__( self ):
        super(WeaveAction, self).__init__( "Weave" )
        self.theWeaver= None
    def __str__( self ):
        return "%s [%s, %s]" % ( self.name, self.web, self.theWeaver )

        
    def __call__( self ):
        super( WeaveAction, self ).__call__()
        if not self.theWeaver: 
            # Examine first few chars of first chunk of web to determine language
            self.theWeaver= self.web.language() 
        try:
            self.web.weave( self.theWeaver )
        except Error,e:
            logger.error(
                "Problems weaving document from %s (weave file is faulty).",
                self.web.webFileName )
            raise

        
    def summary( self, *args ):
        if self.theWeaver and self.theWeaver.linesWritten > 0:
            return "%s %d lines in %0.1f sec." % ( self.name, self.theWeaver.linesWritten, self.duration() )
        return "did not %s" % ( self.name, )



class TangleAction( Action ):
    """An action that weaves a document."""
    def __init__( self ):
        super( TangleAction, self ).__init__( "Tangle" )
        self.theTangler= None
        
    def __call__( self ):
        super( TangleAction, self ).__call__()
        try:
            self.web.tangle( self.theTangler )
        except Error,e:
            logger.error( 
                "Problems tangling outputs from %s (tangle files are faulty).",
                self.web.webFileName )
            raise

        
    def summary( self, *args ):
        if self.theTangler and self.theTangler.linesWritten > 0:
            return "%s %d lines in %0.1f sec." % ( self.name, self.theTangler.linesWritten, self.duration() )
        return "did not %s" % ( self.name, )



class LoadAction( Action ):
    """An action that loads the source web for a document."""
    def __init__( self ):
        super( LoadAction, self ).__init__( "Load" )
        self.web= None
        self.webReader= None
    def __str__( self ):
        return "Load [%s, %s]" % ( self.webReader, self.web )
        
    def __call__( self ):
        super( LoadAction, self ).__call__()
        try:
            self.webReader.web(self.web).load()
            self.web.createUsedBy()
        except (Error,IOError),e:
            logger.error(
                "Problems with source file %s, no output produced.",
                self.web.webFileName )
            raise

        
    def summary( self, *args ):
        return "%s %d lines from %d files in %01.f sec." % ( 
            self.name, self.webReader.totalLines, 
            self.webReader.totalFiles, self.duration() )





class Application( object ):
    def __init__( self ):
                
        self.theTangler= TanglerMake()
        self.theWeaver= None
        self.permitList= []
        self.commandChar= '@'
        self.loadOp= LoadAction()
        self.weaveOp= WeaveAction()
        self.tangleOp= TangleAction()
        self.doWeave= ActionSequence( "load and weave", [self.loadOp, self.weaveOp] )
        self.doTangle= ActionSequence( "load and tangle", [self.loadOp, self.tangleOp] )
        self.theAction= ActionSequence( "load, tangle and weave", [self.loadOp, self.tangleOp, self.weaveOp] )
        self.files= []

        
    def parseArgs( self ):
        p = optparse.OptionParser()
        p.add_option( "-v", "--verbose", dest="verbosity", action="store_const", const=logging.INFO )
        p.add_option( "-s", "--silent", dest="verbosity", action="store_const", const=logging.WARN )
        p.add_option( "-d", "--debug", dest="verbosity", action="store_const", const=logging.DEBUG )
        p.add_option( "-c", "--command", dest="command", action="store" )
        p.add_option( "-w", "--weaver", dest="weaver", action="store" )
        p.add_option( "-x", "--except", dest="skip", action="store" )
        p.add_option( "-p", "--permit", dest="permit", action="store" )
        opts, self.files= p.parse_args()
        if opts.command:
            logger.info( "Setting command character to %r", opts.command )
            self.commandChar= opts.command
        if opts.weaver:
            self.theWeaver= weavers[ opts.weaver ]
            logger.info( "Setting weaver to %s", self.theWeaver )
        if opts.skip:
            if opts.skip.lower().startswith('w'): # skip weaving
                self.theAction= self.doTangle
            elif opts.skip.lower().startswith('t'): # skip tangling
                self.theAction= self.doWeave
            else:
                raise Exception( "Unknown -x option %r" % opts.skip )
        if opts.permit:
            # save permitted errors, usual case is -pi to permit include errors
            self.permitList= [ '%s%s' % ( commandChar, c ) for c in opts.permit ]
        if opts.verbosity:
            logger.setLevel( opts.verbosity )
        self.options= opts
    

        
    def process( self, theFiles=None ):
        self.weaveOp.theWeaver= self.theWeaver
        self.tangleOp.theTangler= self.theTangler
        for f in theFiles or self.files:
            w= Web( f ) # A web to work on.
            try:
                with open(f,"r") as source:
                    logger.info( "Reading %r", f )
                    webReader= WebReader( command=self.commandChar, permit=self.permitList )
                    webReader.source( f, source ).web( w )
                    self.loadOp.webReader= webReader
                    self.theAction.web= w
                    self.theAction()
            except Error,e:
                logger.exception( e )
            except IOError,e:
                logger.exception( e )
            logger.info( 'pyWeb: %s', self.theAction.summary(w,self) )



import logging
logger= logging.getLogger( "pyweb" )

# Module global list of available weavers.
weavers = {
    'html':  HTML(),
    'htmls': HTMLShort(),
    'latex': LaTeX(),
    'rst': Weaver(), # Generic Weaver produces RST.
}


def main():
    logging.basicConfig( stream=sys.stderr, level=logging.INFO )
    logging.getLogger( "pyweb.TanglerMake" ).setLevel( logging.WARN )
    logging.getLogger( "pyweb.WebReader" ).setLevel( logging.WARN )
    a= Application()
    a.parseArgs()
    a.process()
    logging.shutdown()

if __name__ == "__main__":
    main( )

