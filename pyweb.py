#!/usr/bin/env python
"""pyWeb Literate Programming - tangle and weave tool.

Yet another simple literate programming tool derived from nuweb, 
implemented entirely in Python.  
This produces any markup for any programming language.

Usage:
    pyweb.py [-dvs] [-c x] [-w format] file.w

Options:
    -v           verbose output (the default)
    -s           silent output
    -d           debugging output
    -c x         change the command character from '@' to x
    -w format    Use the given weaver for the final document.
                 Choices are rst, html, latex and htmlshort.
                 Additionally, a `module.class` name can be used.
    -xw          Exclude weaving
    -xt          Exclude tangling
    -pi          Permit include-command errors
    -rt          Transitive references
    -rs          Simple references (default)
    -n           Include line number comments in the tangled source; requires
                 comment start and stop on the @o commands.
        
    file.w       The input file, with @o, @d, @i, @[, @{, @|, @<, @f, @m, @u commands.
"""
__version__ = """3.0"""

### DO NOT EDIT THIS FILE!
### It was created by /Users/slott/Documents/Projects/PyWebTool-3/pyweb/pyweb.py, __version__='2.3.2'.
### From source pyweb.w modified Sat Jun 16 08:10:37 2018.
### In working directory '/Users/slott/Documents/Projects/PyWebTool-3/pyweb'.

import string

import tempfile
import filecmp


import weakref


import builtins
import sys
import platform


import re


import shlex


import os
import time
import datetime
import types

import argparse


import logging
import logging.config




class Error( Exception ): pass



class Command:
    """A Command is the lowest level of granularity in the input stream."""
    def __init__( self, fromLine=0 ):
        self.lineNumber= fromLine+1 # tokenizer is zero-based
        self.chunk= None
        self.logger= logging.getLogger( self.__class__.__qualname__ )
    def __str__( self ):
        return "at {!r}".format(self.lineNumber)
        
    def startswith( self, prefix ):
        return None
    def searchForRE( self, rePat ):
        return None
    def indent( self ):
        return None
    

        
    def ref( self, aWeb ):
        return None
    def weave( self, aWeb, aWeaver ):
        pass
    def tangle( self, aWeb, aTangler ):
        pass
    




class TextCommand( Command ):
    """A piece of document source text."""
    def __init__( self, text, fromLine=0 ):
        super().__init__( fromLine )
        self.text= text
    def __str__( self ):
        return "at {!r}: {!r}...".format(self.lineNumber,self.text[:32])
    def startswith( self, prefix ):
        return self.text.startswith( prefix )
    def searchForRE( self, rePat ):
        return rePat.search( self.text )
    def indent( self ):
        if self.text.endswith('\n'):
            return 0
        try:
            last_line = self.text.splitlines()[-1]
            return len(last_line)
        except IndexError:
            return 0
    def weave( self, aWeb, aWeaver ):
        aWeaver.write( self.text )
    def tangle( self, aWeb, aTangler ):
        aTangler.write( self.text )



class CodeCommand( TextCommand ):
    """A piece of program source code."""
    def weave( self, aWeb, aWeaver ):
        aWeaver.codeBlock( aWeaver.quote( self.text ) )
    def tangle( self, aWeb, aTangler ):
        aTangler.codeBlock( self.text )



class XrefCommand( Command ):
    """Any of the Xref-goes-here commands in the input."""
    def __str__( self ):
        return "at {!r}: cross reference".format(self.lineNumber)
    def formatXref( self, xref, aWeaver ):
        aWeaver.xrefHead()
        for n in sorted(xref):
            aWeaver.xrefLine( n, xref[n] )
        aWeaver.xrefFoot()
    def tangle( self, aWeb, aTangler ):
        raise Error('Illegal tangling of a cross reference command.')



class FileXrefCommand( XrefCommand ):
    """A FileXref command."""
    def weave( self, aWeb, aWeaver ):
        """Weave a File Xref from @o commands."""
        self.formatXref( aWeb.fileXref(), aWeaver )



class MacroXrefCommand( XrefCommand ):
    """A MacroXref command."""
    def weave( self, aWeb, aWeaver ):
        """Weave the Macro Xref from @d commands."""
        self.formatXref( aWeb.chunkXref(), aWeaver )



class UserIdXrefCommand( XrefCommand ):
    """A UserIdXref command."""
    def weave( self, aWeb, aWeaver ):
        """Weave a user identifier Xref from @d commands."""
        ux= aWeb.userNamesXref()
        if len(ux) != 0:
            aWeaver.xrefHead()
            for u in sorted(ux):
                defn, refList= ux[u]
                aWeaver.xrefDefLine( u, defn, refList )
            aWeaver.xrefFoot()
        else:
            aWeaver.xrefEmpty()



class ReferenceCommand( Command ):
    """A reference to a named chunk, via @<name@>."""
    def __init__( self, refTo, fromLine=0 ):
        super().__init__( fromLine )
        self.refTo= refTo
        self.fullname= None
        self.sequenceList= None
        self.chunkList= []
    def __str__( self ):
        return "at {!r}: reference to chunk {!r}".format(self.lineNumber,self.refTo)
        
    def resolve( self, aWeb ):
        """Expand our chunk name and list of parts"""
        self.fullName= aWeb.fullNameFor( self.refTo )
        self.chunkList= aWeb.getchunk( self.refTo )
    

        
    def ref( self, aWeb ):
        """Find and return the full name for this reference."""
        self.resolve( aWeb )
        return self.fullName
    

        
    def weave( self, aWeb, aWeaver ):
        """Create the nicely formatted reference to a chunk of code."""
        self.resolve( aWeb )
        aWeb.weaveChunk( self.fullName, aWeaver )
    

        
    def tangle( self, aWeb, aTangler ):
        """Create source code."""
        self.resolve( aWeb )
        
        self.logger.debug( "Indent {!r} + {!r}".format(aTangler.context, self.chunk.previous_command.indent()) )    
        self.chunk.reference_indent( aWeb, aTangler, self.chunk.previous_command.indent() )
        
        self.logger.debug( "Tangling chunk {!r}".format(self.fullName) )
        if len(self.chunkList) != 0:
            for p in self.chunkList:
                p.tangle( aWeb, aTangler )
        else:
            raise Error( "Attempt to tangle an undefined Chunk, {!s}.".format( self.fullName, ) )
    
        self.chunk.reference_dedent( aWeb, aTangler )
    






class Chunk:
    """Anonymous piece of input file: will be output through the weaver only."""
    # construction and insertion into the web
    def __init__( self ):
        self.commands= [ ] # The list of children of this chunk
        self.user_id_list= None
        self.initial= None
        self.name= ''
        self.fullName= None
        self.seq= None
        self.fileName= ''
        self.referencedBy= [] # Chunks which reference this chunk.  Ideally just one.
        self.references= [] # Names that this chunk references
                
    def __str__( self ):
        return "\n".join( map( str, self.commands ) )
    def __repr__( self ):
        return "{!s}('{!s}')".format( self.__class__.__name__, self.name )
        
    def append( self, command ):
        """Add another Command to this chunk."""
        self.commands.append( command )
        command.chunk= self
    

        
    def appendText( self, text, lineNumber=0 ):
        """Append a single character to the most recent TextCommand."""
        try:
            # Works for TextCommand, otherwise breaks
            self.commands[-1].text += text
        except IndexError as e:
            # First command?  Then the list will have been empty.
            self.commands.append( self.makeContent(text,lineNumber) )
        except AttributeError as e:
            # Not a TextCommand?  Then there won't be a text attribute.
            self.commands.append( self.makeContent(text,lineNumber) )
    

        
    def webAdd( self, web ):
        """Add self to a Web as anonymous chunk."""
        web.add( self )
    

    
        
    def genReferences( self, aWeb ):
        """Generate references from this Chunk."""
        try:
            for t in self.commands:
                ref= t.ref( aWeb )
                if ref is not None:
                    yield ref
        except Error as e:
            raise
    

        
    def makeContent( self, text, lineNumber=0 ):
        return TextCommand( text, lineNumber )
    

        
    def startswith( self, prefix ):
        """Examine the first command's starting text."""
        return len(self.commands) >= 1 and self.commands[0].startswith( prefix )
    
    def searchForRE( self, rePat ):
        """Visit each command, applying the pattern."""
        for c in self.commands:
            if c.searchForRE( rePat ):
                return self
        return None
    
    @property
    def lineNumber( self ):
        """Return the first command's line number or None."""
        return self.commands[0].lineNumber if len(self.commands) >= 1 else None
    
    def getUserIDRefs( self ):
        return []
    

        
    def references_list( self, theWeaver ):
        """Extract name, sequence from Chunks into a list."""
        return [ (c.name, c.seq) 
            for c in theWeaver.reference_style.chunkReferencedBy( self ) ]

    
        
    def weave( self, aWeb, aWeaver ):
        """Create the nicely formatted document from an anonymous chunk."""
        aWeaver.docBegin( self )
        for cmd in self.commands:
            cmd.weave( aWeb, aWeaver )
        aWeaver.docEnd( self )
    def weaveReferenceTo( self, aWeb, aWeaver ):
        """Create a reference to this chunk -- except for anonymous chunks."""
        raise Exception( "Cannot reference an anonymous chunk.""")
    def weaveShortReferenceTo( self, aWeb, aWeaver ):
        """Create a short reference to this chunk -- except for anonymous chunks."""
        raise Exception( "Cannot reference an anonymous chunk.""")
    

        
    def tangle( self, aWeb, aTangler ):
        """Create source code -- except anonymous chunks should not be tangled"""
        raise Error( 'Cannot tangle an anonymous chunk', self )
    

        
    def reference_indent( self, aWeb, aTangler, amount ):
        aTangler.addIndent( amount )  # Or possibly set indent to local zero.
        
    def reference_dedent( self, aWeb, aTangler ):
        aTangler.clrIndent()




class NamedChunk( Chunk ):
    """Named piece of input file: will be output as both tangler and weaver."""
    def __init__( self, name ):
        super().__init__()
        self.name= name
        self.user_id_list= []
        self.refCount= 0
    def __str__( self ):
        return "{!r}: {!s}".format( self.name, Chunk.__str__(self) )
    def makeContent( self, text, lineNumber=0 ):
        return CodeCommand( text, lineNumber )
        
    def setUserIDRefs( self, text ):
        """Save user ID's associated with this chunk."""
        self.user_id_list= text.split()
    def getUserIDRefs( self ):
        return self.user_id_list
    

        
    def webAdd( self, web ):
        """Add self to a Web as named chunk, update xrefs."""
        web.addNamed( self )
    

        
    def weave( self, aWeb, aWeaver ):
        """Create the nicely formatted document from a chunk of code."""
        self.fullName= aWeb.fullNameFor( self.name )
        aWeaver.addIndent()
        aWeaver.codeBegin( self )
        for cmd in self.commands:
            cmd.weave( aWeb, aWeaver )
        aWeaver.clrIndent( )
        aWeaver.codeEnd( self )
    def weaveReferenceTo( self, aWeb, aWeaver ):
        """Create a reference to this chunk."""
        self.fullName= aWeb.fullNameFor( self.name )
        txt= aWeaver.referenceTo( self.fullName, self.seq )
        aWeaver.codeBlock( txt )
    def weaveShortReferenceTo( self, aWeb, aWeaver ):
        """Create a shortened reference to this chunk."""
        txt= aWeaver.referenceTo( None, self.seq )
        aWeaver.codeBlock( txt )
    

        
    def tangle( self, aWeb, aTangler ):
        """Create source code.
        Use aWeb to resolve @<namedChunk@>.
        Format as correctly indented source text
        """
        self.previous_command= TextCommand( "", self.commands[0].lineNumber )
        aTangler.codeBegin( self )
        for t in self.commands:
            try:
                t.tangle( aWeb, aTangler )
            except Error as e:
                raise
            self.previous_command= t
        aTangler.codeEnd( self )
    



class NamedChunk_Noindent( NamedChunk ):
    """Named piece of input file: will be output as both tangler and weaver."""
    def reference_indent( self, aWeb, aTangler, amount ):
        aTangler.setIndent( 0 )
    
    def reference_dedent( self, aWeb, aTangler ):
        aTangler.clrIndent()


class OutputChunk( NamedChunk ):
    """Named piece of input file, defines an output tangle."""
    def __init__( self, name, comment_start=None, comment_end="" ):
        super().__init__( name )
        self.comment_start= comment_start
        self.comment_end= comment_end
        
    def webAdd( self, web ):
        """Add self to a Web as output chunk, update xrefs."""
        web.addOutput( self )
    

        
    def weave( self, aWeb, aWeaver ):
        """Create the nicely formatted document from a chunk of code."""
        self.fullName= aWeb.fullNameFor( self.name )
        aWeaver.fileBegin( self )
        for cmd in self.commands:
            cmd.weave( aWeb, aWeaver )
        aWeaver.fileEnd( self )
    

        
    def tangle( self, aWeb, aTangler ):
        aTangler.comment_start= self.comment_start
        aTangler.comment_end= self.comment_end
        super().tangle( aWeb, aTangler )




class NamedDocumentChunk( NamedChunk ):
    """Named piece of input file with document source, defines an output tangle."""
    def makeContent( self, text, lineNumber=0 ):
        return TextCommand( text, lineNumber )
        
    def weave( self, aWeb, aWeaver ):
        """Ignore this when producing the document."""
        pass
    def weaveReferenceTo( self, aWeb, aWeaver ):
        """On a reference to this chunk, expand the body in place."""
        for cmd in self.commands:
            cmd.weave( aWeb, aWeaver )
    def weaveShortReferenceTo( self, aWeb, aWeaver ):
        """On a reference to this chunk, expand the body in place."""
        self.weaveReferenceTo( aWeb, aWeaver )
    

        
    def tangle( self, aWeb, aTangler ):
        """Raise an exception on an attempt to tangle."""
        raise Error( "Cannot tangle a chunk defined with @[.""" )
    





class Web:
    """The overall Web of chunks."""
    def __init__( self ):
        self.webFileName= None
        self.chunkSeq= [] 
        self.output= {} # Map filename to Chunk
        self.named= {} # Map chunkname to Chunk
        self.sequence= 0
        self.logger= logging.getLogger( self.__class__.__qualname__ )
    def __str__( self ):
        return "Web {!r}".format( self.webFileName, )

        
    
    def addDefName( self, name ):
        """Reference to or definition of a chunk name."""
        nm= self.fullNameFor( name )
        if nm is None: return None
        if nm[-3:] == '...':
            self.logger.debug( "Abbreviated reference {!r}".format(name) )
            return None # first occurance is a forward reference using an abbreviation
        if nm not in self.named:
            self.named[nm]= []
            self.logger.debug( "Adding empty chunk {!r}".format(name) )
        return nm
    
    
    
    def add( self, chunk ):
        """Add an anonymous chunk."""
        self.chunkSeq.append( chunk )
        chunk.web= weakref.ref(self)
    
    
    
    def addNamed( self, chunk ):
        """Add a named chunk to a sequence with a given name."""
        self.chunkSeq.append( chunk )
        chunk.web= weakref.ref(self)
        nm= self.addDefName( chunk.name )
        if nm:
            # We found the full name for this chunk
            self.sequence += 1
            chunk.seq= self.sequence
            chunk.fullName= nm
            self.named[nm].append( chunk )
            chunk.initial= len(self.named[nm]) == 1
            self.logger.debug( "Extending chunk {!r} from {!r}".format(nm, chunk.name) )
        else:
            raise Error("No full name for {!r}".format(chunk.name), chunk)
    
    
    
    def addOutput( self, chunk ):
        """Add an output chunk to a sequence with a given name."""
        self.chunkSeq.append( chunk )
        chunk.web= weakref.ref(self)
        if chunk.name not in self.output:
            self.output[chunk.name] = []
            self.logger.debug( "Adding chunk {!r}".format(chunk.name) )
        self.sequence += 1
        chunk.seq= self.sequence
        chunk.fullName= chunk.name
        self.output[chunk.name].append( chunk )
        chunk.initial = len(self.output[chunk.name]) == 1
    
    

        
    def fullNameFor( self, name ):
        """Resolve "..." names into the full name."""
        if name in self.named: return name
        if name[-3:] == '...':
            best= [ n for n in self.named.keys()
                if n.startswith( name[:-3] ) ]
            if len(best) > 1:
                raise Error("Ambiguous abbreviation {!r}, matches {!r}".format( name, list(sorted(best)) ) )
            elif len(best) == 1: 
                return best[0]
        return name
    
    
    def getchunk( self, name ):
        """Locate a named sequence of chunks."""
        nm= self.fullNameFor( name )
        if nm in self.named:
            return self.named[nm]
        raise Error( "Cannot resolve {!r} in {!r}".format(name,self.named.keys()) )
    

        
    def createUsedBy( self ):
        """Update every piece of a Chunk to show how the chunk is referenced.
        Each piece can then report where it's used in the web.
        """
        for aChunk in self.chunkSeq:
            #usage = (self.fullNameFor(aChunk.name), aChunk.seq)
            for aRefName in aChunk.genReferences( self ):
                for c in self.getchunk( aRefName ):
                    c.referencedBy.append( aChunk )
                    c.refCount += 1
                
        for nm in self.no_reference():
            self.logger.warn( "No reference to {!r}".format(nm) )
        for nm in self.multi_reference():
            self.logger.warn( "Multiple references to {!r}".format(nm) )
        for nm in self.no_definition():
            self.logger.error( "No definition for {!r}".format(nm) )
            self.errors += 1
    
    
    
    def no_reference( self ):
        return [ nm for nm,cl in self.named.items() if len(cl)>0 and cl[0].refCount == 0 ]
    def multi_reference( self ):
        return [ nm for nm,cl in self.named.items() if len(cl)>0 and cl[0].refCount > 1 ]
    def no_definition( self ):
        return [ nm for nm,cl in self.named.items() if len(cl) == 0 ] 
    
    
    def fileXref( self ):
        fx= {}
        for f,cList in self.output.items():
            fx[f]= [ c.seq for c in cList ]
        return fx
    def chunkXref( self ):
        mx= {}
        for n,cList in self.named.items():
            mx[n]= [ c.seq for c in cList ]
        return mx
    
    
    def userNamesXref( self ):
        ux= {}
        self._gatherUserId( self.named, ux )
        self._gatherUserId( self.output, ux )
        self._updateUserId( self.named, ux )
        self._updateUserId( self.output, ux )
        return ux
    def _gatherUserId( self, chunkMap, ux ):
                
        for n,cList in chunkMap.items():
            for c in cList:
                for id in c.getUserIDRefs():
                    ux[id]= ( c.seq, [] )
    
    def _updateUserId( self, chunkMap, ux ):
                
        # examine source for occurrences of all names in ux.keys()
        for id in ux.keys():
            self.logger.debug( "References to {!r}".format(id) )
            idpat= re.compile( r'\W{!s}\W'.format(id) )
            for n,cList in chunkMap.items():
                for c in cList:
                    if c.seq != ux[id][0] and c.searchForRE( idpat ):
                        ux[id][1].append( c.seq )
    
    

        
    def language( self, preferredWeaverClass=None ):
        """Construct a weaver appropriate to the document's language"""
        if preferredWeaverClass:
            return preferredWeaverClass()
        self.logger.debug( "Picking a weaver based on first chunk {!r}".format(self.chunkSeq[0][:4]) )
        if self.chunkSeq[0].startswith('<'): 
            return HTML()
        if self.chunkSeq[0].startswith('%') or self.chunkSeq[0].startswith('\\'):  
            return LaTeX()
        return RST()
    

        
    def tangle( self, aTangler ):
        for f, c in self.output.items():
            with aTangler.open(f):
                for p in c:
                    p.tangle( self, aTangler )
    

        
    def weave( self, aWeaver ):
        self.logger.debug( "Weaving file from {!r}".format(self.webFileName) )
        basename, _ = os.path.splitext( self.webFileName )
        with aWeaver.open(basename):
            for c in self.chunkSeq:
                c.weave( self, aWeaver )
    def weaveChunk( self, name, aWeaver ):
        self.logger.debug( "Weaving chunk {!r}".format(name) )
        chunkList= self.getchunk(name)
        if not chunkList:
            raise Error( "No Definition for {!r}".format(name) )
        chunkList[0].weaveReferenceTo( self, aWeaver )
        for p in chunkList[1:]:
            aWeaver.write( aWeaver.referenceSep() )
            p.weaveShortReferenceTo( self, aWeaver )
    




class Tokenizer:
    def __init__( self, stream, command_char='@' ):
        self.command= command_char
        self.parsePat= re.compile( r'({!s}.|\n)'.format(self.command) )
        self.token_iter= (t for t in self.parsePat.split( stream.read() ) if len(t) != 0)
        self.lineNumber= 0
    def __next__( self ):
        token= next(self.token_iter)
        self.lineNumber += token.count('\n')
        return token
    def __iter__( self ):
        return self



class OptionDef:
    def __init__( self, name, **kw ):
        self.name= name
        self.__dict__.update( kw )

class OptionParser:
    def __init__( self, *arg_defs ):
        self.args= dict( (arg.name,arg) for arg in arg_defs )
        self.trailers= [k for k in self.args.keys() if not k.startswith('-')]
    def parse( self, text ):
        try:
            word_iter= iter(shlex.split(text))
        except ValueError as e:
            raise Error( "Error parsing options in {!r}".format(text) )
        options = dict( s for s in self._group( word_iter ) )
        return options
    def _group( self, word_iter ):
        option, value, final= None, [], []
        for word in word_iter:
            if word == '--':
                if option:
                    yield option, value
                try:
                    final= [next(word_iter)] 
                except StopIteration:
                    final= [] # Special case of '--' at the end.
                break
            elif word.startswith('-'):
                if word in self.args:
                    if option: 
                        yield option, value
                    option, value = word, []
                else:
                    raise ParseError( "Unknown option {0}".format(word) )
            else:
                if option:
                    if self.args[option].nargs == len(value):
                        yield option, value
                        final= [word]
                        break
                    else:                
                        value.append( word )
                else:
                    final= [word]
                    break
        # In principle, we step through the trailers based on nargs counts.
        for word in word_iter:
            final.append( word )
        yield self.trailers[0], " ".join(final)


class WebReader:
    """Parse an input file, creating Chunks and Commands."""

    output_option_parser= OptionParser(
        OptionDef( "-start", nargs=1, default=None ),
        OptionDef( "-end", nargs=1, default="" ),
        OptionDef( "argument", nargs='*' ),
        )

    definition_option_parser= OptionParser(
        OptionDef( "-indent", nargs=0 ),
        OptionDef( "-noindent", nargs=0 ),
        OptionDef( "argument", nargs='*' ),
        )

    def __init__( self, parent=None ):
        self.logger= logging.getLogger( self.__class__.__qualname__ )

        # Configuration of this reader.
        self.parent= parent
        if self.parent: 
            self.command= self.parent.command
            self.permitList= self.parent.permitList
        else: # Defaults until overridden
            self.command= '@'
            self.permitList= []

        # Load options
        self._source= None
        self.fileName= None
        self.theWeb= None
            
        # State of reading and parsing.
        self.tokenizer= None
        self.aChunk= None
        
        # Summary
        self.totalLines= 0
        self.totalFiles= 0
        self.errors= 0 
        
                
        # Structural ("major") commands
        self.cmdo= self.command+'o'
        self.cmdd= self.command+'d'
        self.cmdlcurl= self.command+'{'
        self.cmdrcurl= self.command+'}'
        self.cmdlbrak= self.command+'['
        self.cmdrbrak= self.command+']'
        self.cmdi= self.command+'i'
        
        # Inline ("minor") commands
        self.cmdlangl= self.command+'<'
        self.cmdrangl= self.command+'>'
        self.cmdpipe= self.command+'|'
        self.cmdlexpr= self.command+'('
        self.cmdrexpr= self.command+')'
        self.cmdcmd= self.command+self.command
        
        # Content "minor" commands
        self.cmdf= self.command+'f'
        self.cmdm= self.command+'m'
        self.cmdu= self.command+'u'

    def __str__( self ):
        return self.__class__.__name__
        
    def location( self ):
        return (self.fileName, self.tokenizer.lineNumber+1)
    

        
    def load( self, web, filename, source=None ):
        self.theWeb= web
        self.fileName= filename
    
        # Only set the a web filename once using the first file.
        # This should be a setter property of the web.
        if self.theWeb.webFileName is None:
            self.theWeb.webFileName= self.fileName
        
        if source:
            self._source= source
            self.parse_source()
        else:
            with open( self.fileName, "r" ) as self._source:
                self.parse_source()
            
    def parse_source( self ):
            self.tokenizer= Tokenizer( self._source, self.command )
            self.totalFiles += 1
    
            self.aChunk= Chunk() # Initial anonymous chunk of text.
            self.aChunk.webAdd( self.theWeb )
    
            for token in self.tokenizer:
                if len(token) >= 2 and token.startswith(self.command):
                    if self.handleCommand( token ):
                        continue
                    else:
                        self.logger.warn( 'Unknown @-command in input: {!r}'.format(token) )
                        self.aChunk.appendText( token, self.tokenizer.lineNumber )
                elif token:
                    # Accumulate a non-empty block of text in the current chunk.
                    self.aChunk.appendText( token, self.tokenizer.lineNumber )
    

        
    def handleCommand( self, token ):
        self.logger.debug( "Reading {!r}".format(token) )
                
        if token[:2] == self.cmdo:
                        
            args= next(self.tokenizer)
            self.expect( (self.cmdlcurl,) )
            options= self.output_option_parser.parse( args )
            self.aChunk= OutputChunk( name=options['argument'],
                    comment_start= options.get('start',None),
                    comment_end= options.get('end',""),
                    )
            self.aChunk.fileName= self.fileName 
            self.aChunk.webAdd( self.theWeb )
            # capture an OutputChunk up to @}
        
        elif token[:2] == self.cmdd:
                        
            args= next(self.tokenizer)
            brack= self.expect( (self.cmdlcurl,self.cmdlbrak) )
            options= self.output_option_parser.parse( args )
            name=options['argument']
            
            if brack == self.cmdlbrak:
                self.aChunk= NamedDocumentChunk( name )
            elif brack == self.cmdlcurl:
                if '-noindent' in options:
                    self.aChunk= NamedChunk_Noindent( name )
                else:
                    self.aChunk= NamedChunk( name )
            elif brack == None:
                pass # Error noted by expect()
            else:
                raise Error( "Design Error" )
            
            self.aChunk.fileName= self.fileName 
            self.aChunk.webAdd( self.theWeb )
            # capture a NamedChunk up to @} or @]
        
        elif token[:2] == self.cmdi:
                        
            incFile= next(self.tokenizer).strip()
            try:
                self.logger.info( "Including {!r}".format(incFile) )
                include= WebReader( parent=self )
                include.load( self.theWeb, incFile )
                self.totalLines += include.tokenizer.lineNumber
                self.totalFiles += include.totalFiles
                if include.errors:
                    self.errors += include.errors
                    self.logger.error( 
                        "Errors in included file {!s}, output is incomplete.".format(
                        incFile) )
            except Error as e:
                self.logger.error( 
                    "Problems with included file {!s}, output is incomplete.".format(
                    incFile) )
                self.errors += 1
            except IOError as e:
                self.logger.error( 
                    "Problems with included file {!s}, output is incomplete.".format(
                    incFile) )
                # Discretionary -- sometimes we want to continue
                if self.cmdi in self.permitList: pass
                else: raise # TODO: Seems heavy-handed
            self.aChunk= Chunk()
            self.aChunk.webAdd( self.theWeb )
        
        elif token[:2] in (self.cmdrcurl,self.cmdrbrak):
                        
            self.aChunk= Chunk()
            self.aChunk.webAdd( self.theWeb )
        
    
                
        elif token[:2] == self.cmdpipe:
                        
            try:
                self.aChunk.setUserIDRefs( next(self.tokenizer).strip() )
            except AttributeError:
                # Out of place @| user identifier command
                self.logger.error( "Unexpected references near {!s}: {!s}".format(self.location(),token) )
                self.errors += 1
        
        elif token[:2] == self.cmdf:
            self.aChunk.append( FileXrefCommand(self.tokenizer.lineNumber) )
        elif token[:2] == self.cmdm:
            self.aChunk.append( MacroXrefCommand(self.tokenizer.lineNumber) )
        elif token[:2] == self.cmdu:
            self.aChunk.append( UserIdXrefCommand(self.tokenizer.lineNumber) )
        elif token[:2] == self.cmdlangl:
                        
            # get the name, introduce into the named Chunk dictionary
            expand= next(self.tokenizer).strip()
            closing= self.expect( (self.cmdrangl,) )
            self.theWeb.addDefName( expand )
            self.aChunk.append( ReferenceCommand( expand, self.tokenizer.lineNumber ) )
            self.aChunk.appendText( "", self.tokenizer.lineNumber ) # to collect following text
            self.logger.debug( "Reading {!r} {!r}".format(expand, closing) )
        
        elif token[:2] == self.cmdlexpr:
                        
            # get the Python expression, create the expression result
            expression= next(self.tokenizer)
            self.expect( (self.cmdrexpr,) )
            try:
                # Build Context
                safe= types.SimpleNamespace( **dict( (name,obj) 
                    for name,obj in builtins.__dict__.items() 
                    if name not in ('eval', 'exec', 'open', '__import__')))
                globals= dict(
                    __builtins__= safe, 
                    os= types.SimpleNamespace(path=os.path),
                    datetime= datetime,
                    platform= platform,
                    theLocation= self.location(),
                    theWebReader= self,
                    theFile= self.theWeb.webFileName,
                    thisApplication= sys.argv[0],
                    __version__= __version__,
                    )
                # Evaluate
                result= str(eval(expression, globals))
            except Exception as e:
                self.logger.error( 'Failure to process {!r}: result is {!r}'.format(expression, e) )
                self.errors += 1
                result= "@({!r}: Error {!r}@)".format(expression, e)
            self.aChunk.appendText( result, self.tokenizer.lineNumber )
        
        elif token[:2] == self.cmdcmd:
                        
            self.aChunk.appendText( self.command, self.tokenizer.lineNumber )
        
    
        elif token[:2] in (self.cmdlcurl,self.cmdlbrak):
            # These should have been consumed as part of @o and @d parsing
            self.logger.error( "Extra {!r} (possibly missing chunk name) near {!r}".format(token, self.location()) )
            self.errors += 1
        else:
            return None # did not recogize the command
        return True # did recognize the command
    
    
    def expect( self, tokens ):
        try:
            t= next(self.tokenizer)
            while t == '\n':
                t= next(self.tokenizer)
        except StopIteration:
            self.logger.error( "At {!r}: end of input, {!r} not found".format(self.location(),tokens) )
            self.errors += 1
            return
        if t not in tokens:
            self.logger.error( "At {!r}: expected {!r}, found {!r}".format(self.location(),tokens,t) )
            self.errors += 1
            return
        return t
    




class Emitter:
    """Emit an output file; handling indentation context."""
    code_indent= 0 # Used by a Tangler
    def __init__( self ):
        self.fileName= ""
        self.theFile= None
        self.linesWritten= 0
        self.totalFiles= 0
        self.totalLines= 0
        self.fragment= False
        self.logger= logging.getLogger( self.__class__.__qualname__ )
        self.log_indent= logging.getLogger( "indent." + self.__class__.__qualname__ )
        self.readdIndent( self.code_indent ) # Create context and initial lastIndent values
    def __str__( self ):
        return self.__class__.__name__
        
    def open( self, aFile ):
        """Open a file."""
        self.fileName= aFile
        self.linesWritten= 0
        self.doOpen( aFile )
        return self
    
    def doOpen( self, aFile ):
        self.logger.debug( "creating {!r}".format(self.fileName) )
    
    
    def close( self ):
        self.codeFinish() # Trailing newline for tangler only.
        self.doClose()
        self.totalFiles += 1
        self.totalLines += self.linesWritten
    
    def doClose( self ):
        self.logger.debug( "wrote {:d} lines to {!s}".format(
            self.linesWritten, self.fileName) )
    
    
    def write( self, text ):
        if text is None: return
        self.linesWritten += text.count('\n')
        self.theFile.write( text )
    
    # Context Manager
    def __enter__( self ):
        return self
    def __exit__( self, *exc ):
        self.close()
        return False
        
    

        
    def codeBlock( self, text ):
        """Indented write of a block of code. We buffer
        The spaces from the last line to act as the indent for the next line.
        """
        indent= self.context[-1]
        lines= text.split( '\n' )
        if len(lines) == 1: # Fragment with no newline.
            self.write('{!s}{!s}'.format(self.lastIndent*' ', lines[0]) )
            self.lastIndent= 0
            self.fragment= True
        else:
            first, rest= lines[:1], lines[1:]
            self.write('{!s}{!s}\n'.format(self.lastIndent*' ', first[0]) )
            for l in rest[:-1]:
                self.write( '{!s}{!s}\n'.format(indent*' ', l) )
            if rest[-1]:
                self.write( '{!s}{!s}'.format(indent*' ', rest[-1]) )
                self.lastIndent= 0
                self.fragment= True
            else:
                # Buffer a next indent
                self.lastIndent= len(rest[-1]) + indent
                self.fragment= False
    
    
    quoted_chars = [
        # Must be empty for tangling.
    ]
    
    def quote( self, aLine ):
        """Each individual line of code; often overridden by weavers to quote the code."""
        clean= aLine
        for from_, to_ in self.quoted_chars:
            clean= clean.replace( from_, to_ )
        return clean
    
    
    def codeFinish( self ):
        if self.fragment:
            self.write('\n')
    

        
    def addIndent( self, increment ):
        self.lastIndent= self.context[-1]+increment
        self.context.append( self.lastIndent )
        self.log_indent.debug( "addIndent {!s}: {!r}".format(increment, self.context) )
    def setIndent( self, indent ):
        self.lastIndent= self.context[-1]
        self.context.append( indent )
        self.log_indent.debug( "setIndent {!s}: {!r}".format(indent, self.context) )
    def clrIndent( self ):
        if len(self.context) > 1:
            self.context.pop()
        self.lastIndent= self.context[-1]
        self.log_indent.debug( "clrIndent {!r}".format(self.context) )
    def readdIndent( self, indent=0 ):
        self.lastIndent= indent
        self.context= [self.lastIndent]
        self.log_indent.debug( "readdIndent {!s}: {!r}".format(indent, self.context) )
    




class Weaver( Emitter ):
    """Format various types of XRef's and code blocks when weaving.
    RST format. 
    Requires ``..  include:: <isoamsa.txt>``
    and      ``..  include:: <isopub.txt>``
    """
    extension= ".rst" 
    code_indent= 4
    header= """\n..  include:: <isoamsa.txt>\n..  include:: <isopub.txt>\n"""
    
    def __init__( self ):
        super().__init__()
        self.reference_style= None # Must be configured.
    
        
    def doOpen( self, basename ):
        self.fileName= basename + self.extension
        self.logger.info( "Weaving {!r}".format(self.fileName) )
        self.theFile= open( self.fileName, "w" )
        self.readdIndent( self.code_indent )
    def doClose( self ):
        self.theFile.close()
        self.logger.info( "Wrote {:d} lines to {!r}".format(
            self.linesWritten, self.fileName) )
    def addIndent( self, increment=0 ):
        """increment not used when weaving"""
        self.context.append( self.context[-1] )
        self.log_indent.debug( "addIndent {!s}: {!r}".format(self.lastIndent, self.context) )
    def codeFinish( self ):
        pass # Not needed when weaving
    

    
    # Template Expansions.
    
        
    quoted_chars = [
        # prevent some RST markup from being recognized
        ('\\',r'\\'), # Must be first.
        ('`',r'\`'),
        ('_',r'\_'), 
        ('*',r'\*'),
        ('|',r'\|'),
    ]

        
    def docBegin( self, aChunk ):
        pass
    def docEnd( self, aChunk ):
        pass
    

        
    ref_template = string.Template( "${refList}" )
    ref_separator = "; "
    ref_item_template = string.Template( "$fullName (`${seq}`_)" )
    def references( self, aChunk ):
        references= aChunk.references_list( self )
        if len(references) != 0:
            refList= [ 
                self.ref_item_template.substitute( seq=s, fullName=n )
                for n,s in references ]
            return self.ref_template.substitute( refList=self.ref_separator.join( refList ) )
        else:
            return ""
    

        
    cb_template = string.Template( "\n..  _`${seq}`:\n..  rubric:: ${fullName} (${seq}) ${concat}\n..  parsed-literal::\n    :class: code\n\n" )
    
    def codeBegin( self, aChunk ):
        txt = self.cb_template.substitute( 
            seq= aChunk.seq,
            lineNumber= aChunk.lineNumber, 
            fullName= aChunk.fullName,
            concat= "=" if aChunk.initial else "+=", # RST Separator
        )
        self.write( txt )
        
    ce_template = string.Template( "\n..\n\n    ..  class:: small\n\n        |loz| *${fullName} (${seq})*. Used by: ${references}\n" )
    
    def codeEnd( self, aChunk ):
        txt = self.ce_template.substitute( 
            seq= aChunk.seq,
            lineNumber= aChunk.lineNumber, 
            fullName= aChunk.fullName,
            references= self.references( aChunk ),
        )
        self.write(txt)
    

        
    fb_template = string.Template( "\n..  _`${seq}`:\n..  rubric:: ${fullName} (${seq}) ${concat}\n..  parsed-literal::\n    :class: code\n\n" )
    
    def fileBegin( self, aChunk ):
        txt= self.fb_template.substitute(
            seq= aChunk.seq, 
            lineNumber= aChunk.lineNumber, 
            fullName= aChunk.fullName,
            concat= "=" if aChunk.initial else "+=", # RST Separator
        )
        self.write( txt )
    
    fe_template= string.Template( "\n..\n\n    ..  class:: small\n\n        |loz| *${fullName} (${seq})*.\n" )
    
    def fileEnd( self, aChunk ):
        assert len(self.references( aChunk )) == 0
        txt= self.fe_template.substitute(
            seq= aChunk.seq, 
            lineNumber= aChunk.lineNumber, 
            fullName= aChunk.fullName,
            references= [] )
        self.write( txt )
    

        
    refto_name_template= string.Template(r"|srarr|\ ${fullName} (`${seq}`_)")
    refto_seq_template= string.Template("|srarr|\ (`${seq}`_)")
    refto_seq_separator= ", "
    
    def referenceTo( self, aName, seq ):
        """Weave a reference to a chunk.
        Provide name to get a full reference.
        name=None to get a short reference."""
        if aName:
            return self.refto_name_template.substitute( fullName= aName, seq= seq )
        else:
            return self.refto_seq_template.substitute( seq= seq )
            
    def referenceSep( self ):
        """Separator between references."""
        return self.refto_seq_separator
    

        
    xref_head_template = string.Template( "\n" )
    xref_foot_template = string.Template( "\n" )
    xref_item_template = string.Template( ":${fullName}:\n    ${refList}\n" )
    xref_empty_template = string.Template( "(None)\n" )
    
    def xrefHead( self ):
        txt = self.xref_head_template.substitute()
        self.write( txt )
    
    def xrefFoot( self ):
        txt = self.xref_foot_template.substitute()
        self.write( txt )
    
    def xrefLine( self, name, refList ):
        refList= [ self.referenceTo( None, r ) for r in refList ]
        txt= self.xref_item_template.substitute( fullName= name, refList = " ".join(refList) ) # RST Separator
        self.write( txt )
    
    def xrefEmpty( self ):
        self.write( self.xref_empty_template.substitute() )
    
    name_def_template = string.Template( '[`${seq}`_]' )
    name_ref_template = string.Template( '`${seq}`_' )
    
    def xrefDefLine( self, name, defn, refList ):
        templates = { defn: self.name_def_template }
        refTxt= [ templates.get(r,self.name_ref_template).substitute( seq= r )
            for r in sorted( refList + [defn] ) 
            ]
        # Generic space separator
        txt= self.xref_item_template.substitute( fullName= name, refList = " ".join(refTxt) ) 
        self.write( txt )
    




class RST(Weaver):
    pass


class LaTeX( Weaver ):
    """LaTeX formatting for XRef's and code blocks when weaving.
    Requires \\usepackage{fancyvrb}
    """
    extension= ".tex"
    code_indent= 0
    header= """\n\\usepackage{fancyvrb}\n"""

        
    cb_template = string.Template( """\\label{pyweb${seq}}
    \\begin{flushleft}
    \\textit{Code example ${fullName} (${seq})}
    \\begin{Verbatim}[commandchars=\\\\\\{\\},codes={\\catcode`$$=3\\catcode`^=7},frame=single]\n""") # Prevent indent
    

        
    ce_template= string.Template("""
    \\end{Verbatim}
    ${references}
    \\end{flushleft}\n""") # Prevent indentation
    

        
    fb_template= cb_template
    

        
    fe_template= ce_template
    

        
    ref_item_template = string.Template( """
    \\item Code example ${fullName} (${seq}) (Sect. \\ref{pyweb${seq}}, p. \\pageref{pyweb${seq}})\n""")
    ref_template = string.Template( """
    \\footnotesize
    Used by:
    \\begin{list}{}{}
    ${refList}
    \\end{list}
    \\normalsize\n""")
    

        
    quoted_chars = [
        ("\\end{Verbatim}", "\\end\,{Verbatim}"), # Allow \end{Verbatim}
        ("\\{","\\\,{"), # Prevent unexpected commands in Verbatim
        ("$","\\$"), # Prevent unexpected math in Verbatim
    ]
    

        
    refto_name_template= string.Template("""$$\\triangleright$$ Code Example ${fullName} (${seq})""")
    refto_seq_template= string.Template("""(${seq})""")
    




class HTML( Weaver ):
    """HTML formatting for XRef's and code blocks when weaving."""
    extension= ".html"
    code_indent= 0
    header= ""
        
    cb_template= string.Template("""
    <a name="pyweb${seq}"></a>
    <!--line number ${lineNumber}-->
    <p><em>${fullName}</em> (${seq})&nbsp;${concat}</p>
    <code><pre>\n""")
    

        
    ce_template= string.Template("""
    </pre></code>
    <p>&loz; <em>${fullName}</em> (${seq}).
    ${references}
    </p>\n""")
    

        
    fb_template= string.Template("""<a name="pyweb${seq}"></a>
    <!--line number ${lineNumber}-->
    <p>``${fullName}`` (${seq})&nbsp;${concat}</p>
    <code><pre>\n""") # Prevent indent
    

        
    fe_template= string.Template( """</pre></code>
    <p>&loz; ``${fullName}`` (${seq}).
    ${references}
    </p>\n""")
    

        
    ref_item_template = string.Template(
    '<a href="#pyweb${seq}"><em>${fullName}</em>&nbsp;(${seq})</a>'
    )
    ref_template = string.Template( '  Used by ${refList}.'  )
    

        
    quoted_chars = [
        ("&", "&amp;"), # Must be first
        ("<", "&lt;"),
        (">", "&gt;"),
        ('"', "&quot;"),
    ]
    

        
    refto_name_template = string.Template(
    '<a href="#pyweb${seq}">&rarr;<em>${fullName}</em> (${seq})</a>'
    )
    refto_seq_template = string.Template(
    '<a href="#pyweb${seq}">(${seq})</a>'
    )
    

        
    xref_head_template = string.Template( "<dl>\n" )
    xref_foot_template = string.Template( "</dl>\n" )
    xref_item_template = string.Template( "<dt>${fullName}</dt><dd>${refList}</dd>\n" )
    
    name_def_template = string.Template( '<a href="#pyweb${seq}"><b>&bull;${seq}</b></a>' )
    name_ref_template = string.Template( '<a href="#pyweb${seq}">${seq}</a>' )
    
    
    



class HTMLShort( HTML ):
    """HTML formatting for XRef's and code blocks when weaving with short references."""
        
    ref_item_template = string.Template( '<a href="#pyweb${seq}">(${seq})</a>' )
    




class Tangler( Emitter ):
    """Tangle output files."""
    def __init__( self ):
        super().__init__()
        self.comment_start= None
        self.comment_end= ""
        self.include_line_numbers= False
        
    def checkPath( self ):
        if "/" in self.fileName:
            dirname, _, _ = self.fileName.rpartition("/")
            try:
                os.makedirs( dirname )
                self.logger.info( "Creating {!r}".format(dirname) )
            except OSError as e:
                # Already exists.  Could check for errno.EEXIST.
                self.logger.debug( "Exception {!r} creating {!r}".format(e, dirname) )
    def doOpen( self, aFile ):
        self.fileName= aFile
        self.checkPath()
        self.theFile= open( aFile, "w" )
        self.logger.info( "Tangling {!r}".format(aFile) )
    def doClose( self ):
        self.theFile.close()
        self.logger.info( "Wrote {:d} lines to {!r}".format(
            self.linesWritten, self.fileName) )
    

        
    def codeBegin( self, aChunk ):
        self.log_indent.debug( "<tangle {!s}:".format(aChunk.fullName) )
        if self.include_line_numbers and self.comment_start is not None:
            self.write( "\n{start!s} Web: {filename!s}:{line:d} {fullname!s}({seq:d}) {end!s}\n".format( 
                start=  self.comment_start, 
                webfilename= aChunk.web().webFileName, 
                filename= aChunk.fileName,
                fullname= aChunk.fullName, 
                name= aChunk.name,
                seq= aChunk.seq, 
                line= aChunk.lineNumber, 
                end= self.comment_end) )
    

        
    def codeEnd( self, aChunk ):
        self.log_indent.debug( ">{!s}".format(aChunk.fullName) )
    




class TanglerMake( Tangler ):
    """Tangle output files, leaving files untouched if there are no changes."""
    def __init__( self, *args ):
        super().__init__( *args )
        self.tempname= None
        
    def doOpen( self, aFile ):
        fd, self.tempname= tempfile.mkstemp( dir=os.curdir )
        self.theFile= os.fdopen( fd, "w" )
        self.logger.info( "Tangling {!r}".format(aFile) )
    

        
    def doClose( self ):
        self.theFile.close()
        try:
            same= filecmp.cmp( self.tempname, self.fileName )
        except OSError as e:
            same= False # Doesn't exist.  Could check for errno.ENOENT
        if same:
            self.logger.info( "No change to {!r}".format(self.fileName) )
            os.remove( self.tempname )
        else:
            # Windows requires the original file name be removed first.
            self.checkPath()
            try: 
                os.remove( self.fileName )
            except OSError as e:
                pass # Doesn't exist.  Could check for errno.ENOENT
            os.rename( self.tempname, self.fileName )
            self.logger.info( "Wrote {:d} lines to {!r}".format(
                self.linesWritten, self.fileName) )
    





class Reference:
    def __init__( self ):
        self.logger= logging.getLogger( self.__class__.__qualname__ )
    def chunkReferencedBy( self, aChunk ):
        """Return a list of Chunks."""
        pass

class SimpleReference( Reference ):
    def chunkReferencedBy( self, aChunk ):
        refBy= aChunk.referencedBy
        return refBy

class TransitiveReference( Reference ):
    def chunkReferencedBy( self, aChunk ):
        refBy= aChunk.referencedBy
        self.logger.debug( "References: {!s}({:d}) {!r}".format(aChunk.name, aChunk.seq, refBy) )
        return self.allParentsOf( refBy )
    def allParentsOf( self, chunkList, depth=0 ):
        """Transitive closure of parents via recursive ascent.
        """
        final = []
        for c in chunkList:
            final.append( c )
            final.extend( self.allParentsOf( c.referencedBy, depth+1 ) )
        self.logger.debug( "References: {0:>{indent}s} {1!s}".format('--', final, indent=2*depth) )
        return final
 



class Action:
    """An action performed by pyWeb."""
    def __init__( self, name ):
        self.name= name
        self.web= None
        self.options= None
        self.start= None
        self.logger= logging.getLogger( self.__class__.__qualname__ )
    def __str__( self ):
        return "{!s} [{!s}]".format( self.name, self.web )
        
    def __call__( self ):
        self.logger.info( "Starting {!s}".format(self.name) )
        self.start= time.process_time()
    

        
    def duration( self ):
        """Return duration of the action."""
        return (self.start and time.process_time()-self.start) or 0
    def summary( self ):
        return "{!s} in {:0.2f} sec.".format( self.name, self.duration() )
    




class ActionSequence( Action ):
    """An action composed of a sequence of other actions."""
    def __init__( self, name, opSequence=None ):
        super().__init__( name )
        if opSequence: self.opSequence= opSequence
        else: self.opSequence= []
    def __str__( self ):
        return "; ".join( [ str(x) for x in self.opSequence ] )
        
    def __call__( self ):
        for o in self.opSequence:
            o.web= self.web
            o.options= self.options
            o()
    

        
    def append( self, anAction ):
        self.opSequence.append( anAction )
    

        
    def summary( self ):
        return ", ".join( [ o.summary() for o in self.opSequence ] )
    




class WeaveAction( Action ):
    """Weave the final document."""
    def __init__( self ):
        super().__init__( "Weave" )
    def __str__( self ):
        return "{!s} [{!s}, {!s}]".format( self.name, self.web, self.theWeaver )

        
    def __call__( self ):
        super().__call__()
        if not self.options.theWeaver: 
            # Examine first few chars of first chunk of web to determine language
            self.options.theWeaver= self.web.language() 
            self.logger.info( "Using {0}".format(self.options.theWeaver.__class__.__name__) )
        self.options.theWeaver.reference_style= self.options.reference_style
        try:
            self.web.weave( self.options.theWeaver )
            self.logger.info( "Finished Normally" )
        except Error as e:
            self.logger.error(
                "Problems weaving document from {!s} (weave file is faulty).".format(
                self.web.webFileName) )
            #raise
    

        
    def summary( self ):
        if self.options.theWeaver and self.options.theWeaver.linesWritten > 0:
            return "{!s} {:d} lines in {:0.2f} sec.".format( self.name, 
            self.options.theWeaver.linesWritten, self.duration() )
        return "did not {!s}".format( self.name, )
    




class TangleAction( Action ):
    """Tangle source files."""
    def __init__( self ):
        super().__init__( "Tangle" )
        
    def __call__( self ):
        super().__call__()
        self.options.theTangler.include_line_numbers= self.options.tangler_line_numbers
        try:
            self.web.tangle( self.options.theTangler )
        except Error as e:
            self.logger.error( 
                "Problems tangling outputs from {!r} (tangle files are faulty).".format(
                self.web.webFileName) )
            #raise
    

        
    def summary( self ):
        if self.options.theTangler and self.options.theTangler.linesWritten > 0:
            return "{!s} {:d} lines in {:0.2f} sec.".format( self.name, 
            self.options.theTangler.totalLines, self.duration() )
        return "did not {!r}".format( self.name, )
    




class LoadAction( Action ):
    """Load the source web."""
    def __init__( self ):
        super().__init__( "Load" )
    def __str__( self ):
        return "Load [{!s}, {!s}]".format( self.webReader, self.web )
        
    def __call__( self ):
        super().__call__()
        self.webReader= self.options.webReader
        self.webReader.command= self.options.command
        self.webReader.permitList= self.options.permitList 
        self.web.webFileName= self.options.webFileName
        error= "Problems with source file {!r}, no output produced.".format(
                self.options.webFileName)
        try:
            self.webReader.load( self.web, self.options.webFileName )
            if self.webReader.errors != 0:
                self.logger.error( error )
                raise Error( "Syntax Errors in the Web" )
            self.web.createUsedBy()
            if self.webReader.errors != 0:
                self.logger.error( error )
                raise Error( "Internal Reference Errors in the Web" )        
        except Error as e:
            self.logger.error(error)
            raise # Older design.
        except IOError as e:
            self.logger.error(error)
            raise
    

        
    def summary( self ):
        return "{!s} {:d} lines from {:d} files in {:0.2f} sec.".format( 
            self.name, self.webReader.totalLines, 
            self.webReader.totalFiles, self.duration() )
    






class Application:
    def __init__( self ):
        self.logger= logging.getLogger( self.__class__.__qualname__ )
                
        self.defaults= argparse.Namespace(
            verbosity= logging.INFO,
            command= '@',
            weaver= 'rst', 
            skip= '', # Don't skip any steps
            permit= '', # Don't tolerate missing includes
            reference= 's', # Simple references
            tangler_line_numbers= False,
            )
        self.expand( self.defaults )
        
        # Primitive Actions
        self.loadOp= LoadAction()
        self.weaveOp= WeaveAction()
        self.tangleOp= TangleAction()
        
        # Composite Actions
        self.doWeave= ActionSequence( "load and weave", [self.loadOp, self.weaveOp] )
        self.doTangle= ActionSequence( "load and tangle", [self.loadOp, self.tangleOp] )
        self.theAction= ActionSequence( "load, tangle and weave", [self.loadOp, self.tangleOp, self.weaveOp] )

        
    def parseArgs( self ):
        p = argparse.ArgumentParser()
        p.add_argument( "-v", "--verbose", dest="verbosity", action="store_const", const=logging.INFO )
        p.add_argument( "-s", "--silent", dest="verbosity", action="store_const", const=logging.WARN )
        p.add_argument( "-d", "--debug", dest="verbosity", action="store_const", const=logging.DEBUG )
        p.add_argument( "-c", "--command", dest="command", action="store" )
        p.add_argument( "-w", "--weaver", dest="weaver", action="store" )
        p.add_argument( "-x", "--except", dest="skip", action="store", choices=('w','t') )
        p.add_argument( "-p", "--permit", dest="permit", action="store" )
        p.add_argument( "-r", "--reference", dest="reference", action="store", choices=('t', 's') )
        p.add_argument( "-n", "--linenumbers", dest="tangler_line_numbers", action="store_true" )
        p.add_argument( "files", nargs='+' )
        config= p.parse_args( namespace=self.defaults )
        self.expand( config )
        return config
        
    def expand( self, config ):
        """Translate the argument values from simple text to useful objects.
        Weaver. Tangler. WebReader.
        """
        if config.reference == 't':
            config.reference_style = TransitiveReference() 
        elif config.reference == 's':
            config.reference_style = SimpleReference()
        else:
            raise Error( "Improper configuration" )
    
        try:
            weaver_class= weavers[config.weaver.lower()]
        except KeyError:
            module_name, _, class_name = config.weaver.partition('.')
            weaver_module = __import__(module_name)
            weaver_class = weaver_module.__dict__[class_name]
            if not issubclass(weaver_class, Weaver):
                raise TypeError( "{0!r} not a subclass of Weaver".format(weaver_class) )
        config.theWeaver= weaver_class()
        
        config.theTangler= TanglerMake()
        
        if config.permit:
            # save permitted errors, usual case is ``-pi`` to permit ``@i`` include errors
            config.permitList= [ '{!s}{!s}'.format( config.command, c ) for c in config.permit ]
        else:
            config.permitList= []
    
        config.webReader= WebReader()
    
        return config
    
    

        
    def process( self, config ):
        root= logging.getLogger()
        root.setLevel( config.verbosity )
        self.logger.debug( "Setting root log level to {!r}".format( 
            logging.getLevelName(root.getEffectiveLevel()) ) )
        
        if config.command:
            self.logger.debug( "Command character {!r}".format(config.command) )
            
        if config.skip:
            if config.skip.lower().startswith('w'): # not weaving == tangling
                self.theAction= self.doTangle
            elif config.skip.lower().startswith('t'): # not tangling == weaving
                self.theAction= self.doWeave
            else:
                raise Exception( "Unknown -x option {!r}".format(config.skip) )
    
        self.logger.info( "Weaver {!s}".format(config.theWeaver) )
    
        for f in config.files:
            w= Web() # New, empty web to load and process.
            self.logger.info( "{!s} {!r}".format(self.theAction.name, f) )
            config.webFileName= f
            self.theAction.web= w
            self.theAction.options= config
            self.theAction()
            self.logger.info( self.theAction.summary() )
    



# Global list of available weaver classes.
weavers = {
    'html':  HTML,
    'htmlshort': HTMLShort,
    'latex': LaTeX,
    'rst': RST, 
}


class Logger:
    def __init__( self, dict_config=None, **kw_config ):
        self.dict_config= dict_config
        self.kw_config= kw_config
    def __enter__( self ):
        if self.dict_config:
            logging.config.dictConfig( self.dict_config )
        else:
            logging.basicConfig( **self.kw_config )
        return self
    def __exit__( self, *args ):
        logging.shutdown()
        return False

log_config= dict(
    version= 1,
    disable_existing_loggers= False, # Allow pre-existing loggers to work.
    handlers= {
        'console': {
            'class': 'logging.StreamHandler',
            'stream': 'ext://sys.stderr',
            'formatter': 'basic',
        },
    },
    formatters = {
        'basic': {
            'format': "{levelname}:{name}:{message}",
            'style': "{",
        }
    },
    
    root= { 'handlers': ['console'], 'level': logging.INFO, },
    
    #For specific debugging support...
    loggers= {
    #    'RST': { 'level': logging.DEBUG },
    #    'TanglerMake': { 'level': logging.DEBUG },
    #    'WebReader': { 'level': logging.DEBUG },
    },
)


def main():
    a= Application()
    config= a.parseArgs()
    a.process(config)

if __name__ == "__main__":
    with Logger( log_config ):
        main( )

